<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/백준] 1197번: 최소 스패닝 트리</title>
	  <link>/blog//algo-boj1197</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1197</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1197">https://www.acmicpc.net/problem/1197</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>크루스칼 알고리즘을 이용한다(프림도 가능).</li>
  <li>가중치 기준 우선순위 큐에서 노드를 뽑는다.</li>
  <li>Union-Find를 이용해 start와 end가 연결되어있는지 확인한다(공통 부모 체크).</li>
  <li>아닐 경우 둘을 연결하고 가중치 합을 누적한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="n">pq</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">e</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 부모는 나 자신으로 초기화</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">e</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span> <span class="c1">// 큐에 다 넣기</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">());</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 가중치 누적 합 계산</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">Node</span> <span class="n">node</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="c1">// start, end의 부모 찾기</span>
			<span class="kt">int</span> <span class="n">parentS</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">start</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">parentE</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span><span class="o">);</span>
			<span class="c1">// 부모가 다르다면(연결되어있지 않다면)</span>
			<span class="k">if</span><span class="o">(</span><span class="n">parentS</span><span class="o">!=</span><span class="n">parentE</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">union</span><span class="o">(</span><span class="n">parentS</span><span class="o">,</span> <span class="n">parentE</span><span class="o">);</span> <span class="c1">// 둘을 연결</span>
				<span class="n">sum</span><span class="o">+=</span><span class="n">node</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span> <span class="c1">// 가중치 계산</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]==</span><span class="n">x</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">b</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">start</span><span class="o">=</span><span class="n">s</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">end</span><span class="o">=</span><span class="n">e</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 가중치 기준 오름차순 정렬</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">크루스칼 알고리즘을 이용한다</span></strong>
    <ul>
      <li>MST는 크루스칼 또는 프림으로 해결할 수 있다.</li>
      <li>E 개수가 적으면 크루스칼, V 개수가 적은 것은 프림을 쓰는게 좋다.</li>
      <li>크루스칼은 V가 작은 것부터 체크한다. 이를 위해 우선순위 큐를 이용한다. 가중치가 작은 것부터 확인하기 때문에 최소 weight로 노드들을 연결할 수 있다.</li>
      <li>사이클을 방지하기 위해 두 노드(start, end)의 최상위 부모를 체크하고, 부모가 다르면 두 노드가 연결되어 있지 않은 것이므로 연결한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[Java][자바][백준][1197번] 최소 스패닝 트리 - 크루스칼 알고리즘 <a href="https://ju-nam2.tistory.com/112">https://ju-nam2.tistory.com/112</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 10282번: 해킹</title>
	  <link>/blog//algo-boj10282</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj10282</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/10282">https://www.acmicpc.net/problem/10282</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>다익스트라를 이용하여 노드에서 다른 노드로 가는 최소 weight를 기준으로 이동한다.</li>
  <li>처음 방문하는 노드이면 cnt++하여 전파되는 컴퓨터의 개수를 센다.</li>
  <li>dist[] 배열에서 INF 값을 제외한 최댓값이 감염되는 최소시간이 된다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dist</span><span class="o">;</span>
	<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">tc</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="k">while</span><span class="o">(</span><span class="n">tc</span><span class="o">--&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 총 컴퓨터 수</span>
			<span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 감염 정보 수</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 시작 컴퓨터</span>
			
			<span class="n">dist</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 0번은 사용 안함</span>
			<span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// INF로 초기화</span>
			<span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> 
				<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;());</span>
			<span class="n">cnt</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 시작 컴퓨터는 이미 감염되었으므로</span>
			
			<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
			<span class="n">dist</span><span class="o">[</span><span class="n">c</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 시작 노드이므로 0으로 초기화</span>
			
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">d</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>				
				<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">s</span><span class="o">));</span> <span class="c1">// b-&gt;a로 감염됨</span>
			<span class="o">}</span>

			<span class="n">solve</span><span class="o">(</span><span class="n">pq</span><span class="o">);</span>
			<span class="c1">// dist에서 INF를 제외한 새 배열 생성</span>
			<span class="kt">int</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">dist</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k</span><span class="o">!=</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
			<span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cnt</span><span class="o">+</span><span class="s">" "</span><span class="o">+</span><span class="n">result</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
		<span class="o">}</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">Node</span> <span class="n">node</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="c1">// 내 weight가 계산된 dist보다 크다면 갱신할 필요 없음</span>
			<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">weight</span><span class="o">&gt;</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
			
			<span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="nl">n:</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// node에서 갈 수 있는 n</span>
				<span class="c1">// n으로 가는 것 중 node에서 n으로 가는 경우가 더 최단이라면</span>
				<span class="k">if</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]&gt;</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">]+</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">if</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]==</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="n">cnt</span><span class="o">++;</span> <span class="c1">// n 방문이 처음이라면</span>
					<span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]=</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">]+</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
					<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">,</span> <span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]));</span>
				<span class="o">}</span>
				
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">idx</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// weight 기준 오름차순 정렬</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">초기화 및 다익스트라 실행 준비</span></strong>
    <ul>
      <li>컴퓨터 인덱스는 1부터 시작하므로 dist, list를 n+1 크기로 생성한다.</li>
      <li>cnt는 감염 컴퓨터 개수로, 시작 컴퓨터가 이미 감염되었으므로 1로 초기화한다.</li>
      <li>우선순위 큐 pq에 시작 노드를 넣는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">다익스트라</span></strong>
    <ul>
      <li>pq는 우선순위 큐이기 때문에 weight(감염 시간)이 작은 순으로 뽑힌다.</li>
      <li>뽑힌 노드 node의 weight를 체크하여 node에서 다음으로 이동할 수 있는지 확인해야 한다.</li>
      <li>예를 들어, 테스트케이스 2에서 1-&gt;3으로 가는 것 보다 1-&gt;2-&gt;3으로 가는 게 최단이다. 이를 거르는 작업이 처음 if문이다.</li>
      <li>for문을 통해 node에서 갈 수 있는, 연결된 노드 n을 하나씩 체크한다.</li>
      <li>n으로 가기 위해 node에서 n으로 가는 것이 기존 방법보다 최단이면 해당 값으로 갱신한다.</li>
      <li>이때 n이 처음 방문하는 노드라면 cnt++하여 감염된 컴퓨터가 하나 늘었음을 표시한다.</li>
      <li>pq에 삽입하여 n에서 갈 수 있는 노드들을 확인할 수 있도록 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">감염 수와 최소 시간을 출력한다</span></strong>
    <ul>
      <li>감염 수는 cnt를 출력하면 된다.</li>
      <li>최소 시간은 dist에서 INF(Integer.MAX_VALUE)를 제외한 최댓값을 출력하면 된다.</li>
      <li>처음에는 max 변수를 두고 dist 배열에 값이 변경될 때마다 Math.max()를 이용하여 최댓값을 저장하도록 했는데, 그러면 기존 dist[i]보다 더 작은 dist[i]를 발견하여 값을 수정하였을 때, max에도 수정된 값으로 들어가야하지만 Math.max()로 인해 값이 갱신되지 않음을 알았다.</li>
      <li>따라서 람다식을 이용하여 dist에서 INF를 제외한 배열을 새로 만든 뒤(result), 이를 오름차순 정렬하여 마지막 값을 뽑았다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[백준 10282] - 해킹 <a href="https://soobarkbar.tistory.com/113">https://soobarkbar.tistory.com/113</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1525번: 퍼즐</title>
	  <link>/blog//algo-boj1525</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1525</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1525">https://www.acmicpc.net/problem/1525</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>map 숫자를 String 한 줄로 표현한다.</li>
  <li>String이 “123456780”이 아니라면 큐에 넣고 BFS 시작한다.</li>
  <li>String에서 0의 위치를 찾는다.</li>
  <li>거기서 사방으로 갈 수 있는 위치를 찾고 범위를 체크한다.</li>
  <li>swap(0, 새로운 인덱스)</li>
  <li>변경값이 “123456780”이면 맵에서 현재 String의 value+1을 리턴한다.</li>
  <li>맵에 없으면 맵, 큐에 push한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span> <span class="c1">// BFS 돌리기 위함</span>
		<span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// 중복 체크</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
		<span class="o">}</span>
		
		<span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"123456780"</span><span class="o">))</span> <span class="c1">// 이미 완성된 퍼즐</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="mi">0</span><span class="o">);</span>
			<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>		
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bfs</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">map</span><span class="o">));</span>			
		<span class="o">}</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">dotX</span><span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">dotY</span><span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">zeroIdx</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span> <span class="c1">// 0 위치 찾기</span>
			<span class="kt">int</span> <span class="n">row</span><span class="o">=</span><span class="n">zeroIdx</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// map에서 행 위치</span>
			<span class="kt">int</span> <span class="n">col</span><span class="o">=</span><span class="n">zeroIdx</span><span class="o">%</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// 열 위치</span>
			
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 이동 가능한 범위 체크</span>
				<span class="kt">int</span> <span class="n">xx</span><span class="o">=</span><span class="n">row</span><span class="o">+</span><span class="n">dotX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="kt">int</span> <span class="n">yy</span><span class="o">=</span><span class="n">col</span><span class="o">+</span><span class="n">dotY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="k">if</span><span class="o">(</span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">xx</span><span class="o">&gt;=</span><span class="mi">3</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&gt;=</span><span class="mi">3</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>				
				<span class="kt">int</span> <span class="n">swapIdx</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">xx</span><span class="o">+</span><span class="n">yy</span><span class="o">;</span> <span class="c1">// 2차원 인덱스를 1차원으로 변환</span>
				
				<span class="c1">// 0과 바꿀 자리를 swap</span>
				<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
				<span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">swapIdx</span><span class="o">);</span>
				<span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">swapIdx</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">);</span>
				<span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">zeroIdx</span><span class="o">,</span> <span class="n">ch</span><span class="o">);</span>
				
				<span class="c1">// 정답 찾음</span>
				<span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"123456780"</span><span class="o">))</span> 
					<span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
				
				<span class="c1">// 새로 만들어진 문자열인 경우</span>
				<span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()))</span> <span class="o">{</span>
					<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> <span class="c1">// 큐에 넣어 나중에 다시 체크</span>
					<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">2차원 map을 1차원 String으로 변환하여 사용한다</span></strong>
    <ul>
      <li>시간과 메모리의 제한이 있기 때문에, map의 숫자들을 한 줄로 표현하고, 인덱스별로 map에서 행, 열 위치를 찾아 swap하는 방식으로 구현한다.</li>
      <li>따라서 BufferedReader로 행을 받은 후, 공백을 제거하여 StringBuilder에 저장하였다.</li>
      <li>저장한 sb가 “123456780”이라면 bfs를 돌릴 필요가 없으므로 바로 0을 리턴하고 종료한다. BFS를 돌게 되면 리턴 값이 2가 되므로 조심해야한다.</li>
      <li>아닐 경우, 큐와 맵에 sb를 넣는다.</li>
      <li>맵의 K는 현재 숫자 문자열, V는 K가 되기까지 카운트한 횟수이다. 따라서 처음에는 0을 넣어야 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">BFS로 숫자를 바꾸며 조건에 맞는지 체크한다</span></strong>
    <ul>
      <li>큐에서 뽑은 값을 str에 저장한다.</li>
      <li>str에서 0의 위치를 찾아 zeroIdx에 저장한다.</li>
      <li>map에서 0의 위치 주변으로 바꿀 값을 찾아야 하기 때문에 map에서 0의 위치(i, j)를 찾아야 한다.</li>
      <li>행은 zeroIdx를 3으로 나눈 몫, 열은 나머지가 된다.</li>
      <li>찾은 row, col 주변으로 갈 수 있는 곳을 for문을 통해 찾는다.</li>
      <li>인덱스 범위를 체크한다.</li>
      <li>2차원 인덱스를 다시 1차원으로 변환하여 swapIdx에 넣는다.</li>
      <li>이제 0(zeroIdx)과 바꿀 값(swapIdx)를 바꿔준다.</li>
      <li>String에서도 바꿀 수 있지만 StringBuilder가 문자열 삽입 등에 더 최적화되어있으므로 str을 StringBuilder로 바꿔서 swap을 진행한다.</li>
      <li>바꿀 인덱스의 값을 ch에 저장하고, setCharAt()을 이용하여 문자열을 바꾼다.</li>
      <li>바꾼 문자열 sb.toString()이 “123456780”이라면 정답을 찾은 것이다. 현재 문자열 str의 카운트 횟수를 map에서 찾아 +1한 값을 리턴한다.</li>
      <li>아닐 경우 바꾼 문자열이 이전에 만든 적이 있는 것은 아닌지 체크해야한다. 큐에는 새로 만든 문자열만 들어가야 하므로(그래야 같은 경우를 또 탐색하는 것을 방지할 수 있다) 맵에서 새로 만든 문자열이 존재하는지 체크하고, 없을 경우에 큐와 맵에 삽입한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1158번: 요세푸스 문제</title>
	  <link>/blog//algo-boj1158</link>
	  <author></author>
	  <pubDate>2020-10-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1158</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1158">https://www.acmicpc.net/problem/1158</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>큐에 값을 넣는다.</li>
  <li>k번째가 아니면 다시 뒤에 넣고, 맞으면 StringBuilder에 저장한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		
		<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&lt;"</span><span class="o">);</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">// 큐에 삽입</span>
		
		<span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">cnt</span><span class="o">++;</span>
			<span class="k">if</span><span class="o">(</span><span class="n">cnt</span><span class="o">%</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">", "</span><span class="o">);</span> <span class="c1">// k번째라면</span>
			<span class="k">else</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// 아니라면 뒤에 삽입</span>
		<span class="o">}</span>
		
		<span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">2</span><span class="o">,</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="c1">// 마지막에 콤마와 띄어쓰기가 있으므로 삭제</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201024_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>배열이나 ArrayList의 인덱스를 가지고 for문 돌리면, 원소의 삭제 삽입이 반복되므로 오류가 발생할 수 있다.</li>
      <li>따라서 큐를 이용한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>cnt는 이제 뽑을 원소가 몇 번째 값인지 체크한다.</li>
      <li>k의 배수 번째 값이라면 제거할 수 있다. 따라서 StringBuilder에 넣는다.</li>
      <li>아닐 경우 뒤에 삽입하여 순서를 다시 받는다.</li>
      <li>StringBuilder 생성이 끝나면 마지막에 “, “가 들어있기 때문에 delete()를 이용하여 삭제한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 14719번: 빗물</title>
	  <link>/blog//algo-boj14719</link>
	  <author></author>
	  <pubDate>2020-10-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj14719</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/14719">https://www.acmicpc.net/problem/14719</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>i 위치 기준 왼쪽과 오른쪽에서 가장 높은 높이를 구한다(자신 포함).</li>
  <li>‘왼쪽 오른쪽 중 작은 높이-내 높이’가 i 위치에서 빗물 넓이이다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">w</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
		<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 높이 저장</span>
			<span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">l</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">l</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// 왼쪽에서 가장 큰 높이 구하기</span>
				<span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="kt">int</span> <span class="n">right</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">r</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">r</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 오른쪽에서 가장 큰 높이</span>
				<span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])-</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
			<span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">sum</span><span class="o">+=</span><span class="n">size</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201024_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">왼쪽과 오른쪽에서 큰 높이를 구한다</span></strong>
    <ul>
      <li>i번째 빗물 넓이는 왼쪽과 오른쪽의 큰 높이 중 작은 값을 택한 곳 만큼 올라가 있다.</li>
      <li>거기서 본인 높이를 빼면 넓이이다(i번째의 w는 1이므로 넓이 계산은 필요 없다).</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11505번: 구간 곱 구하기</title>
	  <link>/blog//algo-boj11505</link>
	  <author></author>
	  <pubDate>2020-10-23T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11505</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11505">https://www.acmicpc.net/problem/11505</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>세그먼트 트리를 이용하여 구간 곱을 구한다.</li>
  <li>구간 합 구하기(<a href="https://iamheesoo.github.io/blog/algo-boj2042">https://iamheesoo.github.io/blog/algo-boj2042</a>)와 전체적인 틀은 같으나 update시 리프노트에서 루트로 올라가며 갱신한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">input</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">tree</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">MOD</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="n">input</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">tree</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">*</span><span class="mi">4</span><span class="o">];</span>	
		<span class="n">MOD</span><span class="o">=</span><span class="mi">1000000007</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="n">input</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="n">init</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span> <span class="c1">// 트리 생성</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">+</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">input</span><span class="o">[</span><span class="n">b</span><span class="o">]=</span><span class="n">c</span><span class="o">;</span>
				<span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span>  <span class="n">c</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">==</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">input</span><span class="o">[</span><span class="n">left</span><span class="o">];</span>		
		
		<span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">init</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">)*</span><span class="n">init</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">)%</span><span class="n">MOD</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
		<span class="c1">// 세그먼트 트리 덧셈과 달리 리프노드에서 루트로 올라가며(재귀) 업데이트</span>
		<span class="k">if</span><span class="o">(</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">idx</span><span class="o">&gt;</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">];</span> <span class="c1">// 갱신할 값이 포함된 범위가 아닐 경우	</span>
		<span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">==</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">c</span><span class="o">;</span> <span class="c1">// 리프노드</span>
		
		<span class="c1">// 자식의 값을 이용해 갱신</span>
		<span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">idx</span><span class="o">,</span> <span class="n">c</span><span class="o">)*</span><span class="n">update</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">idx</span><span class="o">,</span> <span class="n">c</span><span class="o">)%</span><span class="n">MOD</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rangeA</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rangeB</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">rangeA</span> <span class="o">||</span> <span class="n">left</span><span class="o">&gt;</span><span class="n">rangeB</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 범위 초과</span>
		<span class="k">if</span><span class="o">(</span><span class="n">rangeA</span><span class="o">&lt;=</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">&lt;=</span><span class="n">rangeB</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">];</span> <span class="c1">// 범위 안에 속함</span>
		
		<span class="c1">// 범위에 걸쳐 있는 경우 자식으로 내려가며 범위 좁히기</span>
		<span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		<span class="k">return</span> <span class="nf">sum</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">rangeA</span><span class="o">,</span> <span class="n">rangeB</span><span class="o">)*</span><span class="n">sum</span><span class="o">(</span><span class="n">node</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">rangeA</span><span class="o">,</span> <span class="n">rangeB</span><span class="o">)%</span><span class="n">MOD</span><span class="o">;</span>
		
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201023_1.PNG" alt="실행결과" />
🤟 성공 🤟<br />
update 시 루트에서 리프노드로 내려가는 코드로 작성하였으나 실패했다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">update</span></strong>
    <ul>
      <li>N개의 숫자 중 하나가 0으로 초기화되면 갱신이 안되기 때문에 리프 노드부터 갱신을 하며 루트로 올라가야 한다.</li>
      <li>재귀를 이용하여 리프노드까지 내려간 후, 리프노드를 갱신 후 리턴 값을 가지고 다시 올라가며 트리 노드를 갱신한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<ul>
  <li>[BOJ] 백준 11505번 : 구간 곱 구하기 (JAVA) <a href="https://steady-coding.tistory.com/125">https://steady-coding.tistory.com/125</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 2042번: 구간 합 구하기</title>
	  <link>/blog//algo-boj2042</link>
	  <author></author>
	  <pubDate>2020-10-19T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj2042</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/2042">https://www.acmicpc.net/problem/2042</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>세그먼트 트리를 이용한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">input</span><span class="o">,</span> <span class="n">tree</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">K</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="n">tree</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">N</span><span class="o">*</span><span class="mi">4</span><span class="o">];</span>
		<span class="n">input</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 인덱스 1부터 사용</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">N</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> 
			<span class="n">input</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="n">init</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">);</span> <span class="c1">// 세그먼트 트리 생성</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="o">+</span><span class="n">K</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// b번째를 c로 변경</span>
				<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">long</span> <span class="n">c</span><span class="o">=</span><span class="n">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">long</span> <span class="n">diff</span><span class="o">=</span><span class="n">c</span><span class="o">-</span><span class="n">input</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
				<span class="n">input</span><span class="o">[</span><span class="n">b</span><span class="o">]=</span><span class="n">c</span><span class="o">;</span>
				<span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span> <span class="c1">// b~c 합 출력</span>
				<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">N</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
	<span class="o">}</span>
	
	 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">init</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">==</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">input</span><span class="o">[</span><span class="n">left</span><span class="o">];</span> <span class="c1">// 리프노드</span>
		 
		 <span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		 <span class="c1">// (node)번째 노드 합=왼쪽 자식(2*node) 합+오른쪽 자식(2*node+1) 합</span>
		 <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">init</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">node</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">)+</span><span class="n">init</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
	 <span class="o">}</span>
	 
	 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">now</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">long</span> <span class="n">diff</span><span class="o">)</span> <span class="o">{</span>
		 <span class="c1">// now: 현재 노드 위치,  left right: 현재 노드의 합 범위, idx: 바꾸고자 하는 노드 인덱스, diff: 더할 값</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">left</span> <span class="o">||</span> <span class="n">idx</span><span class="o">&gt;</span><span class="n">right</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">// 현재 범위에 idx가 포함되지 않는다면 종료</span>
		 
		 <span class="c1">// 현재 범위(left~right)에 idx가 포함되는 경우임</span>
		 <span class="n">tree</span><span class="o">[</span><span class="n">now</span><span class="o">]+=</span><span class="n">diff</span><span class="o">;</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">left</span><span class="o">!=</span><span class="n">right</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 아직 탐색할 수 있는 범위가 더 있다면</span>
			 <span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
			 <span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">now</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">idx</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span>
			 <span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">now</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">idx</span><span class="o">,</span> <span class="n">diff</span><span class="o">);</span>
		 <span class="o">}</span>
	 <span class="o">}</span>
	 
	 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">long</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">now</span><span class="o">,</span> <span class="kt">int</span> <span class="n">left</span><span class="o">,</span> <span class="kt">int</span> <span class="n">right</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rangeA</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rangeB</span><span class="o">)</span> <span class="o">{</span>
		 <span class="c1">// now: 현재 노드 위치, left right: 현재 노드의 합 범위, rangeA rangeB: 찾아야 할 범위</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">right</span><span class="o">&lt;</span><span class="n">rangeA</span> <span class="o">||</span> <span class="n">left</span><span class="o">&gt;</span><span class="n">rangeB</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 찾아야 할 범위를 벗어나면</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">rangeA</span><span class="o">&lt;=</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">right</span><span class="o">&lt;=</span><span class="n">rangeB</span><span class="o">)</span> <span class="k">return</span> <span class="n">tree</span><span class="o">[</span><span class="n">now</span><span class="o">];</span> <span class="c1">// 찾아야 할 범위 안에 들어왔다면 현재 위치의 구간 합 리턴</span>
		 
		 <span class="c1">// 걸쳐 있을 경우</span>
		 <span class="kt">int</span> <span class="n">mid</span><span class="o">=(</span><span class="n">left</span><span class="o">+</span><span class="n">right</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
		 <span class="k">return</span> <span class="nf">sum</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">now</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">mid</span><span class="o">,</span> <span class="n">rangeA</span><span class="o">,</span> <span class="n">rangeB</span><span class="o">)+</span><span class="n">sum</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">now</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">right</span><span class="o">,</span> <span class="n">rangeA</span><span class="o">,</span> <span class="n">rangeB</span><span class="o">);</span>
	 <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201019_2.PNG" alt="실행결과" />
🤟 성공 🤟<br />
update할 때 input[b]=c로 바꾸지 않아서 틀렸었다.<br />
1 2 2<br />
0<br />
1 1 1<br />
2 1 1<br />
1 1 2<br />
2 1 1</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">세그먼트 트리를 생성한다</span></strong>
    <ul>
      <li>N개의 input값을 배열에 저장한다.</li>
      <li>input[1]부터 저장한다. input의 인덱스 i는 트리에서 i번째 노드임을 뜻한다. 만약 0부터 시작하면 0의 자식노드가 0과 1이 되는 모순이 발생하므로 1부터 시작해야 한다. (i의 자식노드는 2i, 2i+1)</li>
      <li>init()을 호출하여 트리를 생성한다.</li>
      <li>init()의 파라미터 node는 현재 노드 인덱스, left right는 현재 위치에서 구간 합 범위이다(left&lt;= ~ &lt;=right).</li>
      <li>노드는 1부터 시작하므로 1, 루트(1)의 구간 합 범위는 1~N이므로 init(1, 1, N)이다.</li>
      <li>left==right는 리프 노드라는 뜻이므로 현재 위치(node)에 input[left]를 저장한다(left~right의 구간 합은 input[left]이므로).</li>
      <li>리프 노드가 아니라면 자식 노드(2i, 2i+1)를 재귀로 호출한다. 두 자식 노드의 구간 합이 tree[node]값이 된다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">update()</span></strong>
    <ul>
      <li>main에서 b번째 값을 c로 변경하는 작업이다.</li>
      <li>조심해야 할 것은 input[b]도 c로 변경해야 한다는 것이다. update에서 더해야 할 값 diff를 계산하기 위해 input 배열을 계속 확인하기 때문이다.</li>
      <li>diff는 b번째 값(input[b])가 c가 되기 위해 더해야 하는 값이다. 트리를 순회하며 구간 합에 b번째가 들어가면 diff만큼 더해주면 된다.</li>
      <li>update() 파라미터 now는 현재 노드 인덱스, left right는 현재 위치에서 구간 합 범위, idx는 인덱스 b(갱신 노드), diff는 수정 값이다.</li>
      <li>현재 위치에서 left right 구간 합 범위에 idx가 들어오지 않는다면 해당 노드는 수정할 필요가 없으므로 리턴한다.</li>
      <li>아닐 경우 현재 노드에 diff만큼 더해서 값을 갱신한다.</li>
      <li>left!=right라면 아직 자식노드가 존재한다는 뜻이므로(리프노드가 아니므로) 자식노드 2i, 2i+1로 재귀 호출한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">sum()</span></strong>
    <ul>
      <li>main에서 b~c의 구간 합을 출력한다.</li>
      <li>sum() 파라미터 now는 현재 노드 인덱스, left right는 현재 노드의 구간 합 범위, rangeA rangeB는 찾아야 할 구간 합 범위이다.</li>
      <li>따라서 처음으로 확인할 노드(루트 노드부터 시작) 1, 루트 노드의 구간 합 범위 1 N, 찾아야 할 구간 합 b c이므로 sum(1, 1, N, b, c)이다.</li>
      <li>총 범위 1~N에서 b~c로 좁혀 나가는 과정이다. 따라서 현재 구간 합 범위 left right가 찾아야 할 범위 rangeA rangeB를 벗어나면 0을 리턴한다.</li>
      <li>찾아야 할 범위에 들어오면 해당 노드의 구간합(tree[now])를 리턴한다.</li>
      <li>이때 tree[now]를 리턴하기 위해서는 now 구간 합 범위와 똑같지 않아도 되고, 부분 집합으로 속하기만 하면 된다. 예를 들어 1~5를 찾기 위해 현재 3~5라면 해당 누적 합을 쓸 수 있다.</li>
      <li>하지만 2~6과 같이 걸쳐있는 경우에는 누적 합을 쓸 수 없다. 따라서 세분화한 자식 노드로 이동한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>BOJ 2042 구간 합 구하기 JAVA <a href="https://blog.naver.com/PostView.nhn?blogId=phj8498&amp;logNo=221308136784">https://blog.naver.com/PostView.nhn?blogId=phj8498&amp;logNo=221308136784</a></li>
  <li>세그먼트 트리(Segment Tree) / 인덱스 트리(Index Tree) <a href="http://isukorea.com/blog/home/waylight3/216">http://isukorea.com/blog/home/waylight3/216</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 4195번: 친구 네트워크</title>
	  <link>/blog//algo-boj4195</link>
	  <author></author>
	  <pubDate>2020-10-19T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj4195</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/4195">https://www.acmicpc.net/problem/4195</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>해시맵을 이용하여 각 이름에 인덱스를 부여한다.</li>
  <li>Union-Find 알고리즘을 이용해 각 이름별 부모를 저장한다.</li>
  <li>부모간의 거리를 cnt[]에 저장한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">cnt</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		 <span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		 <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">t</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			 <span class="kt">int</span> <span class="n">f</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			 <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
			 <span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">f</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 부모 연결 배열</span>
			 <span class="n">cnt</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">f</span><span class="o">*</span><span class="mi">2</span><span class="o">];</span> <span class="c1">// 부모간의 거리 저장 배열</span>
			 <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">cnt</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> 
			 
			 <span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
			 <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">f</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				 <span class="n">String</span><span class="o">[]</span> <span class="n">str</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
				 <span class="c1">// 처음 들어온 이름이면 해시맵에 put</span>
				 <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">0</span><span class="o">]))</span> <span class="o">{</span>
					 <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]=</span><span class="n">idx</span><span class="o">;</span>
					 <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">idx</span><span class="o">++);</span>
				 <span class="o">}</span>
				 <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">1</span><span class="o">]))</span> <span class="o">{</span>
					 <span class="n">parent</span><span class="o">[</span><span class="n">idx</span><span class="o">]=</span><span class="n">idx</span><span class="o">;</span>
					 <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">idx</span><span class="o">++);</span>
				 <span class="o">}</span>
				 
				 <span class="c1">// union으로 연결</span>
				 <span class="n">union</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
				 <span class="c1">// find하며 저장된 cnt값을 출력</span>
				 <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cnt</span><span class="o">[</span><span class="n">find</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">[</span><span class="mi">1</span><span class="o">]))]);</span>
			 <span class="o">}</span>
		 <span class="o">}</span>
		 
	<span class="o">}</span>
	

	 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
		 <span class="c1">// 최상위 부모 찾기</span>
		 <span class="kt">int</span> <span class="n">parentA</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		 <span class="kt">int</span> <span class="n">parentB</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
		 <span class="c1">// 같다면 이미 연결되어 있는 노드</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">parentA</span><span class="o">==</span><span class="n">parentB</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> 
		 
		 <span class="n">parent</span><span class="o">[</span><span class="n">parentB</span><span class="o">]=</span><span class="n">parentA</span><span class="o">;</span> <span class="c1">// a밑에 b가 들어감</span>
		 <span class="n">cnt</span><span class="o">[</span><span class="n">parentA</span><span class="o">]+=</span><span class="n">cnt</span><span class="o">[</span><span class="n">parentB</span><span class="o">];</span> <span class="c1">// b가 추가됐으므로 cnt[a] 갱신</span>
	 <span class="o">}</span>
	 
	 <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
		 <span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]==</span><span class="n">a</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">;</span> <span class="c1">// 더 이상 부모가 없음</span>
		 <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]);</span> <span class="c1">// 부모로 이동</span>
	 <span class="o">}</span>
	 
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201019_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">해시맵을 이용하여 이름에 인덱스를 부여한다</span></strong>
    <ul>
      <li>parent[]에는 부모의 인덱스를 저장하는 것이 편하므로 이름별 인덱스를 부여해야 한다.</li>
      <li>해시맵을 이용하여 들어오는 순서에 따라 인덱스를 부여한다.</li>
      <li>key: 이름, value: 인덱스</li>
      <li>당연히 이전에 등록한 이름이 input으로 들어오면 패스한다.</li>
      <li>새 이름이 들어왔으므로 parent[idx]=idx로 초기화한다(내 부모는 나 자신).</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">Union-Find 알고리즘을 이용한다</span></strong>
    <ul>
      <li>union: 파라미터 a, b를 연결하는 작업이다.</li>
      <li>둘의 최상위 부모를 찾아 parentA, parentB에 저장한다.</li>
      <li>두 값이 같다면 a, b는 이미 연결되어 있으므로 종료한다.</li>
      <li>아니라면, a 밑에 b가 들어가도록 한다.</li>
      <li>두 파라미터가 연결되었으므로 cnt[parentA]에 parentB의 개수들을 저장한다.</li>
      <li>find: 파라미터 a의 최상위 부모를 찾는 메소드이다.</li>
      <li>parent[a]=a라면 더 이상 부모가 없으므로 종료한다.</li>
      <li>아닐 경우 parent[a]의 부모를 찾는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11659번: 구간 합 구하기 4</title>
	  <link>/blog//algo-boj11659</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11659</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11659">https://www.acmicpc.net/problem/11659</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>n개의 누적합은 변하지 않으므로 한 번만 계산해놓고 필요한 부분을 뽑아서 쓴다.</li>
  <li>입력과 동시에 i까지의 누적합을 구해서 저장한다.</li>
  <li>array[j]-array[i-1]을 리턴한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="n">array</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// i까지의 누적합 구하기</span>
			<span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="c1">// a, b사이의 구간합은 array[b]-array[a-1]과 같다</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">b</span><span class="o">]-</span><span class="n">array</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">누적합 계산은 한 번만 한다</span></strong>
    <ul>
      <li>n개의 숫자에 따른 합은 변하지 않는 값이므로 한 번만 계산한 후 필요한 부분을 뽑아서 쓴다.</li>
      <li>array[i]: 0부터 i번째까지의 누적합을 저장한다.</li>
      <li>구간 i, j 사이의 합은 array[j]-array[i-1]과 같다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11438번: LCA 2</title>
	  <link>/blog//algo-boj11438</link>
	  <author></author>
	  <pubDate>2020-10-13T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11438</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11438">https://www.acmicpc.net/problem/11438</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>최소 시간을 구해야 하므로 BFS를 이용한다.</li>
  <li>time[i]를 이용하여 위치 i까지 걸린 시간을 저장하고, 중복 방문을 피한다.</li>
  <li>이동 경로를 출력해야 하므로 prev[i]를 통해 i의 이전 위치를 저장한다. Stack을 이용하여 이동 경로를 출력한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">depth</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">maxDepth</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">check</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(</span><span class="n">check</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 트리의 깊이 계산</span>
			<span class="n">check</span><span class="o">&lt;&lt;=</span><span class="mi">1</span><span class="o">;</span>
			<span class="n">maxDepth</span><span class="o">++;</span>
		<span class="o">}</span>
		
		<span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;());</span>
		<span class="n">depth</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">maxDepth</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 트리 생성</span>
		<span class="n">setParent</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">);</span> <span class="c1">// 부모 계산</span>
		
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">));</span>
			
		<span class="o">}</span>
	<span class="o">}</span>
	
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">depth</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">cnt</span><span class="o">;</span> <span class="c1">// node의 깊이 저장</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// node와 연결된 곳 중</span>
			<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">n</span><span class="o">]!=</span><span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문한 곳은 패스</span>
			<span class="n">parent</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">node</span><span class="o">;</span> <span class="c1">// n의 첫 번째 부모는 node</span>
			<span class="n">dfs</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// n으로 이동</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">maxDepth</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 2^i번째 부모 저장</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">parent</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">parent</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&gt;</span><span class="n">depth</span><span class="o">[</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// a의 깊이가 b보다 더 작도록</span>
			<span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">a</span><span class="o">;</span>
			<span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="o">;</span>
			<span class="n">b</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">maxDepth</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// a, b가 같은 깊이가 되도록 설정</span>
			<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&lt;=</span><span class="n">depth</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">]])</span> <span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
		<span class="o">}</span>
		
		<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
		<span class="c1">// 다르다면</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">maxDepth</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// 같이 깊이를 올리며 </span>
			<span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">i</span><span class="o">]!=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">a</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
				<span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201013_1.PNG" alt="실행결과" />
🤟 성공 🤟<br />
처음에는 트리를 ArrayList가 아니라 HashMap으로 구현하여 시간을 단축하고자 했는데 실패했다. 그래서 다른 사람들의 코드를 참고하였다. for문에서 maxDepth만큼 돌릴 때, maxDepth는 말 그대로 트리의 마지막 깊이이기 때문에 이 곳에서는 a, b의 공통 부모가 있을 수 없다. 그래서 maxDepth는 체크하면 안되고, maxDepth-1부터 시작해야한다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">시간을 줄이기 위해 node의 parent를 이차원 배열로 만든다</span></strong>
    <ul>
      <li>LCA (<a href="https://www.acmicpc.net/problem/11438">https://www.acmicpc.net/problem/11438</a>)와 문제는 같으나, N의 개수가 2배이고, 시간 제한은 절반으로 줄었다.</li>
      <li>이전 문제에서는 parent[]를 일차원으로 만들어 i의 바로 위 부모만 저장해두고 역이동으로 최소 공통 부모를 찾았다.</li>
      <li>이번에는 이차원 배열 parent[i][j]를 두고, i의 2^j번째 부모들을 저장한다. i의 홀수 번째 부모는 배열에 저장되지 않아 모든 부모를 탐색하지 못한다고 생각할 수도 있다. 하지만 parent[i][1]를 k라고 할 때, i의 3번째 부모는 parent[k][0]으로 방문 가능하므로 결국 모든 부모들을 탐색할 수 있다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">트리의 최대 깊이를 계산한다</span></strong>
    <ul>
      <li>노드가 n개인 균형이진트리의 깊이는 logn을 내림한 값과 같다(근데 문제에서 트리가 균형이진트리라는 말이 없는데.. 이 부분은 잘 이해가 안간다).</li>
      <li>자바에는 밑이 2인 로그를 계산하는 함수가 따로 없기 때문에, 비트 연산을 통해 최대 깊이(maxDepth)를 구한다.</li>
      <li>왼쪽으로 쉬프트하는 것은 2를 곱하는 것과 같으므로 해당 방법으로 maxDepth를 구한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">dfs()로 트리를 만든다</span></strong>
    <ul>
      <li>이 코드는 이전 문제 같으므로 자세한 설명은 생략한다.</li>
      <li>for문에서 n의 바로 위 부모는 2^0번째이므로 parent[n][0]에 node를 저장한다. 나머지 부모들은 setParent()에서 구한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">setParent()로 부모들을 저장한다</span></strong>
    <ul>
      <li>i는 깊이, j는 노드이다. 이 순서를 바꿀 경우 노드 j에 따른 2^i번째 부모들을 한 번에 구하게 되는데, 이 경우 아직 값이 저장되지 않은 부모를 참조하여 0이 들어가게 되므로 안된다.</li>
      <li>parent[j][i]는 j의 2^i번째 부모와 같다. 이는 j의 바로 앞 부모 노드인 parent[j][i-1]의 2^(i-1) 번째 부모를 구하는 것과 같다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">solve()로 LCA를 구한다</span></strong>
    <ul>
      <li>트리에서 a가 b보다 위에 있도록 설정한다.</li>
      <li>b를 움직여 a와 같은 깊이가 되도록 한다.</li>
      <li>a==b라면 공통 부모를 가리키고 있는 것이므로 a(또는 b)를 리턴한다.</li>
      <li>아니라면, 같이 움직이며 공통 부모를 찾은 후 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<ul>
  <li>백준 11438 Java <a href="https://velog.io/@imfksh/%EB%B0%B1%EC%A4%80-11438-Java">https://velog.io/@imfksh/%EB%B0%B1%EC%A4%80-11438-Java</a></li>
  <li>LCA(Lowest Common Ancestor) 알고리즘<a href="https://www.crocus.co.kr/660">https://www.crocus.co.kr/660</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
