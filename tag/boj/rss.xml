<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/백준] 11659번: 구간 합 구하기 4</title>
	  <link>/blog//algo-boj11659</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11659</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11659">https://www.acmicpc.net/problem/11659</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>n개의 누적합은 변하지 않으므로 한 번만 계산해놓고 필요한 부분을 뽑아서 쓴다.</li>
  <li>입력과 동시에 i까지의 누적합을 구해서 저장한다.</li>
  <li>array[j]-array[i-1]을 리턴한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="n">array</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// i까지의 누적합 구하기</span>
			<span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="c1">// a, b사이의 구간합은 array[b]-array[a-1]과 같다</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">b</span><span class="o">]-</span><span class="n">array</span><span class="o">[</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">누적합 계산은 한 번만 한다</span></strong>
    <ul>
      <li>n개의 숫자에 따른 합은 변하지 않는 값이므로 한 번만 계산한 후 필요한 부분을 뽑아서 쓴다.</li>
      <li>array[i]: 0부터 i번째까지의 누적합을 저장한다.</li>
      <li>구간 i, j 사이의 합은 array[j]-array[i-1]과 같다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11438번: LCA 2</title>
	  <link>/blog//algo-boj11438</link>
	  <author></author>
	  <pubDate>2020-10-13T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11438</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11438">https://www.acmicpc.net/problem/11438</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>최소 시간을 구해야 하므로 BFS를 이용한다.</li>
  <li>time[i]를 이용하여 위치 i까지 걸린 시간을 저장하고, 중복 방문을 피한다.</li>
  <li>이동 경로를 출력해야 하므로 prev[i]를 통해 i의 이전 위치를 저장한다. Stack을 이용하여 이동 경로를 출력한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">depth</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">maxDepth</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">check</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(</span><span class="n">check</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 트리의 깊이 계산</span>
			<span class="n">check</span><span class="o">&lt;&lt;=</span><span class="mi">1</span><span class="o">;</span>
			<span class="n">maxDepth</span><span class="o">++;</span>
		<span class="o">}</span>
		
		<span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;());</span>
		<span class="n">depth</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">maxDepth</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 트리 생성</span>
		<span class="n">setParent</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">);</span> <span class="c1">// 부모 계산</span>
		
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">maxDepth</span><span class="o">));</span>
			
		<span class="o">}</span>
	<span class="o">}</span>
	
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">depth</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">cnt</span><span class="o">;</span> <span class="c1">// node의 깊이 저장</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">n:</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// node와 연결된 곳 중</span>
			<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">n</span><span class="o">]!=</span><span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문한 곳은 패스</span>
			<span class="n">parent</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">node</span><span class="o">;</span> <span class="c1">// n의 첫 번째 부모는 node</span>
			<span class="n">dfs</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// n으로 이동</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setParent</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">maxDepth</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 2^i번째 부모 저장</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">parent</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">parent</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">,</span> <span class="kt">int</span> <span class="n">maxDepth</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&gt;</span><span class="n">depth</span><span class="o">[</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// a의 깊이가 b보다 더 작도록</span>
			<span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">a</span><span class="o">;</span>
			<span class="n">a</span><span class="o">=</span><span class="n">b</span><span class="o">;</span>
			<span class="n">b</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">maxDepth</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// a, b가 같은 깊이가 되도록 설정</span>
			<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&lt;=</span><span class="n">depth</span><span class="o">[</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">]])</span> <span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
		<span class="o">}</span>
		
		<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="o">)</span> <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
		<span class="c1">// 다르다면</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">maxDepth</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// 같이 깊이를 올리며 </span>
			<span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">i</span><span class="o">]!=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
				<span class="n">a</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
				<span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
			<span class="o">}</span>
		<span class="o">}</span>
		<span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201013_1.PNG" alt="실행결과" />
🤟 성공 🤟<br />
처음에는 트리를 ArrayList가 아니라 HashMap으로 구현하여 시간을 단축하고자 했는데 실패했다. 그래서 다른 사람들의 코드를 참고하였다. for문에서 maxDepth만큼 돌릴 때, maxDepth는 말 그대로 트리의 마지막 깊이이기 때문에 이 곳에서는 a, b의 공통 부모가 있을 수 없다. 그래서 maxDepth는 체크하면 안되고, maxDepth-1부터 시작해야한다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">시간을 줄이기 위해 node의 parent를 이차원 배열로 만든다</span></strong>
    <ul>
      <li>LCA (<a href="https://www.acmicpc.net/problem/11438">https://www.acmicpc.net/problem/11438</a>)와 문제는 같으나, N의 개수가 2배이고, 시간 제한은 절반으로 줄었다.</li>
      <li>이전 문제에서는 parent[]를 일차원으로 만들어 i의 바로 위 부모만 저장해두고 역이동으로 최소 공통 부모를 찾았다.</li>
      <li>이번에는 이차원 배열 parent[i][j]를 두고, i의 2^j번째 부모들을 저장한다. i의 홀수 번째 부모는 배열에 저장되지 않아 모든 부모를 탐색하지 못한다고 생각할 수도 있다. 하지만 parent[i][1]를 k라고 할 때, i의 3번째 부모는 parent[k][0]으로 방문 가능하므로 결국 모든 부모들을 탐색할 수 있다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">트리의 최대 깊이를 계산한다</span></strong>
    <ul>
      <li>노드가 n개인 균형이진트리의 깊이는 logn을 내림한 값과 같다(근데 문제에서 트리가 균형이진트리라는 말이 없는데.. 이 부분은 잘 이해가 안간다).</li>
      <li>자바에는 밑이 2인 로그를 계산하는 함수가 따로 없기 때문에, 비트 연산을 통해 최대 깊이(maxDepth)를 구한다.</li>
      <li>왼쪽으로 쉬프트하는 것은 2를 곱하는 것과 같으므로 해당 방법으로 maxDepth를 구한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">dfs()로 트리를 만든다</span></strong>
    <ul>
      <li>이 코드는 이전 문제 같으므로 자세한 설명은 생략한다.</li>
      <li>for문에서 n의 바로 위 부모는 2^0번째이므로 parent[n][0]에 node를 저장한다. 나머지 부모들은 setParent()에서 구한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">setParent()로 부모들을 저장한다</span></strong>
    <ul>
      <li>i는 깊이, j는 노드이다. 이 순서를 바꿀 경우 노드 j에 따른 2^i번째 부모들을 한 번에 구하게 되는데, 이 경우 아직 값이 저장되지 않은 부모를 참조하여 0이 들어가게 되므로 안된다.</li>
      <li>parent[j][i]는 j의 2^i번째 부모와 같다. 이는 j의 바로 앞 부모 노드인 parent[j][i-1]의 2^(i-1) 번째 부모를 구하는 것과 같다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">solve()로 LCA를 구한다</span></strong>
    <ul>
      <li>트리에서 a가 b보다 위에 있도록 설정한다.</li>
      <li>b를 움직여 a와 같은 깊이가 되도록 한다.</li>
      <li>a==b라면 공통 부모를 가리키고 있는 것이므로 a(또는 b)를 리턴한다.</li>
      <li>아니라면, 같이 움직이며 공통 부모를 찾은 후 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<ul>
  <li>백준 11438 Java <a href="https://velog.io/@imfksh/%EB%B0%B1%EC%A4%80-11438-Java">https://velog.io/@imfksh/%EB%B0%B1%EC%A4%80-11438-Java</a></li>
  <li>LCA(Lowest Common Ancestor) 알고리즘<a href="https://www.crocus.co.kr/660">https://www.crocus.co.kr/660</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 13913번: 숨바꼭질 4</title>
	  <link>/blog//algo-boj13913</link>
	  <author></author>
	  <pubDate>2020-10-12T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj13913</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/13913">https://www.acmicpc.net/problem/13913</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>최소 시간을 구해야 하므로 BFS를 이용한다.</li>
  <li>time[i]를 이용하여 위치 i까지 걸린 시간을 저장하고, 중복 방문을 피한다.</li>
  <li>이동 경로를 출력해야 하므로 prev[i]를 통해 i의 이전 위치를 저장한다. Stack을 이용하여 이동 경로를 출력한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		
		<span class="kt">int</span><span class="o">[]</span> <span class="n">time</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100001</span><span class="o">];</span> <span class="c1">// i 위치일 때 시간</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">prev</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">100001</span><span class="o">];</span> <span class="c1">// i의 이전 위치</span>
		<span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">time</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 초기화</span>
		
		<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
		<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="c1">// 시작점</span>
		<span class="n">time</span><span class="o">[</span><span class="n">n</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 시작 위치에서는 0초</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="n">k</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 도착</span>
				<span class="k">while</span><span class="o">(</span><span class="n">x</span><span class="o">!=</span><span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// k에서 n으로 다시 역이동</span>
					<span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
					<span class="n">x</span><span class="o">=</span><span class="n">prev</span><span class="o">[</span><span class="n">x</span><span class="o">];</span>
				<span class="o">}</span>
				<span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">n</span><span class="o">);</span> <span class="c1">// 마지막 시작점도 추가</span>
				<span class="k">break</span><span class="o">;</span>
			<span class="o">}</span>
			
			<span class="kt">int</span><span class="o">[]</span> <span class="n">dotX</span><span class="o">=</span> <span class="o">{-</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="n">x</span><span class="o">};</span> <span class="c1">// 이동할 수 있는 경우의 수</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">next</span><span class="o">=</span><span class="n">dotX</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="n">x</span><span class="o">;</span>
				<span class="k">if</span><span class="o">(</span><span class="n">next</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">next</span><span class="o">&gt;</span><span class="mi">100000</span> <span class="o">||</span> <span class="n">time</span><span class="o">[</span><span class="n">next</span><span class="o">]!=-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
				<span class="n">time</span><span class="o">[</span><span class="n">next</span><span class="o">]=</span><span class="n">time</span><span class="o">[</span><span class="n">x</span><span class="o">]+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 시간 계산</span>
				<span class="n">prev</span><span class="o">[</span><span class="n">next</span><span class="o">]=</span><span class="n">x</span><span class="o">;</span> <span class="c1">// next의 이전 위치(x) 저장</span>
				<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
			<span class="o">}</span>
			
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">time</span><span class="o">[</span><span class="n">k</span><span class="o">]);</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">()+</span><span class="s">" "</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201012_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">BFS를 이용한다</span></strong>
    <ul>
      <li>최소 시간을 구해야 하므로 BFS이다.</li>
      <li>time[]를 이용해 시간을 계산한다. -1로 초기화 한다. 이후 time[i]==-1이라면 아직 방문하지 않은 위치로 인식한다.</li>
      <li>prev[i]는 i의 이전 경로를 저장한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">큐를 이용하여 k까지 이동한다</span></strong>
    <ul>
      <li>배열 dotX를 이용해 다음 노드로 갈 수 있는 경우를 만들고, for문을 통해 다음 위치를 계산한다(xx).</li>
      <li>xx의 범위가 0~100,000안에 들어오는지 확인한다. 이 범위를 초과하면 최소 시간이 될 확률이 낮다.</li>
      <li>xx가 방문하지 않은 노드인지 확인한다. 방문한 노드를 생각하지 않는다면, 같은 연산을 여러 번 수행하게 되므로 효율성이 떨어진다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">스택을 통해 경로를 출력한다</span></strong>
    <ul>
      <li>k(==x)에서 부터 n까지 prev[]를 통해 역이동한다. 이때 이동 위치를 스택에 저장한 후, 마지막에 출력한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<ul>
  <li>[백준 13913: JAVA] 숨바꼭질 4 / DP, BFS, 역추적 <a href="https://dragon-h.tistory.com/37">https://dragon-h.tistory.com/37</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1717번: 집합의 표현</title>
	  <link>/blog//algo-boj1717</link>
	  <author></author>
	  <pubDate>2020-10-11T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1717</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1717">https://www.acmicpc.net/problem/1717</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>Union-Find 문제이다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		
		<span class="n">String</span><span class="o">[]</span> <span class="n">input</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>		

		<span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// i의 최상 부모 저장</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 배열 초기화</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
			
			<span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"0"</span><span class="o">))</span> <span class="n">union</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
			<span class="k">else</span> <span class="nf">check</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">//		if(a&gt;b) { // a&lt;b이도록 설정</span>
<span class="c1">//			int temp=a;</span>
<span class="c1">//			a=b;</span>
<span class="c1">//			b=temp;</span>
<span class="c1">//		}		</span>
		<span class="c1">// 최상 부모 찾기</span>
		<span class="n">a</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="n">b</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
		<span class="c1">// 부모가 다르다면 b의 부모로 a설정하여 둘이 합집합 만들기</span>
		<span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">!=</span><span class="n">b</span><span class="o">)</span> <span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">]=</span><span class="n">a</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]==</span><span class="n">x</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> <span class="c1">// 부모가 없을 때</span>
		<span class="c1">// x의 최상위 부모 저장 및 리턴</span>
		<span class="k">else</span> <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">a</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="n">b</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
		<span class="c1">// 최상위 부모가 같아야 둘은 합집합임</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="o">?</span> <span class="s">"YES\n"</span><span class="o">:</span><span class="s">"NO\n"</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201011_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">Union-Find으로 문제를 해결한다</span></strong>
    <ul>
      <li>parent[]는 i의 부모를 저장한다.</li>
      <li>처음에는 부모가 없으므로 자기자신으로 배열을 초기화한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">Union</span></strong>
    <ul>
      <li>a와 b를 합집합으로 만든다.</li>
      <li>부모가 자식보다 작아야 한다던가의 크기 조건이 없기 때문에 a와 b의 대소 비교는 필요없다(있어도 문제 푸는데 지장은 없다).</li>
      <li>find()로 a, b의 부모를 찾는다. 둘의 부모가 같다면 이미 합집합이므로 따로 코드를 수행하지 않아도 된다.</li>
      <li>부모가 다르다면, b의 부모로 a를 설정한다(a의 부모로 b를 설정해도 상관없다).</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">Find</span></strong>
    <ul>
      <li>x의 부모를 찾는다.</li>
      <li>parent[x]==x라면 더이상 x의 부모가 없는 것이므로 x를 리턴한다.</li>
      <li>부모가 더 있다면 재귀 호출을 통해 그곳으로 이동한다.</li>
      <li>재귀를 통해 타고타고 최상위 부모까지 갔다가 최상위 부모 값을 가지고 다시 복귀하면, parent[x]에 최상위 부모를 저장한다. 이를 통해 이후 다시 x의 부모를 찾을 때, 똑같이 부모를 타고 올라가는 중복을 방지한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[알고리즘] 유니온 파인드 (Union-Find) <a href="https://brenden.tistory.com/33">https://brenden.tistory.com/33</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1780번: 종이의 개수</title>
	  <link>/blog//algo-boj1780</link>
	  <author></author>
	  <pubDate>2020-10-08T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1780</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1780">https://www.acmicpc.net/problem/1780</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>분할정복 문제이다.</li>
  <li>범위를 줄여나가며 범위안에 같은 숫자들로 구성되어 있는지 확인한다.</li>
  <li><a href="https://iamheesoo.github.io/blog/algo-boj1992">https://iamheesoo.github.io/blog/algo-boj1992</a>랑 똑같은 문제</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">zero</span><span class="o">,</span> <span class="n">posOne</span><span class="o">,</span> <span class="n">negOne</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
		<span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span> <span class="c1">// 초기화</span>
		<span class="n">zero</span><span class="o">=</span><span class="n">posOne</span><span class="o">=</span><span class="n">negOne</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 맵 생성</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">input</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="n">divide</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">);</span> <span class="c1">// 분할</span>
		<span class="n">String</span> <span class="n">answer</span><span class="o">=</span><span class="n">negOne</span><span class="o">+</span><span class="s">"\n"</span><span class="o">+</span><span class="n">zero</span><span class="o">+</span><span class="s">"\n"</span><span class="o">+</span><span class="n">posOne</span><span class="o">;</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
		
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isAble</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// map[row][col]을 시작으로 n 사이즈 범위 내에 같은 숫자들로만 구성되어 있는지 체크</span>
		<span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">row</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">row</span><span class="o">+</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">col</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">col</span><span class="o">+</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=</span><span class="n">value</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">isAble</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 같은 수로만 구성되어 있다면</span>
			<span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]==</span><span class="mi">0</span><span class="o">)</span> <span class="n">zero</span><span class="o">++;</span>
            <span class="c1">// 그 숫자에 따라 개수 카운드</span>
			<span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]==</span><span class="mi">1</span><span class="o">)</span> <span class="n">posOne</span><span class="o">++;</span>
			<span class="k">else</span> <span class="n">negOne</span><span class="o">++;</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">newSize</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// 사이즈는 3의 배수이므로</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 시작점을 다르게 하여 newSize 범위 내에서 다시 체크</span>
				<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
					<span class="n">divide</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="n">newSize</span><span class="o">*</span><span class="n">i</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="n">newSize</span><span class="o">*</span><span class="n">j</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201008_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li>
    <p><strong><span style="color:navy">맵을 생성한다</span></strong></p>
  </li>
  <li>
    <p><strong><span style="color:navy">divide()로 정사각형 범위를 만들고, isAble()로 압축 가능한지 체크한다</span></strong></p>
    <ul>
      <li>1992 문제와 코드가 거의 같다.</li>
      <li>다른 점은 divide() else문에서 재귀 호출을 for문으로 했다는 것이다. 1992번 문제에서는 탐색 순서가 정해져 있고, 재귀를 4번만 호출하면 되기 때문에 for문을 사용하지 않고 일일이 코드를 썼는데, 이번 문제는 사이즈가 3의 약수로 줄어들어야 하므로 재귀도 총 9번 호출해야한다. 9개를 다 쓸 수는 없으므로 for문으로 작성하였다.</li>
      <li>이 문제는 탐색 순서가 중요하지 않고 숫자별 개수만 세면 되므로 i, j를 적절히 써서 각기 다른 시작점을 만들고 9번을 호출하기만 하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[JAVA/백준] 1992번: 쿼드트리 <a href="https://iamheesoo.github.io/blog/algo-boj1992">https://iamheesoo.github.io/blog/algo-boj1992</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1992번: 쿼드트리</title>
	  <link>/blog//algo-boj1992</link>
	  <author></author>
	  <pubDate>2020-10-08T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1992</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1992">https://www.acmicpc.net/problem/1992</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>분할정복 문제이다.</li>
  <li>정사각형 범위를 줄여나가며 범위안에 같은 숫자들로 구성되어 있는지 확인한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
	<span class="kd">static</span> <span class="n">String</span> <span class="n">answer</span><span class="o">;</span> <span class="c1">// 출력할 문자열 저장하는 변수</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">NumberFormatException</span><span class="o">,</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
		<span class="n">answer</span><span class="o">=</span><span class="s">""</span><span class="o">;</span>
		
		<span class="c1">// 맵 생성</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">String</span><span class="o">[]</span> <span class="n">input</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"1"</span><span class="o">))</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span> 
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="c1">// 큰 정사각형부터 점점 범위를 좁혀나가며 체크</span>
		<span class="n">divide</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">n</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="c1">// map[row][col]을 시작으로 사이즈 n 정사각형 범위안에 같은 수로만 구성되어 있는지 체크</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isAble</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">row</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">row</span><span class="o">+</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">col</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">col</span><span class="o">+</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=</span><span class="n">value</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
	<span class="o">}</span>
    
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">divide</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">isAble</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 같은 수로만 구성되어 있으므로</span>
			<span class="n">answer</span><span class="o">+=</span><span class="n">map</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">];</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span> <span class="c1">// 아닐 경우 범위를 좁힘</span>
			<span class="n">answer</span><span class="o">+=</span><span class="s">"("</span><span class="o">;</span>
			<span class="kt">int</span> <span class="n">newSize</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
			<span class="c1">// 범위를 좁히고, 시작점을 지정하여 재귀호출</span>
			<span class="n">divide</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
			<span class="n">divide</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
			<span class="n">divide</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
			<span class="n">divide</span><span class="o">(</span><span class="n">row</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">col</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
			<span class="n">answer</span><span class="o">+=</span><span class="s">")"</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201008_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">맵을 생성한다</span></strong>
    <ul>
      <li>input이 한 줄 단위로 들어오기 때문에 split(““)으로 쪼갠 후, 1인 곳에 값을 넣는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">divide()로 정사각형 범위를 만들고, isAble()로 압축 가능한지 체크한다</span></strong>
    <ul>
      <li>파라미터 row, col은 map에서 시작점이고, n은 확인하고자 하는 정사각형 사이즈이다.</li>
      <li>isAble(row, col, n)을 통해 map[row][col]에서 오른쪽으로 n개, 아래로 n개만큼의 정사각형을 체크한다.</li>
      <li>value에 시작점 값을 넣는다. 압축이 가능하다면 해당 범위는 value로만 이루어져 있어야 한다. value와 다른 값이 나오면 false를 리턴한다.</li>
      <li>true를 리턴받았다면 압축 가능하므로 answer에 해당 값(map[row][col])을 저장한다.</li>
      <li>아닐 경우, 정사각형 범위를 줄인다. 범위는 정사각형이므로 반으로 나눠야한다.</li>
      <li>현재 위치(map[row][col])에서 newSize만큼 범위를 체크(1), 그 오른쪽 범위를 체크(2), 현재 위치 아래를 체크(3), 그 오른쪽을 체크(4)한다. 재귀를 이용한다. 순서가 바뀌면 안된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[백준] 1992번 자바 쿼드트리 <a href="https://log-laboratory.tistory.com/74">https://log-laboratory.tistory.com/74</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 2011번: 암호코드</title>
	  <link>/blog//algo-boj2011</link>
	  <author></author>
	  <pubDate>2020-10-07T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj2011</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/2011">https://www.acmicpc.net/problem/2011</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>dp[i]: i번째 문자까지 만들 수 있는 암호의 경우의 수(인덱스는 1부터 시작)</li>
  <li>i번째가 0인 경우 앞 문자가 1 또는 2라면 가능하고, 아니라면 잘못된 암호이므로 0을 리턴한다.</li>
  <li>앞 문자를 체크하여 경우의 수를 센다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="n">String</span> <span class="n">s</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
		<span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)==</span><span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 시작이 0이면 잘못된 암호</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 현재 체크하는 문자</span>
			<span class="kt">char</span> <span class="n">prev</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 앞 문자</span>
			<span class="k">if</span><span class="o">(</span><span class="n">ch</span><span class="o">==</span><span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">prev</span><span class="o">==</span><span class="sc">'1'</span> <span class="o">||</span> <span class="n">prev</span><span class="o">==</span><span class="sc">'2'</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span> 
				 <span class="c1">// 현재 문자 0을 앞과 연결할 수 없다면 잘못된 문자열이므로 종료</span>
				<span class="k">else</span> <span class="k">break</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="c1">// 앞 문자가 0이면 경우의 수 변화 없음</span>
				<span class="k">if</span><span class="o">(</span><span class="n">prev</span><span class="o">==</span><span class="sc">'0'</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span>
				<span class="k">else</span> <span class="o">{</span> <span class="c1">// 앞 문자와 연결할 수 있는지 체크</span>
				 	<span class="c1">// 앞 문자와 연결했을 때 숫자를 int형으로 출력</span>
					<span class="kt">int</span> <span class="n">temp</span><span class="o">=(</span><span class="n">prev</span><span class="o">-</span><span class="sc">'0'</span><span class="o">)*</span><span class="mi">10</span><span class="o">+(</span><span class="n">ch</span><span class="o">-</span><span class="sc">'0'</span><span class="o">);</span>
					<span class="c1">// 암호 코드안에 들어오면 경우의 수 갱신</span>
					<span class="k">if</span><span class="o">(</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">&lt;=</span><span class="mi">26</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])%</span><span class="mi">1000000</span><span class="o">;</span>
					<span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()]%</span><span class="mi">1000000</span><span class="o">);</span>
		
	<span class="o">}</span>
	
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201007_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp에는 인덱스 1부터 사용한다.</li>
      <li>dp[i]: input의 i-1번째 문자까지의 암호 해석 경우의 수.</li>
      <li>암호 길이가 5000 이하이므로 DFS로는 풀 수 없다. 처음부터 하나씩 문자를 체크하며 경우의 수를 따지는 방법으로 문제를 해결할 수 있다. 따라서 DP를 이용한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">예시: 25114</span></strong>
    <ul>
      <li>dp[1]=1 (2)</li>
      <li>dp[2]=2 (2 5, 25)</li>
      <li>dp[3]=2 (2 5 1, 25 1)</li>
      <li>dp[4]=4 (2 5 1 1, 25 1 1, 25 11, 2 5 11)</li>
      <li>dp[5]=6 (2 5 1 1 4, 25 1 1 4, 25 1 14, 25 11 4, 2 5 11 4, 2 5 1 14)</li>
      <li>여기서 dp[i]=dp[i-2]+dp[i-1]을 알 수 있다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">0인 경우를 생각한다</span></strong>
    <ul>
      <li>시작이 0이면 잘못된 경우이므로 0을 출력한다.</li>
      <li>중간에 0이 나오면 prev(i-1, 앞 문자)를 체크한다. prev가 1 또는 2라면 prev에 0을 붙이면 된다.</li>
      <li></li>
      <li>예시: 1203</li>
      <li>dp[1]=1</li>
      <li>dp[2]=2</li>
      <li>dp[3]=1</li>
      <li>dp[4]=1</li>
      <li>여기서 dp[3]은 1이 되어야 한다. dp[2]까지는 (1 2, 12)였지만 3번째가 0으로 (1 20)만 가능하다. 따라서 dp[i]는 dp[i-1]이 아닌 dp[i-2]를 가져온다.</li>
      <li></li>
      <li>prev가 1, 2가 아니라면 잘못된 문자이므로 break.</li>
      <li>prev가 0이면 새로운 경우의 수를 만들 수 없으므로 dp[i]=dp[i-1] (ex. 1230, 1091)</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">1000000으로 나눈다</span></strong>
    <ul>
      <li>문제 조건에서 1000000으로 나눈 나머지를 출력하라고 했으므로 dp[i]를 받을 때 마다 해당 값으로 나눈다.</li>
      <li>사실 dp[i]가 갱신되는 (dp[i]=dp[i-2]+dp[i-1])에서만 해줘도 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11728번: 배열 합치기</title>
	  <link>/blog//algo-boj11728</link>
	  <author></author>
	  <pubDate>2020-10-07T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11728</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11728">https://www.acmicpc.net/problem/11728</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>시간 제한이 있으므로, BufferedReader와 BufferedWriter를 이용한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">BufferedWriter</span> <span class="n">bw</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="n">OutputStreamWriter</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

		<span class="n">String</span><span class="o">[]</span> <span class="n">input</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span> <span class="c1">// 첫 번째 개행 읽기</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="mi">0</span><span class="o">]),</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
		<span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="o">;</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
		
		<span class="n">String</span><span class="o">[]</span> <span class="n">arrayA</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span> <span class="c1">// 두 번째 줄 읽기</span>
		<span class="n">String</span><span class="o">[]</span> <span class="n">arrayB</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span> <span class="c1">// 세 번째 줄 읽기</span>
		
		<span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 배열 A 넣기</span>
			<span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">++]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arrayA</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 배열 B 넣기</span>
			<span class="n">result</span><span class="o">[</span><span class="n">idx</span><span class="o">++]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">arrayB</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
		<span class="o">}</span>
		<span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">);</span> <span class="c1">// 오름차순 정렬</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">r:</span><span class="n">result</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">r</span><span class="o">)+</span><span class="s">" "</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
		<span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
	<span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201007_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">BufferedReader를 이용하여 input을 읽은 후 오름차순 정렬한다</span></strong>
    <ul>
      <li>BufferedReader는 버퍼에 input값을 저장해두었다가, 버퍼가 가득차거나 개행 문자가 나타나면 버퍼의 내용을 한 번에 전달하므로 실행 속도가 빠르다.</li>
      <li>br.readLine()을 통해 input을 한 줄 읽는다.</li>
      <li>첫 번째 줄은 n과 m이므로, 읽은 값을 스페이스 기준으로 나눈다. 0번째 인덱스에는 n, 1번째에는 m이다.</li>
      <li>두 배열을 합쳐야 하므로 길이가 n+m인 배열을 선언한다.</li>
      <li>두 번째 줄 input은 배열 A의 원소들이다. for문에서 변수 iㄹ르 통해 배열 A를 순회하고, idx변수를 밖에서 선언하여 resul 배열을 움직이며 A 값을 저장한다. B도 마찬가지이다.</li>
      <li>result에 A, B를 넣은 후 Arrays.sort()로 오름차순 정렬한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">BufferedWriter를 이용하여 출력한다</span></strong>
    <ul>
      <li>BufferedWriter 역시 버퍼를 이용하기 때문에 성능이 좋다.</li>
      <li>정렬된 result 배열의 원소를 하나씩 뽑아 bw에 적는다.</li>
      <li>write()는 말그대로 버퍼에 적는 것이기 때문에, flush(), close()를 통해 버퍼를 출력한 후 스트림을 닫아야 한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[Java 자바 입출력] BufferedReader/BufferedWriter <a href="https://jhnyang.tistory.com/92">https://jhnyang.tistory.com/92</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 11437번: LCA</title>
	  <link>/blog//algo-boj11437</link>
	  <author></author>
	  <pubDate>2020-10-07T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj11437</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/11437">https://www.acmicpc.net/problem/11437</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>ArrayList&lt;&gt;를 이용하여 트리를 만든다.</li>
  <li>각 노드 별 depth, parent를 구한다.</li>
  <li>가장 가까운 공통 조상을 찾는다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
	<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">depth</span><span class="o">,</span> <span class="n">parent</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="n">n</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="c1">// 트리 생성</span>
		<span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;());</span>
		<span class="o">}</span>		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 나와 연결된 노드를 저장</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="o">}</span>
		
		<span class="c1">// 깊이, 부모 찾기</span>
		<span class="n">depth</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">);</span>
		
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">));</span> <span class="c1">// 공통 부모 찾기</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span><span class="c1">// node: 방문 노드, cnt: 현재 깊이</span>
    	<span class="n">depth</span><span class="o">[</span><span class="n">node</span><span class="o">]=</span><span class="n">cnt</span><span class="o">;</span>
    	
    	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">child:</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// node와 연결된 것들 중에</span>
    		<span class="k">if</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">child</span><span class="o">]==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 깊이 계산이 안 된 곳은 자식 노드이므로</span>
    			<span class="n">dfs</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    			<span class="n">parent</span><span class="o">[</span><span class="n">child</span><span class="o">]=</span><span class="n">node</span><span class="o">;</span>
    		<span class="o">}</span>
    	<span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 같은 층으로 만들기</span>
    	<span class="k">while</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&gt;</span><span class="n">depth</span><span class="o">[</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// a가 더 밑에 있다면</span>
    		<span class="n">a</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
    	<span class="o">}</span>
    	<span class="k">while</span><span class="o">(</span><span class="n">depth</span><span class="o">[</span><span class="n">a</span><span class="o">]&lt;</span><span class="n">depth</span><span class="o">[</span><span class="n">b</span><span class="o">])</span> <span class="o">{</span> <span class="c1">//b가 더 밑에 있다면</span>
    		<span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
    	<span class="o">}</span>
    	
        <span class="c1">// 같은 층인데 같지 않다면(부모가 다르다면)</span>
    	<span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">!=</span><span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 같은 부모를 찾을 때 까지 반복</span>
    		<span class="n">a</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">];</span>
    		<span class="n">b</span><span class="o">=</span><span class="n">parent</span><span class="o">[</span><span class="n">b</span><span class="o">];</span>
    	<span class="o">}</span>
    	
    	<span class="k">return</span> <span class="n">a</span><span class="o">;</span>
    <span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201007_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">LCA</span></strong>
    <ul>
      <li>LCA(Lowest Common Ancestor): 가장 가까운 공통 조상을 찾는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">ArrayList를 이용하여 트리를 만든다</span></strong>
    <ul>
      <li>BST가 아니므로 자식 노드가 몇 개가 될 지 모른다. 따라서 ArrayList를 이용해야 한다.</li>
      <li>서로 연결된 노드들을 ArrayList에 저장한다. list.get(1)은 노드 1와 연결되어 있는 노드들이 저장된다.</li>
      <li>자식 노드들만 저장하는 것이 아니라, 나와 연결된 노드를 저장한다.</li>
      <li>노드는 1부터 시작하므로 ArrayList&lt;&gt;는 총 n+1개를 만들고, list.get(0)은 사용하지 않는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">깊이, 부모를 계산한다</span></strong>
    <ul>
      <li>depth[i]는 i 노드의 깊이가, parent[i]는 i의 부모 값이 저장된다.</li>
      <li>DFS를 이용하여 깊이를 계산한다. depth, parent[] 배열을 이용하여 값을 저장한다.</li>
      <li>dfs()는 깊이 계산이 되지 않은 곳만 넣는다. depth[i]==0인 곳이 계산 안 된 곳이며, i의 자식노드이다. 따라서 재귀 호출을 통해 자식 노드로 이동하며, cnt+1을 통해 깊이를 계산한다.</li>
      <li>자식 노드의 경우 parent는 node가 되므로 이를 저장한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">깊이를 같게 만든 후, 가장 가까운 공통 조상을 찾는다</span></strong>
    <ul>
      <li>solve()를 통해 깊이를 같게 만든 후 가장 가까운 공통 조상을 찾는다.</li>
      <li>a와 b의 depth를 확인한다. 다를 수가 있으므로 더 깊은 곳을 한 칸씩 위로 올라가며 기준으로 같게 만든다.</li>
      <li>첫 번째 while문은 a가 더 깊은 경우로, a=parent[a]하며 올라간다.</li>
      <li>두 번째 while문은 b가 더 깊은 경우다.</li>
      <li>a와 b의 깊이 같아지면 세 번째 while문의 조건을 확인한다. 깊이가 같고 a==b이면 공통 조상을 가리키고 있는 것이다. a!=b라면 깊이는 같지만 공통 조상이 아니므로 같이 한 칸씩 위로 올라가며 공통 조상을 찾을 때 까지 반복한다.</li>
      <li>공통 조상 a를 리턴한다(b도 가능).</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[BOJ] 백준 11437번 LCA 자바 풀이 <a href="https://hoho325.tistory.com/103">https://hoho325.tistory.com/103</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 다리 놓기</title>
	  <link>/blog//algo-boj1010</link>
	  <author></author>
	  <pubDate>2020-09-22T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1010</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1010">https://www.acmicpc.net/problem/1010</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용해 mCn을 계산한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">T</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">;</span><span class="n">t</span><span class="o">++)</span> <span class="o">{</span>
        	<span class="kt">int</span> <span class="n">N</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        	<span class="kt">int</span> <span class="n">M</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
        	
        	<span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">30</span><span class="o">][</span><span class="mi">30</span><span class="o">];</span>
        	<span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        	<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">M</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        			<span class="k">if</span><span class="o">(</span><span class="n">j</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        			<span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        		<span class="o">}</span>
        	<span class="o">}</span>
        	
        	<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">M</span><span class="o">][</span><span class="n">N</span><span class="o">]);</span>
        <span class="o">}</span>
	<span class="o">}</span>
	

<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200922_6.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">mCn을 DP를 이용해 계산한다</span></strong>
    <ul>
      <li>서쪽이 N, 동쪽이 M으로 N에서 M으로 가는 경우의 수는 mCn과 같다.</li>
      <li>따라서 DP를 이용해 mCn을 계산한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
