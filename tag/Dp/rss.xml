<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/백준] 2011번: 암호코드</title>
	  <link>/blog//algo-boj2011</link>
	  <author></author>
	  <pubDate>2020-10-07T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj2011</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/2011">https://www.acmicpc.net/problem/2011</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>dp[i]: i번째 문자까지 만들 수 있는 암호의 경우의 수(인덱스는 1부터 시작)</li>
  <li>i번째가 0인 경우 앞 문자가 1 또는 2라면 가능하고, 아니라면 잘못된 암호이므로 0을 리턴한다.</li>
  <li>앞 문자를 체크하여 경우의 수를 센다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="n">String</span> <span class="n">s</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
		<span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)==</span><span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 시작이 0이면 잘못된 암호</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()+</span><span class="mi">1</span><span class="o">];</span>
		<span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 현재 체크하는 문자</span>
			<span class="kt">char</span> <span class="n">prev</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">);</span> <span class="c1">// 앞 문자</span>
			<span class="k">if</span><span class="o">(</span><span class="n">ch</span><span class="o">==</span><span class="sc">'0'</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">prev</span><span class="o">==</span><span class="sc">'1'</span> <span class="o">||</span> <span class="n">prev</span><span class="o">==</span><span class="sc">'2'</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span> 
				 <span class="c1">// 현재 문자 0을 앞과 연결할 수 없다면 잘못된 문자열이므로 종료</span>
				<span class="k">else</span> <span class="k">break</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="c1">// 앞 문자가 0이면 경우의 수 변화 없음</span>
				<span class="k">if</span><span class="o">(</span><span class="n">prev</span><span class="o">==</span><span class="sc">'0'</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span>
				<span class="k">else</span> <span class="o">{</span> <span class="c1">// 앞 문자와 연결할 수 있는지 체크</span>
				 	<span class="c1">// 앞 문자와 연결했을 때 숫자를 int형으로 출력</span>
					<span class="kt">int</span> <span class="n">temp</span><span class="o">=(</span><span class="n">prev</span><span class="o">-</span><span class="sc">'0'</span><span class="o">)*</span><span class="mi">10</span><span class="o">+(</span><span class="n">ch</span><span class="o">-</span><span class="sc">'0'</span><span class="o">);</span>
					<span class="c1">// 암호 코드안에 들어오면 경우의 수 갱신</span>
					<span class="k">if</span><span class="o">(</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">temp</span><span class="o">&lt;=</span><span class="mi">26</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">])%</span><span class="mi">1000000</span><span class="o">;</span>
					<span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]%</span><span class="mi">1000000</span><span class="o">;</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()]%</span><span class="mi">1000000</span><span class="o">);</span>
		
	<span class="o">}</span>
	
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201007_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp에는 인덱스 1부터 사용한다.</li>
      <li>dp[i]: input의 i-1번째 문자까지의 암호 해석 경우의 수.</li>
      <li>암호 길이가 5000 이하이므로 DFS로는 풀 수 없다. 처음부터 하나씩 문자를 체크하며 경우의 수를 따지는 방법으로 문제를 해결할 수 있다. 따라서 DP를 이용한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">예시: 25114</span></strong>
    <ul>
      <li>dp[1]=1 (2)</li>
      <li>dp[2]=2 (2 5, 25)</li>
      <li>dp[3]=2 (2 5 1, 25 1)</li>
      <li>dp[4]=4 (2 5 1 1, 25 1 1, 25 11, 2 5 11)</li>
      <li>dp[5]=6 (2 5 1 1 4, 25 1 1 4, 25 1 14, 25 11 4, 2 5 11 4, 2 5 1 14)</li>
      <li>여기서 dp[i]=dp[i-2]+dp[i-1]을 알 수 있다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">0인 경우를 생각한다</span></strong>
    <ul>
      <li>시작이 0이면 잘못된 경우이므로 0을 출력한다.</li>
      <li>중간에 0이 나오면 prev(i-1, 앞 문자)를 체크한다. prev가 1 또는 2라면 prev에 0을 붙이면 된다.</li>
      <li></li>
      <li>예시: 1203</li>
      <li>dp[1]=1</li>
      <li>dp[2]=2</li>
      <li>dp[3]=1</li>
      <li>dp[4]=1</li>
      <li>여기서 dp[3]은 1이 되어야 한다. dp[2]까지는 (1 2, 12)였지만 3번째가 0으로 (1 20)만 가능하다. 따라서 dp[i]는 dp[i-1]이 아닌 dp[i-2]를 가져온다.</li>
      <li></li>
      <li>prev가 1, 2가 아니라면 잘못된 문자이므로 break.</li>
      <li>prev가 0이면 새로운 경우의 수를 만들 수 없으므로 dp[i]=dp[i-1] (ex. 1230, 1091)</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">1000000으로 나눈다</span></strong>
    <ul>
      <li>문제 조건에서 1000000으로 나눈 나머지를 출력하라고 했으므로 dp[i]를 받을 때 마다 해당 값으로 나눈다.</li>
      <li>사실 dp[i]가 갱신되는 (dp[i]=dp[i-2]+dp[i-1])에서만 해줘도 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 96. Unique Binary Search Trees</title>
	  <link>/blog//algo-leet96</link>
	  <author></author>
	  <pubDate>2020-09-27T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet96</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees/submissions/">https://leetcode.com/problems/unique-binary-search-trees/submissions/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]+=</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]*</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200927_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>n=1이면 1 (dp[1]=1)</li>
      <li>n=2이면 1(root)- 2(right) 또는 1(left)-2(root) 이므로 dp[2]=2</li>
      <li>n=3인 경우, root가 1이면 left에는 아무것도 오지 않고, right는 {2,3}이 온다. {2,3}이나 {1,2}나 BST를 만드는 경우의 수는 같으므로 경우의 수는 1(left 경우의 수, dp[0])*dp<a href="right 경우의 수">2</a>=2</li>
      <li>root=2이면, left에는 {1}, right는 {3}이 온다. 따라서 경우의 수는 dp[1]*dp[1]=1</li>
      <li>root=3이면 left에 {1,2}, right={null}이므로 dp[2]*dp[0]=2</li>
      <li>이를 모두 더하면 <code class="highlighter-rouge">dp[3]=(dp[0]*dp[2])+(dp[1]*dp[1])+(dp[2]*dp[0])</code></li>
      <li>따라서 이를 점화식으로 나타내면 dp[x]=dp[0]*dp[x-1]+…+dp[x-1][0]이다.</li>
      <li>이를 for문을 통해 나타냈다. i가 x, j는 0부터 x-1까지 경우의 수를 모두 더하는데 사용한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>
<p>멀고도 험난한 DP의 세계🤯</p>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 70. Climbing Stairs</title>
	  <link>/blog//algo-leet70</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet70</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/climbing-stairs/">https://leetcode.com/problems/climbing-stairs/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_3.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>이렇게 노가다를 해야할 것 같은 문제는 일단 1부터 개수를 세면서 규칙을 찾아본다.</li>
      <li>규칙이 있다면 DP를 쓰면 된다.</li>
      <li>(input, answer)이라 할 때, (1,1), (2,2), (3,3), (4,5), (5,8), (6,13), (7,21) …</li>
      <li>3번째 부터는 이전 두 값의 합이 answer이라는 것을 알 수 있다.</li>
      <li>따라서, dp[i]=dp[i-1]+dp[i-2]</li>
      <li>input이 1,2,3이면 answer==input이므로 dp를 따로 생성하지 않고 처음 if문을 통해 값을 리턴하게 했다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 64. Minimum Path Sum</title>
	  <link>/blog//algo-leet64</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet64</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/minimum-path-sum/">https://leetcode.com/problems/minimum-path-sum/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>dp[i][j]는 (i,j)에서 최솟값으로, 왼쪽이나 위에서 작은 값을 선택하고, 내 값을 더한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 시작점 초기화</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 시작점은 패스</span>
                <span class="c1">// 왼쪽, 위쪽이 둘 다 존재한다면 둘 중 작은 값 선택</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// 위쪽만 있다면(i==0)</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// 왼쪽만 있다면(j==0)</span>
                <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
DFS로 하고 싶었지만 참았다</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>m, n의 범위를 알려주지 않아서 왠만큼 큰 숫자여도 풀 수 있어야 할 것 같았다. 그래서 DFS는 아니라고 생각했다.</li>
      <li>모든 경우를 다 따지는 것이 아니라면, 이런 문제는 보통 DP로 풀 수 있다. 따라서 점화식을 어떻게 짤지 생각했다.</li>
      <li>오른쪽, 아래쪽으로만 이동할 수 있기 때문에 (i,j)에 가기 위해서는 전의 위치가 (i-1,j)이거나 (i,j-1)이어야 한다.</li>
      <li>이때 합이 최소가 되도록 움직여야 하므로, 이전 값이 작은 것이 좋다.</li>
      <li>따라서 이전 위치에서 작은 값+내 값이 된다.</li>
      <li>이를 점화식으로 만들면, dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]</li>
      <li>이때 i-1, j-1의 인덱스 범위를 생각해야하므로 if, else if, else문으로 경우에 따라 더할 값을 처리하였다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 72. Edit Distance</title>
	  <link>/blog//algo-leet72</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet72</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/edit-distance/">https://leetcode.com/problems/edit-distance/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="n">String</span> <span class="n">word1</span><span class="o">,</span> <span class="n">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 초기화</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">j</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="c1">// i, j 문자가 같으면 변경 필요 없음</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)==</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="k">else</span><span class="o">{</span> <span class="c1">// 다른 경우</span>
                    <span class="kt">int</span> <span class="n">insert</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">delete</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">replace</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">insert</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">delete</span><span class="o">,</span> <span class="n">replace</span><span class="o">))+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 셋 중 가장 작은 값+1(이번에 수행한 것)  </span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_4.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>word1는 i, word2는 j로 문자를 체크한다.</li>
      <li>dp[i][j]: word1의 i번째, word2의 j번째를 바꿀 때, 최소 횟수(이전까지의 횟수에 누적)</li>
      <li>i, j는 1부터 시작한다. 따라서 charAt()을 쓸 때는 -1해야한다.</li>
      <li>빈 문자열과 word를 비교할 수도 있으므로 m+1, n+1로 배열을 선언하여 0~m 또는 n까지 체크할 수 있게 하였다.</li>
      <li>i==0 또는 j==0인 곳은 해당 word와 빈 문자열을 비교하는 것과 같다. 따라서 내 word와 같게 계속 삽입하면 되므로 그 횟수로 초기화한다.</li>
      <li>i와 j를 변경하는 세 가지 방법 insert, delete, replace 중, 처음부터 현재 i, j까지를 고려했을 때, 가장 적은 횟수가 드는 것을 선택하고, 여기에 지금 수행한 것(셋 중 하나)를 +1한다.</li>
      <li>insert: i 자리에 알파벳을 추가하므로, j는 i+1에서 체크한다. 다시말하면 j-1과 i를 체크하는 것과 같으므로 dp[i][j-1]이다.</li>
      <li>delete: i를 삭제하는 것이므로 j는 i+1와 비교한다. 즉, j-1과 i를 비교하는 것과 같으므로 dp[i][j-1].</li>
      <li>replace: i를 j로 바꾸는 것이므로 이전의 i-1, j-1을 그대로 가져오면 된다. dp[i-1][j-1].</li>
      <li>셋 중 가장 작은 값을 Math.min()을 두 번 사용함으로써 뽑고, 여기에 현재 수행한 횟수 1을 더한다.</li>
      <li>마지막 dp[m][n]에 최종으로 min 값이 들어있다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 53. Maximum Subarray</title>
	  <link>/blog//algo-leet53</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet53</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>누적합에 i값을 더할 지, 아니면 i값에서부터 다시 시작할 지 둘 중 max로 결정한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">long</span> <span class="n">answer</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// dp에서 최댓값을 저장</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// i를 더하거나, i에서 다시 시작하거나</span>
            <span class="n">answer</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">dp</span><span class="o">));</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_6.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
answer을 dp[0]이 아닌 Integer.MIN으로 초기화해서 실패했다. [-1,-2]인 경우 answer에 -1이 들어가지 않기 때문이다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp[i]=Math.max(dp[i-1]+nums[i], nums[i])</li>
      <li>dp[i]: i번째까지의 누적 합</li>
      <li>이전 합에서 nums[i]를 더한 것과, nums[i] 자체 중 더 큰 값을 설정한다. nums[i]를 선택하게 되면, i부터 누적합을 다시 구하는 것이다.</li>
      <li>dp 마지막 인덱스에 누적 값의 최댓값이 들어온다는 보장은 없으므로, answer을 두어 dp의 최댓값을 저장한다.</li>
      <li>nums[i]의 범위가 int형 범위와 같고, 합을 구하는 문제이기 때문에 오버플로우를 생각하여 dp를 long형으로 선언했다.</li>
      <li>근데 문제는 여기까지 의도한게 맞는건지 모르겠지만, 리턴형이 int여서 마지막에 answer를 int로 형변환하였다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 55. Jump Game</title>
	  <link>/blog//algo-leet55</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet55</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>boolean DP를 이용한다.</li>
  <li>방문한 곳(true)에서만 이동할 수 있는 범위를 체크한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 시작점이니까 방문</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문하지 않은 곳이면 패스</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// i에서 뛸 수 있는 범위 체크</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 뛸 수 있는 곳은 true</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> 
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_7.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
BFS로 시도했으나 또 시간초과나서 DP로 수정해서 풀었다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>boolean[] dp를 이용한다. dp[i]=true면 방문한 곳, false는 방문할 수 없는 곳이다.</li>
      <li>0에서 시작하므로 dp[0]=true이다.</li>
      <li>dp[i]=false는 방문할 수 없는 곳이므로 뛸 수 없다. 따라서 continue로 패스한다.</li>
      <li>i에서 뛸 수 있는 곳을 j로 체크한다. dp[i+j]는 갈 수 있는 곳이므로 true로 바꾼다.</li>
      <li>마지막 dp[n-1]이 true라면 도착할 수 있는 것이고, 아니면 없다는 뜻이다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 46. Permutations</title>
	  <link>/blog//algo-leet46</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet46</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>i 위치에서 건너뛸 수 있는 max를 구하고, 1~max까지 뛰어본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span><span class="o">;</span> <span class="c1">// 사용 여부 체크</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visit</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>
        
        <span class="n">permutation</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(),</span> <span class="n">nums</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">permutation</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="n">n</span><span class="o">){</span> <span class="c1">// 순열 생성 완료</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 사용한 숫자는 패스</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">permutation</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 재귀를 끝내고 다시 돌아온 후, 다음 사용을 위해 원상복구</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_3.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">재귀를 이용해 순열을 구한다</span></strong>
    <ul>
      <li>순열은 순서를 고려한다.</li>
      <li>visit[] 배열을 둬서 숫자 사용 여부를 체크한다. 이를 통해 중복을 거른다.</li>
      <li>for문에서 0부터 n까지 숫자를 확인한다. visit[i]가 true면 사용한 숫자이므로 패스한다.</li>
      <li>사용하지 않은 숫자는 true로 바꾸고, list에 넣은 후 다시 permutation()을 재귀 호출한다. 이렇게 해서 n개의 숫자를 고른다.</li>
      <li>n개를 다 골랐으면 result에 넣는다. 이때 result.add(list)를 하면 리스트 내에 빈 값만 들어간다. 따라서 위와 같이 작성해야 한다(이유는 아직 이해가 안된다).</li>
      <li>재귀를 끝나고 재귀 호출 다음으로 돌아오면, 방금 넣었던 nums[i]를 지금 선택하지 않는 경우를 위해 list에서도 삭제, visit에서도 false로 바꾼다. 다음 사용을 위함이다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 45. Jump Game II</title>
	  <link>/blog//algo-leet45</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet45</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/jump-game-ii/">https://leetcode.com/problems/jump-game-ii/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>i 위치에서 건너뛸 수 있는 max를 구하고, 1~max까지 뛰어본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// Math.min을 사용하기 위함</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// i 위치에서 다 체크</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// 1부터 nums[i]까지 뛰어본다, 단 배열 범위 벗어나지 않는 범위내에서</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 기존 점프 횟수와 i에서 뛴 것 중 작은 값 선택</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
처음에는 BFS로 문제를 코드를 작성했는데, 특정 테케에서 시간 초과로 다른 사람의 코드를 참고했다. 뭔가 DP 느낌은 들었는데 점화식이 떠오르지 않았다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>nums 개수 만큼 dp를 만든다.</li>
      <li>Math.min()을 이용하여 둘 중 작은 값을 넣을 것이기 때문에 dp가 0으로 초기화 되어있으면 안된다. 따라서 Integer.MAX_VALUE로 min을 통해 값이 무조건 변경되도록 한다.</li>
      <li>i는 dp에서 확인할 위치이다.</li>
      <li>j는 i에서 1부터 nums[i]번 만큼 뛸 수 있는 경우다. 예를 들어 [2,3,1,1,4]에서 0번째 인덱스에서는 1부터 2까지 뛸 수 있다.</li>
      <li>따라서 j는 1부터 nums[i]만큼 뛰어보는데, 이때 i+j가 배열 범위를 벗어나면 안된다.</li>
      <li>dp[i+j]는 i위치에서 j만큼 뛴 곳이다. 이곳의 값은 기존 dp[i+j]를 유지하거나, i에서 j만큼 뛰어 해당 위치에 가는 두 방법이 있다. 따라서 dp[i]+1과 기존 dp[i+j] 중 작은 값을 택한다.</li>
      <li>dp[마지막 위치]에는 인덱스 0부터 뛴 경우를 다 체크하고 min값이 들어갈 것이므로, 해당 값을 리턴하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 42. Trapping Rain Water</title>
	  <link>/blog//algo-leet42</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet42</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">https://leetcode.com/problems/trapping-rain-water/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>i 위치에서 왼쪽, 오른쪽으로 max 높이를 구한다.</li>
  <li>둘 중 작은 값-내 높이 가 i에서 물의 영역이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        
        <span class="c1">// 왼쪽으로 max 높이 저장</span>
        <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">height</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// 오른쪽</span>
        <span class="n">right</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]=</span><span class="n">height</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--){</span>
            <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="c1">// 물 영역 계산</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">answer</span><span class="o">+=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">])-</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_1.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>i 위치에서 물 영역을 계산하려면 왼쪽 오른쪽에서 경계를 찾아야 한다. DP를 사용하지 않고 Brute Force로 진행하면 i위치에 따른 left, right max 높이를 계속 구해야 한다. 이 값은 변하는 것이 아니기 때문에 dp에 넣고 한 번만 체크하는 것이 더 시간을 단축시킨다.</li>
      <li>left[i]는 i 기준 왼쪽에서 가장 큰 높이를 저장한다.</li>
      <li>이전까지의 최대 높이(left[i-1])와 현재 내 높이(height[i]) 중 큰 값을 left[i]에 저장한다.</li>
      <li>right도 같다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">물을 계산한다</span></strong>
    <ul>
      <li>water[i]=min(left[i], right[i])-height[i]이다.</li>
      <li>왼쪽, 오른쪽 최대 높이에서 작은 높이까지만 물을 담을 수 있으므로 min을 통해 둘 중 하나를 선택한다.</li>
      <li>내 높이까지는 물을 채울 수 없으므로 height[i]를 뺀다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
