<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[Android/STOMP] STOMP 사용</title>
	  <link>/blog//android-stomp01</link>
	  <author></author>
	  <pubDate>2021-02-04T09:00:00+09:00</pubDate>
	  <guid>/blog//android-stomp01</guid>
	  <description><![CDATA[
	     <p>Simple Text Oriented Messaging Protocol</p>

<h2 id="-setting">👊 Setting</h2>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">repositories</span> <span class="o">{</span> 
    <span class="n">jcenter</span><span class="o">()</span>
    <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s">"https://jitpack.io"</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">implementation</span> <span class="err">'</span><span class="n">com</span><span class="o">.</span><span class="na">github</span><span class="o">.</span><span class="na">NaikSoftware</span><span class="o">:</span><span class="nl">StompProtocolAndroid:</span><span class="mf">1.6</span><span class="o">.</span><span class="mi">6</span><span class="err">'</span>
<span class="o">}</span>
</code></pre></div></div>
<p><a href="https://github.com/NaikSoftware/StompProtocolAndroid">https://github.com/NaikSoftware/StompProtocolAndroid</a>를 이용하였다.</p>

<h3 id="1-stomp-생성-및-connect">1. STOMP 생성 및 Connect</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="kd">private</span> <span class="n">StompClient</span> <span class="n">stompClient</span><span class="o">;</span>
<span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StompHeader</span><span class="o">&gt;</span> <span class="n">headerList</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">initStomp</span><span class="o">(){</span>
    <span class="n">stompClient</span><span class="o">=</span> <span class="n">Stomp</span><span class="o">.</span><span class="na">over</span><span class="o">(</span><span class="n">Stomp</span><span class="o">.</span><span class="na">ConnectionProvider</span><span class="o">.</span><span class="na">OKHTTP</span><span class="o">,</span> <span class="n">wsServerUrl</span><span class="o">);</span>

    <span class="n">stompClient</span><span class="o">.</span><span class="na">lifecycle</span><span class="o">().</span><span class="na">subscribe</span><span class="o">(</span><span class="n">lifecycleEvent</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">lifecycleEvent</span><span class="o">.</span><span class="na">getType</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nl">OPENED:</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Stomp connection opened"</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">ERROR:</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Error"</span><span class="o">,</span> <span class="n">lifecycleEvent</span><span class="o">.</span><span class="na">getException</span><span class="o">());</span>
                <span class="k">if</span><span class="o">(</span><span class="n">lifecycleEvent</span><span class="o">.</span><span class="na">getException</span><span class="o">().</span><span class="na">getMessage</span><span class="o">().</span><span class="na">contains</span><span class="o">(</span><span class="s">"EOF"</span><span class="o">)){</span>
                    <span class="n">isUnexpectedClosed</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="nl">CLOSED:</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"Stomp connection closed"</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isUnexpectedClosed</span><span class="o">){</span>
                    <span class="cm">/**
                        * EOF Error
                        */</span>
                    <span class="n">initStomp</span><span class="o">();</span>
                    <span class="n">isUnexpectedClosed</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="c1">// add Header</span>
    <span class="n">headerList</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="n">headerList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">StompHeader</span><span class="o">(</span><span class="s">"Authorization"</span><span class="o">,</span> <span class="n">G</span><span class="o">.</span><span class="na">accessToken</span><span class="o">));</span>
    <span class="n">stompClient</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">headerList</span><span class="o">);</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>먼저 stomp.over()로 stompClient를 생성한다.</li>
  <li>첫 번째 파라미터는 connection이다. 현재 OkHttp와 JWS가 가능하다.</li>
  <li>두 번째 파라미터는 연결하고자 하는 서버 주소이다.</li>
  <li>다음은 stompClient의 lifeCycle에 따라 필요한 조건이 있을 경우 선언한다.</li>
  <li>헤더에 추가해야할 것이 있다면 StompHeader()를 이용해서 만든다.</li>
  <li>이제 connect()로 연결!</li>
</ul>

<h4 id="주소는-ws">⭐⭐주소는 ws</h4>
<ul>
  <li>연결하려는 주소가 http로 시작하면 ws, https는 wss로 시작하며, 마지막에 /websocket을 꼭 붙여야 한다.</li>
  <li>connect에 성공하면 101을 받는다.</li>
</ul>

<h3 id="2-send-subscribe">2. Send, Subscribe</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="cm">/**
* 보낼 JSONObject 만들기
* */</span>
<span class="n">stompClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">"send할 주소"</span><span class="o">,</span> <span class="n">jsonObject</span><span class="o">.</span><span class="na">toJSONString</span><span class="o">()).</span><span class="na">subscribe</span><span class="o">();</span>
        

<span class="n">stompClient</span><span class="o">.</span><span class="na">topic</span><span class="o">(</span><span class="s">"subscribe할 주소"</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span><span class="n">topicMessage</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="n">JSONParser</span> <span class="n">parser</span><span class="o">=</span><span class="k">new</span> <span class="n">JSONParser</span><span class="o">();</span>
    <span class="n">Object</span> <span class="n">obj</span><span class="o">=</span><span class="n">parser</span><span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">topicMessage</span><span class="o">.</span><span class="na">getPayload</span><span class="o">());</span>
    <span class="o">...</span>
<span class="o">});</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>tooooooo easy!0!</li>
  <li>send()할때 뒤에 .subscribe() 잊지 말자.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Android] Service 정리</title>
	  <link>/blog//android-service01</link>
	  <author></author>
	  <pubDate>2021-02-04T09:00:00+09:00</pubDate>
	  <guid>/blog//android-service01</guid>
	  <description><![CDATA[
	     <h3 id="service">Service</h3>
<ul>
  <li>FG, BG, binder</li>
  <li>back으로 종료하는 경우 service는 살아있고, overview로 종료하면 서비스가 종료된다고 알고 있다.</li>
  <li>startService로 실행한 서비스는 (중간에 bindService 진행해도) stopService로 종료해야 끝난다.</li>
  <li>bindSerivce로 실행하면 unbindService로 종료한다.</li>
  <li>참고로 bindService는 바인딩이 모두 해제되어야 종료된다.</li>
  <li>startService는 onStartCommand()를 진행, bindService는 바로 onBind() 진행한다.</li>
  <li>보통 service 호출 및 종료를 같은 액티비티(프래그먼트)에서 진행하지 않는데, 확실하게 죽이고 싶으면 같은 곳에서 하는게 좋다.</li>
</ul>

<h3 id="stopservice가-ondestroy를-호출하지-않을-때">stopService가 onDestroy()를 호출하지 않을 때</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">getActivity</span><span class="o">().</span><span class="na">bindService</span><span class="o">(</span><span class="n">LoginActivity</span><span class="o">.</span><span class="na">getPushIntent</span><span class="o">(),</span> <span class="n">mConnection</span><span class="o">,</span> <span class="n">Context</span><span class="o">.</span><span class="na">BIND_ADJUST_WITH_ACTIVITY</span><span class="o">);</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>flag를 Context.BIND_AUTO_CREATE가 아니라 위의 값으로 변경</li>
  <li>근데 같은 코드지만 디바이스마다 onDestory()가 호출되는 시간이 달라보였다🤷‍♂️.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Android/error] ListView Item에 중복된 값이 나오는 문제 해결</title>
	  <link>/blog//android-error01</link>
	  <author></author>
	  <pubDate>2021-02-04T09:00:00+09:00</pubDate>
	  <guid>/blog//android-error01</guid>
	  <description><![CDATA[
	     <h3 id="-문제">🤦‍ 문제</h3>
<ul>
  <li>Adapter를 이용하여 ListView에 item을 띄우는 과정에서, 화면을 스크롤하면 밑에 있는 값들이 제대로 안나옴</li>
  <li>List에는 제대로 들어가는데, 화면에 이상하게 띄우는 듯</li>
</ul>

<h3 id="-해결">💃 해결</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre> <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">View</span> <span class="nf">getView</span><span class="o">(</span><span class="kt">int</span> <span class="n">position</span><span class="o">,</span> <span class="n">View</span> <span class="n">view</span><span class="o">,</span> <span class="n">ViewGroup</span> <span class="n">viewGroup</span><span class="o">){</span>
        <span class="n">GroupItem</span> <span class="n">item</span><span class="o">=</span> <span class="n">groupItems</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">position</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">view</span><span class="o">==</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">View</span> <span class="n">itemView</span><span class="o">=</span><span class="n">layoutInflater</span><span class="o">.</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">item_group</span><span class="o">,</span> <span class="n">viewGroup</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="n">CircleImageView</span> <span class="n">iv</span><span class="o">=</span><span class="n">itemView</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">iv_group</span><span class="o">);</span>
            <span class="n">TextView</span> <span class="n">tvTitle</span><span class="o">=</span><span class="n">itemView</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tv_groupmsg</span><span class="o">);</span>
            <span class="n">tvTitle</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="n">Glide</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">itemView</span><span class="o">).</span><span class="na">load</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getProfile</span><span class="o">()).</span><span class="na">error</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">profile_default</span><span class="o">).</span><span class="na">into</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>

            <span class="k">return</span> <span class="n">itemView</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="n">CircleImageView</span> <span class="n">iv</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">iv_group</span><span class="o">);</span>
            <span class="n">TextView</span> <span class="n">tvTitle</span><span class="o">=</span><span class="n">view</span><span class="o">.</span><span class="na">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tv_groupmsg</span><span class="o">);</span>
            <span class="n">tvTitle</span><span class="o">.</span><span class="na">setText</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
            <span class="n">Glide</span><span class="o">.</span><span class="na">with</span><span class="o">(</span><span class="n">view</span><span class="o">).</span><span class="na">load</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getProfile</span><span class="o">()).</span><span class="na">error</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">profile_default</span><span class="o">).</span><span class="na">into</span><span class="o">(</span><span class="n">iv</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">view</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>이런식으로 view가 null인지 아닌지로 나눠서 코드를 작성해야 한다.</li>
  <li>UI가 view를 reuse하기 때문에, view가 null이면 새로 만들고, 아니라면 기존 인스턴스에 item을 넣어야 된다고 한다.</li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li>Duplicated entries in ListView <a href="https://stackoverflow.com/questions/8261376/duplicated-entries-in-listview">https://stackoverflow.com/questions/8261376/duplicated-entries-in-listview</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Android/WebRTC] WebRTC 개념</title>
	  <link>/blog//android-webrtc02</link>
	  <author></author>
	  <pubDate>2021-02-04T09:00:00+09:00</pubDate>
	  <guid>/blog//android-webrtc02</guid>
	  <description><![CDATA[
	     <ul>
  <li>Web Real-Time Communications</li>
  <li>별도의 소프트웨어없이 음성, 영상, 텍스트, 파일 등의 데이터를 브라우저끼리 주고 받을 수 있게 만든 기술</li>
  <li>P2P 통신에 최적화</li>
  <li>MediaStream: 카메라, 마이크 등의 데이터 스트림에 접근</li>
  <li>RTCPeerConnection: 암호화, 대역폭 관리, 오디오/비디오 연결 담당</li>
  <li>RTCDataChannel: 음성, 영상 데이터가 아닌, json/text 데이터를 주고받음</li>
</ul>

<h3 id="수행-과정">수행 과정</h3>
<p><img src="./assets/images/210204_1.jpeg" alt="이미지" width="70%" height="70%" /></p>
<ol>
  <li>Fetching: peer에게 보낼 나의 음성, 영상 데이터를 수집</li>
  <li>Signaling: peer와 연결하기 위해 peer의 정보를 탐색</li>
  <li>Connection: 발견된 peer와 P2P connection 진행. 채널을 개방해둠</li>
  <li>Communication: 개방해놓은 채널을 통해 데이터를 주고받음</li>
</ol>

<h3 id="signaling">Signaling</h3>
<ul>
  <li>Peer들이 데이터를 교환할 수 있게 처리해주는 과정</li>
  <li>peer들이 통신하기 위해서는 서버가 필요하고, 서버를 통해 서로의 SessionDescription을 교환해야함</li>
  <li>ICE Framework를 사용해 내 ip, port를 찾아서 서로의(peer) network 정보를 교환</li>
  <li>SDP 형식을 따르는 offer, answer를 주고받으며 Media Capability(각자 사용 가능한 코덱, 해상도 등이 무엇인지) 교환</li>
  <li>Session Control Messages(통신 연결의 초기화, 종료)를 교환</li>
</ul>

<h3 id="stunturn-server">STUN/TURN Server</h3>
<ul>
  <li>P2P 통신이 가능하도록 해줌</li>
  <li>peer들이 연결하려면 서로의 ip를 알아야하는데, 실제로는 방화벽 등으로 peer들간의 연결이 쉽지 않음 이때 STUN, TURN 서버를 사용한다.</li>
</ul>

<h3 id="stun">STUN</h3>
<ul>
  <li>Session Traversal Utilities for NAT</li>
  <li>NAT 환경에서 내 ip 주소를 알려줌</li>
  <li>클라이언트 A는 STUN 서버를 통해 내 ip 주소가 뭔지 받고, 접근 가능한지 알아냄</li>
</ul>

<h3 id="nat">NAT</h3>
<ul>
  <li>Network Address Translation</li>
  <li>단말에 공개 ip 주소를 할당하기 위해 사용됨</li>
  <li>모든 단말들은 라우터에 연결되어있고, 라우터는 공개, 비공개 ip 주소를 가지고 있음</li>
  <li>peer간의 요청은 단말의 private ip로부터 라우터의 공개 ip 주소, 유일한 포트 기반으로 가능해짐</li>
</ul>

<h3 id="turn">TURN</h3>
<ul>
  <li>Traversal Using Relays around NAT</li>
  <li>어떤 라우터들은 네트워크에 연결할 수 있는 제한이 있어서, STUN으로 공개 ip 주소를 알아내도 모두가 연결할 수 있는 것은 아님 -&gt; TURN 서버가 필요</li>
  <li>몇몇 라우터는 Symmetric NAT(이전에 연결한 적이 있는 연결들만 허용함)을 채용하고 있음 -&gt; TURN 서버와 연결하고 모든 정보를 그 서버에 전달하는 것으로 Symmetric NAT 제한을 우회하는 방식으로 진행</li>
  <li>TURN 서버와 연결한 후 모든 peer들에게 모든 패킷을 보내고 다시 본인에게 전달해달라고 해야하므로 오버헤드가 발생</li>
</ul>

<h3 id="sdp">SDP</h3>
<ul>
  <li>Session Description Protocol</li>
  <li>스트리밍 미디어 포맷</li>
  <li>해상도, 형식, 코덱, 암호화 등의 멀티미디어 컨텐츠의 연결을 설명하기 위한 표준 프로토콜</li>
  <li>peer간의 ice candidate 교환 후 createOffer()로 offer SDP를 생성(내가 사용 가능한 코덱, 해상도 등의 정보가 담김) 및 전송</li>
  <li>offer sdp를 받은 peer는 setRemoteDescription()을 수행</li>
  <li>받은 peer는 createAnswer()로 answer SDP를 생성하고 전달</li>
  <li>쌍방으로 모두 진행되야 함</li>
  <li>둘 다 setRemoteDescription()이 수행되면 P2P 연결 성공</li>
</ul>

<h3 id="ice-candidate">ICE Candidate</h3>
<ul>
  <li>Interactive Connectivity Establishment</li>
  <li>브라우저가 peer를 통한 연결이 가능하도록 하게 해주는 프레임워크</li>
  <li>내 네트워크 정보</li>
  <li>onIceCandidate()로 내 ice candidate를 확보해서 전달</li>
  <li>peer의 candidate가 도착하면, addIceCandidate()로 peer의 네트워크 정보를 등록해야함</li>
</ul>

<h4 id="참고">참고</h4>
<ul>
  <li>[WebRTC] WebRTC란? <a href="https://medium.com/@hyun.sang/webrtc-webrtc%EB%9E%80-43df68cbe511">https://medium.com/@hyun.sang/webrtc-webrtc%EB%9E%80-43df68cbe511</a></li>
  <li>2018 webRTC 정리 <a href="http://jaynewho.com/post/36">http://jaynewho.com/post/36</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Android/WebRTC] WebRTC 세팅 및 sdp, candidate 생성</title>
	  <link>/blog//android-webrtc01</link>
	  <author></author>
	  <pubDate>2021-01-31T09:00:00+09:00</pubDate>
	  <guid>/blog//android-webrtc01</guid>
	  <description><![CDATA[
	     <h3 id="-setting">👊 Setting</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">implementation</span> <span class="err">'</span><span class="n">org</span><span class="o">.</span><span class="na">webrtc</span><span class="o">:</span><span class="n">google</span><span class="o">-</span><span class="nl">webrtc:</span><span class="mf">1.0</span><span class="o">.+</span><span class="err">'</span>
</code></pre></div></div>
<p>로 추가 가능하나, 블로그 대부분의 예시가 arr파일로 되어있어서 나도 arr 파일을 사용하였다 😎</p>
<ul>
  <li>아래 코드는 audio를 가져오는 코드로, video도 생성하고 싶은 경우 VideoTrack을 이용하면 쉽게 구현할 수 있다.</li>
</ul>

<h3 id="1-webrtc-세팅">1. WebRTC 세팅</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">feature</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.hardware.camera"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">feature</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.hardware.camera.autofocus"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">feature</span>
    <span class="nl">android:</span><span class="n">glEsVersion</span><span class="o">=</span><span class="s">"0x00020000"</span>
    <span class="nl">android:</span><span class="n">required</span><span class="o">=</span><span class="s">"true"</span> <span class="o">/&gt;</span>

<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.INTERNET"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.ACCESS_NETWORK_STATE"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.CHANGE_NETWORK_STATE"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.READ_EXTERNAL_STORAGE"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.WRITE_EXTERNAL_STORAGE"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.RECORD_AUDIO"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.MODIFY_AUDIO_SETTINGS"</span> <span class="o">/&gt;</span>
<span class="o">&lt;</span><span class="n">uses</span><span class="o">-</span><span class="n">permission</span> <span class="nl">android:</span><span class="n">name</span><span class="o">=</span><span class="s">"android.permission.CAMERA"</span> <span class="o">/&gt;</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>먼저, 필요한 permission을 AndroiMenifest.xml에 추가한다.</li>
  <li>다음으로, WebRTC에 필요한 생성 및 초기화를 진행한다.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">initWebRTC</span><span class="o">(){</span>
    <span class="n">PeerConnectionFactory</span><span class="o">.</span><span class="na">initializeAndroidGlobals</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>

    <span class="n">PeerConnectionFactory</span><span class="o">.</span><span class="na">Options</span> <span class="n">options</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PeerConnectionFactory</span><span class="o">.</span><span class="na">Options</span><span class="o">();</span>
    <span class="n">peerConnectionFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PeerConnectionFactory</span><span class="o">(</span><span class="n">options</span><span class="o">);</span>

    <span class="n">audioConstraints</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MediaConstraints</span><span class="o">();</span>
    <span class="n">audioSource</span> <span class="o">=</span> <span class="n">peerConnectionFactory</span><span class="o">.</span><span class="na">createAudioSource</span><span class="o">(</span><span class="n">audioConstraints</span><span class="o">);</span>
    <span class="n">localAudioTrack</span> <span class="o">=</span> <span class="n">peerConnectionFactory</span><span class="o">.</span><span class="na">createAudioTrack</span><span class="o">(</span><span class="s">"101"</span><span class="o">,</span> <span class="n">audioSource</span><span class="o">);</span>
    <span class="n">localAudioTrack</span><span class="o">.</span><span class="na">setEnabled</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>

    <span class="n">sdpConstraints</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MediaConstraints</span><span class="o">();</span>
    <span class="n">sdpConstraints</span><span class="o">.</span><span class="na">mandatory</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">MediaConstraints</span><span class="o">.</span><span class="na">KeyValuePair</span><span class="o">(</span><span class="s">"offerToReceiveAudio"</span><span class="o">,</span> <span class="s">"true"</span><span class="o">));</span>
    <span class="n">sdpConstraints</span><span class="o">.</span><span class="na">mandatory</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">MediaConstraints</span><span class="o">.</span><span class="na">KeyValuePair</span><span class="o">(</span><span class="s">"offerToReceiveVideo"</span><span class="o">,</span> <span class="s">"false"</span><span class="o">));</span> 

    <span class="n">stream</span> <span class="o">=</span> <span class="n">peerConnectionFactory</span><span class="o">.</span><span class="na">createLocalMediaStream</span><span class="o">(</span><span class="s">"102"</span><span class="o">);</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">addTrack</span><span class="o">(</span><span class="n">localAudioTrack</span><span class="o">);</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>audioSource를 생성하기 위해 PeerConnectionFactory을 생성 및 초기화한다.</li>
  <li>audioConstraints를 통해 audio를 생성하고, localAudioTrack으로 audio를 setEnable한다.</li>
  <li>sdpConstraints는 SDP 정보를 생성하는 것으로, 연결하고자 하는 Peer간의 미디어와 네트워크에 관한 정보를 이해하기 위해 사용된다.</li>
  <li>마지막으로 stream을 통해 생성한 audioTrack을 넣으면 WebRTC 초기 세팅이 끝난다.</li>
</ul>

<h3 id="2-sdp와-icecandidate-전달">2. SDP와 IceCandidate 전달</h3>

<ul>
  <li>두 Peer가 서버와 연결되면, 같은 dest를 가지고 있는 Peer들은 sdp와 candidate를 교환해야 한다.</li>
  <li>SDP(Session Description Protocol)은 미디어 정보를 서로 교환한다.</li>
  <li>sdp는 (연결하고자 하는) A가 만든 sdp(createOffer())와, 상대방(A)의 sdp를 받고 제대로 받았음을 send할 B의 sdp(createAnswer())가 필요하다.</li>
</ul>

<h4 id="createoffer">createOffer()</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setPeer</span><span class="o">(){</span>
    <span class="o">...</span>
    <span class="k">if</span><span class="o">(</span><span class="n">initCall</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">newPeer</span><span class="o">.</span><span class="na">createOffer</span><span class="o">(</span><span class="k">new</span> <span class="n">CustomSdpObserver</span><span class="o">(</span><span class="s">"newPeerCreateOffer"</span><span class="o">)</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreateSuccess</span><span class="o">(</span><span class="n">SessionDescription</span> <span class="n">sessionDescription</span><span class="o">)</span> <span class="o">{</span>
                    <span class="kd">super</span><span class="o">.</span><span class="na">onCreateSuccess</span><span class="o">(</span><span class="n">sessionDescription</span><span class="o">);</span>
                    <span class="n">createdDescription</span><span class="o">(</span><span class="n">sessionDescription</span><span class="o">,</span> <span class="n">peerUuid</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">},</span> <span class="n">sdpConstraints</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>createOffer()로 sdp를 생성하면, onCreateSuccess()의 파라미터 sessionDescription으로 생성된 sdp를 확인할 수 있다. 이제 생성된 sdp를 서버로 전송해주면 된다.</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">createdDescription</span><span class="o">(</span><span class="n">SessionDescription</span> <span class="n">sessionDescription</span><span class="o">,</span> <span class="n">String</span> <span class="n">peerUuid</span><span class="o">){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"createdDescription"</span><span class="o">);</span>

    <span class="n">CustomPeerConnection</span> <span class="n">tempPeer</span><span class="o">=</span> <span class="n">peerMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">peerUuid</span><span class="o">);</span>
    <span class="n">tempPeer</span><span class="o">.</span><span class="na">pc</span><span class="o">.</span><span class="na">setLocalDescription</span><span class="o">(</span><span class="k">new</span> <span class="n">CustomSdpObserver</span><span class="o">(</span><span class="s">"createdDescription"</span><span class="o">),</span> <span class="n">sessionDescription</span><span class="o">);</span>

    <span class="cm">/**
      * createOffer()한 sdp를 서버로 전송
      */</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h4 id="createanswer">createAnswer()</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="n">tempPeer</span><span class="o">.</span><span class="na">pc</span><span class="o">.</span><span class="na">createAnswer</span><span class="o">(</span><span class="k">new</span> <span class="n">CustomSdpObserver</span><span class="o">(</span><span class="s">"offer createAnswer"</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreateSuccess</span><span class="o">(</span><span class="n">SessionDescription</span> <span class="n">sessionDescription</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreateSuccess</span><span class="o">(</span><span class="n">sessionDescription</span><span class="o">);</span>
        <span class="n">tempPeer</span><span class="o">.</span><span class="na">pc</span><span class="o">.</span><span class="na">setLocalDescription</span><span class="o">(</span><span class="k">new</span> <span class="n">CustomSdpObserver</span><span class="o">(</span><span class="s">"offer setLocal"</span><span class="o">),</span> <span class="n">sessionDescription</span><span class="o">);</span>
        <span class="n">createdDescription</span><span class="o">(</span><span class="n">sessionDescription</span><span class="o">,</span> <span class="n">peerUuid</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="k">new</span> <span class="n">MediaConstraints</span><span class="o">());</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>상대방의 sdp를 제대로 받았음을 전송하는 sdp이다.</li>
  <li>sdp 교환이 끝나면, Ice Candidates를 교환한다.</li>
</ul>

<h3 id="onicecandidate">onIceCandidate()</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="n">PeerConnection</span> <span class="n">newPeer</span><span class="o">=</span><span class="n">peerConnectionFactory</span><span class="o">.</span><span class="na">createPeerConnection</span><span class="o">(</span><span class="n">iceServerList</span><span class="o">,</span> <span class="n">sdpConstraints</span><span class="o">,</span>
    <span class="k">new</span> <span class="nf">CustomPeerConnectionObserver</span><span class="o">(</span><span class="s">"newPeerCreation"</span><span class="o">)</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onIceCandidate</span><span class="o">(</span><span class="n">IceCandidate</span> <span class="n">iceCandidate</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"onIceCandidate"</span><span class="o">);</span>
            <span class="kd">super</span><span class="o">.</span><span class="na">onIceCandidate</span><span class="o">(</span><span class="n">iceCandidate</span><span class="o">);</span>
            <span class="cm">/**
                * 생성된 iceCandidate(파라미터 값)을 서버로 전송
                */</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onAddStream</span><span class="o">(</span><span class="n">MediaStream</span> <span class="n">mediaStream</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">.</span><span class="na">onAddStream</span><span class="o">(</span><span class="n">mediaStream</span><span class="o">);</span>
            <span class="n">gotRemoteStream</span><span class="o">(</span><span class="n">mediaStream</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">});</span>

<span class="n">newPeer</span><span class="o">.</span><span class="na">addStream</span><span class="o">(</span><span class="n">stream</span><span class="o">);</span>
        </pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>onAddStream이 호출되면 Peer 연결에 성공했다는 뜻이다.</li>
  <li>A와 B가 iceCandidate 교환에 성공하면, connection되어 audio 전송이 가능해진다.</li>
</ul>

<h3 id="4-참고">4. 참고</h3>
<h4 id="customsdpobserverjava">CustomSdpObserver.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="kd">class</span> <span class="nc">CustomSdpObserver</span> <span class="kd">implements</span> <span class="n">SdpObserver</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="n">String</span> <span class="n">tag</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getCanonicalName</span><span class="o">();</span>

    <span class="n">CustomSdpObserver</span><span class="o">(</span><span class="n">String</span> <span class="n">logTag</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">tag</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">tag</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">logTag</span><span class="o">;</span>
    <span class="o">}</span>


    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreateSuccess</span><span class="o">(</span><span class="n">SessionDescription</span> <span class="n">sessionDescription</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"onCreateSuccess() called with: sessionDescription = ["</span> <span class="o">+</span> <span class="n">sessionDescription</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSetSuccess</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"onSetSuccess() called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreateFailure</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"onCreateFailure() called with: s = ["</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSetFailure</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">tag</span><span class="o">,</span> <span class="s">"onSetFailure() called with: s = ["</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">"]"</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>CustomSdpObserver는 SdpObserver를 implement하여, SDP와 관련된 이벤트들을 체크한다.</li>
  <li>SdpObserver가 필요한 곳에 override method를 다 써줄 순 없으니까 Custom class를 하나 생성하여, 필요한 메소드가 있을 경우 override해준다.</li>
</ul>

<h4 id="음량-조절-기능">음량 조절 기능</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">muteAudio</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">action</span><span class="o">){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"muteAudio"</span><span class="o">);</span>
    <span class="n">stream</span><span class="o">.</span><span class="na">audioTracks</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">setEnabled</span><span class="o">(</span><span class="n">action</span><span class="o">);</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setVolume</span><span class="o">(</span><span class="kt">long</span> <span class="n">uid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">volume</span><span class="o">){</span>
    <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"setVolume "</span><span class="o">+</span><span class="n">uid</span><span class="o">+</span><span class="s">" "</span><span class="o">+</span><span class="n">volume</span><span class="o">);</span>
    <span class="n">audioMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">uid</span><span class="o">).</span><span class="na">setVolume</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span><span class="n">volume</span><span class="o">);</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>audio, video는 MediaStream에서 관리한다.</li>
  <li>
    <p>initWebRTC()에서 audio, video를 세팅해주고 addTrack()으로 나의 audio 데이터를 담았다.</p>
  </li>
  <li>참고로, MediaStream에는 audioTracks와 videoTracks가 존재한다(둘다 LinkedList).</li>
  <li>그래서 내 audio는 media.audioTrack.get(0)이 된다.</li>
  <li>
    <p>음소거 기능은 setEnabled()로 관리하며, false가 음소거이다.</p>
  </li>
  <li>audio는 LinkedList형태로 peer들이 들어올 때마다 뒤에서 삽입되므로 해당 인덱스를 찾는다면 특정 peer의 음량을 조절할 수 있다.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Android/React-Native] Windows 설치 및 프로젝트 실행</title>
	  <link>/blog//android-react-setup</link>
	  <author></author>
	  <pubDate>2020-11-22T09:00:00+09:00</pubDate>
	  <guid>/blog//android-react-setup</guid>
	  <description><![CDATA[
	     <h2 id="설치">설치</h2>

<h3 id="1-nvm과-node">1. nvm과 node</h3>
<ul>
  <li><a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a>에서 nvm-setup.zip 다운로드</li>
  <li>압축해제 및 설치</li>
  <li>nvm install <버전></버전></li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="n">nvm</span> <span class="n">install</span> <span class="mf">10.16</span><span class="o">.</span><span class="mi">2</span> <span class="c1">// 설치</span>
<span class="n">nvm</span> <span class="n">use</span> <span class="mf">10.16</span><span class="o">.</span><span class="mi">2</span> <span class="c1">// 활성화</span>

<span class="c1">// 버전 확인으로 제대로 설치되었는지 체크</span>
<span class="n">node</span> <span class="o">-</span><span class="n">v</span>
<span class="n">npm</span> <span class="o">-</span><span class="n">v</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="2-java-open-jdk">2. Java open jdk</h3>
<ul>
  <li>Java 유저라면 있을테니까 패스</li>
  <li>버전 체크로 설치되어 있는지 체크</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">java</span> <span class="o">-</span><span class="n">version</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>설치 후 환경변수(JAVA_HOME) 등록</li>
</ul>

<h3 id="3-python">3. Python</h3>
<ul>
  <li><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">python</span> <span class="o">--</span><span class="n">version</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>버전 체크로 설치 확인</li>
  <li>나의 경우 구체적인 버전이 나오지 않고 Python이라고만 출력되었는데도 문제 X</li>
</ul>

<h3 id="4-react-native-cli">4. React Native CLI</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">react</span><span class="o">-</span><span class="kd">native</span><span class="o">-</span><span class="n">cli</span>
<span class="n">react</span><span class="o">-</span><span class="kd">native</span> <span class="o">--</span><span class="n">version</span> <span class="c1">//버전 체크</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="5-안드로이드-스튜디오">5. 안드로이드 스튜디오</h3>
<ul>
  <li>기존에 있어서 설치 패스</li>
  <li>설치 후 시스템 환경 변수 편집&gt; 환경 변수&gt; 시스템 변수&gt; 새로 만들기</li>
  <li>변수 이름: ANDROID_HOME <br />
변수 값: 안드로이드 실행&gt; File&gt; Settings&gt; Appearance&amp;Behavior&gt; System Setting&gt; Android SDK 에 Android SDK Location
<img src="./assets/images/201122_2.PNG" alt="이미지1" /></li>
  <li>이번에는 시스템 변수 Path 편집</li>
  <li>새로 만들기&gt; 위에 변수값\platform-tools 추가</li>
  <li>cmd 켜놓았다면 다 끄고 재실행</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
</pre></td><td class="code"><pre><span class="n">adb</span> <span class="c1">// adb 명령어가 먹는지 확인</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="6-vs-code">6. VS Code</h3>
<ul>
  <li>이미 설치되어 있어서 패스</li>
</ul>

<h2 id="프로젝트-생성-및-실행">프로젝트 생성 및 실행</h2>

<h3 id="1-vs-code로-프로젝트-생성">1. VS Code로 프로젝트 생성</h3>
<ul>
  <li>상단에서 터미널 열기</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">cd</span> <span class="o">&lt;</span><span class="err">위치</span><span class="o">&gt;</span> <span class="c1">// 프로젝트 생성할 폴더로 이동</span>
<span class="n">react</span><span class="o">-</span><span class="kd">native</span> <span class="n">init</span> <span class="o">&lt;</span><span class="err">프로젝트</span> <span class="err">이름</span><span class="o">&gt;</span> <span class="c1">//프로젝트 생성</span></pre></td></tr></tbody></table></code></pre></figure>

<ul>
  <li>파일&gt; 폴더 열기로 생성한 프로젝트 불러오기</li>
</ul>

<h3 id="2-안드로이드-에뮬레이터-또는-디바이스-실행">2. 안드로이드 에뮬레이터 또는 디바이스 실행</h3>
<ul>
  <li>안드로이드 스튜디오 실행</li>
  <li>에뮬레이터를 사용하려고 한다면 미리 실행시켜 놓고 react를 돌려야 함</li>
  <li>에뮬레이터 설치 안했다면 설치</li>
  <li>build.gradle Module의 targetSdkVersion과 맞는 에뮬레이터 설치</li>
  <li>AVD Manager에서 Create Virutal Device로 설치 가능</li>
  <li>상단에서 AVD Manager 클릭후 Action에서 실행하여 에뮬레이터 구동
 <img src="./assets/images/201122_3.PNG" alt="이미지2" /></li>
  <li>다시 vs 터미널</li>
</ul>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="n">adb</span> <span class="n">devices</span> <span class="c1">// 현재 연결된 디바이스와 에뮬레이터 확인 가능</span>
<span class="n">npx</span> <span class="n">react</span><span class="o">-</span><span class="kd">native</span> <span class="n">run</span><span class="o">-</span><span class="n">android</span> <span class="c1">// 실행</span></pre></td></tr></tbody></table></code></pre></figure>

	  ]]></description>
	</item>

	<item>
	  <title>[Android] 안드로이드 앱 프로그래밍</title>
	  <link>/blog//android01</link>
	  <author></author>
	  <pubDate>2020-08-23T09:00:00+09:00</pubDate>
	  <guid>/blog//android01</guid>
	  <description><![CDATA[
	     <hr />

<h1 id="1-레이아웃">1. 레이아웃</h1>
<ul>
  <li>화면 배치를 도와줌</li>
  <li>Activity의 onCreate() 메소드 안에 setContentView(레이아웃 이름)으로 화면에 표시</li>
</ul>

<h2 id="제약-레이아웃-constraintlayout">제약 레이아웃 (ConstraintLayout)</h2>
<ul>
  <li>제약 조건(Constraint) 기반 모델</li>
  <li>제약 조건을 사용해 화면 구성</li>
  <li>디폴트 레이아웃</li>
</ul>

<h2 id="리니어-레이아웃-linearlayout">리니어 레이아웃 (LinearLayout)</h2>
<ul>
  <li>박스(Box) 모델</li>
  <li>한 쪽 방향(Horizontal, Vertical)으로 차례대로 뷰를 추가하며 화면 구성</li>
  <li>뷰가 차지할 수 있는 사각형 영역을 할당</li>
</ul>

<h2 id="상대-레이아웃-relativelayout">상대 레이아웃 (RelativeLayout)</h2>
<ul>
  <li>규칙(Rule) 기반 모델</li>
  <li>부모 컨테이너나 다른 뷰와의 상대적 위치로 화면을 구성</li>
  <li>제약 레이아웃을 사용하게 되면서 상대 레이아웃은 권장하지 않음</li>
</ul>

<h2 id="테이블-레이아웃-tablelayout">테이블 레이아웃 (TableLayout)</h2>
<ul>
  <li>격자(Grid) 모델</li>
  <li>격자 모양의 배열을 사용하여 화면 구성</li>
  <li>HTML에서 많이 사용하는 정렬 방식과 유사하지만 많이 사용하지는 않음</li>
</ul>

<h2 id="프레임-레이아웃-framelayout">프레임 레이아웃 (FrameLayout)</h2>
<ul>
  <li>싱글(Single) 모델</li>
  <li>가장 상위에 있는 하나의 뷰 또는 뷰그룹만 보여주는 방법</li>
  <li>여러 개의 뷰가 들어가면 중첩하여 쌓게 됨</li>
  <li>가장 단순하지만 여러 개의 뷰를 중첩한 후 각 뷰를 전환하여 보여주는 방식으로 자주 사용</li>
  <li>visibility 속성으로 특정 뷰를 보이거나 보이지 않게 하여 화면이 전환되는 효과를 만듬</li>
</ul>

<h2 id="스크롤-뷰-scrollview">스크롤 뷰 (ScrollView)</h2>
<ul>
  <li>어떤 뷰의 내용물이 넘치면 스크롤을 만들 수 있게 도와줌</li>
</ul>

<hr />

<h1 id="2-기본-위젯과-드로어블">2. 기본 위젯과 드로어블</h1>
<ul>
  <li>기본 위젯: 버튼, 텍스트뷰, 에디트텍스트, 이미지뷰</li>
</ul>

<h2 id="텍스트뷰-textview">텍스트뷰 (TextView)</h2>
<ul>
  <li>화면에서 글자를 보여주는 역할
    <h3 id="속성">속성</h3>
  </li>
  <li>text: 텍스트뷰의 문자열을 설정</li>
  <li>textColor: 문자열의 색상, #AARRGGBB</li>
  <li>textSize: 문자열의 크기, dp, sp, px(크기의 단위)</li>
  <li>textStyle: 문자열의 스타일 속성, normal, bold, italic</li>
  <li>typeFace: 문자열의 폰트, normal, sans, serif, monospace</li>
  <li>maxLines: 텍스트뷰에서 표시하는 문자열의 최대 줄 수</li>
</ul>

<h2 id="버튼-button">버튼 (Button)</h2>
<ul>
  <li>사용자가 클릭하면 클릭에 대한 반응을 하는 위젯</li>
  <li>다양한 유형의 버튼 제공(체크 박스, 라디오 버튼 등)</li>
</ul>

<h2 id="에디트텍스트-edittext">에디트텍스트 (EditText)</h2>
<ul>
  <li>입력상자의 역할, 사용자에게 값을 입력받을 때 사용</li>
  <li>hint: 기본 안내글</li>
  <li>inputType: 입력되는 글자의 유형 정의</li>
</ul>

<h2 id="이미지뷰imageview와-이미지-버튼">이미지뷰(ImageView)와 이미지 버튼</h2>
<ul>
  <li>이미지를 화면에 표시할 때 사용</li>
  <li>두 위젯의 차이점은 버튼처럼 사용 유무</li>
  <li>@drawable/이미지 파일명
    <h3 id="속성-1">속성</h3>
  </li>
  <li>src: 원본 이미지</li>
  <li>maxWidth, maxHeight: 이미지가 표시되는 최대 폭, 높이. 설정하지 않을 시 원본 이미지가 그대로 표시</li>
  <li>tint: 이미지뷰에 보이는 이미지의 색상 설정</li>
  <li>scaleType: 이미지뷰의 크기에 맞게 원본 이미지의 크기를 자동으로 늘리거나 줄여서 보여줄 때 사용
    <h3 id="해상도-설정">해상도 설정</h3>
  </li>
  <li>초고해상도 /app/res/drawable-xhdpi</li>
  <li>고해상도 /app/res/drawable-hdpi</li>
  <li>중간 해상도 /app/res/drawble-mdpi</li>
  <li>저해상도 /app/res/drawable-ldpi</li>
  <li>/app/res/drawable에 이미지를 넣으면 일반적으로 사용되는 이미지로 인식함</li>
  <li>위 폴더를 직접 생성 후 넣으면 해상도에 맞게 자동 적용됨</li>
</ul>

<h2 id="드로어블">드로어블</h2>
<ul>
  <li>뷰에 설정할 수 있는 객체</li>
  <li>그 위에 그래픽을 그릴 수 있음</li>
  <li>비트맵 드로어블(BitmapDrawable), 상태 드로어블(StateListDrawable), 전환 드로어블(TransitionDrawable), 셰이프 드로어블(ShapeDrawable), 인셋 드로어블(InsetDrawable), 클립 드로어블(ClipDrawable), 스케일 드로어블(ScaleDrawable)</li>
</ul>

<h2 id="이벤트-처리">이벤트 처리</h2>
<ul>
  <li>위임 모델(Delegation Model): 화면에서 발생하는 이벤트를 버튼과 같은 위젯 객체에 전달한 후 그 이후의 처리 과정을 버튼에 위임</li>
  <li>위임 모델은 각각의 이벤트를 처리할 수 있는 리스너(Listner) 인터페이스를 등록할 수 있도록 함
    <h3 id="터치-이벤트">터치 이벤트</h3>
  </li>
  <li>화면을 손가락으로 누를 때 발생하는 이벤트
    <h3 id="키-이벤트">키 이벤트</h3>
  </li>
  <li>키패드나 하드웨어 버튼을 누를 때 발생하는 이벤트
    <h3 id="제스처-이벤트">제스처 이벤트</h3>
  </li>
  <li>터치 이벤트 중에서 스크롤과 같이 일정 패턴으로 구분되는 이벤트
    <h3 id="포커스">포커스</h3>
  </li>
  <li>뷰마다 순서대로 주어지는 포커스
    <h3 id="화면-방향-변경">화면 방향 변경</h3>
  </li>
  <li>화면의 방향이 가로와 세로로 바뀜에 따라 발생하는 이벤트</li>
  <li>단말 방향이 바뀌었을 때 세로 방향과 가로 XML 레이아웃을 따로 만들 필요가 있음</li>
  <li>/res/에 layout-land 리소스 폴더를 추가. 이 이름으로 된 폴더는 앱을 실행했을 때 단말에 의해 자동으로 확인된 후 단말을 가로 방향으로 돌리면 이 폴더 안에 들어있는 레이아웃 파일을 우선적으로 적용</li>
</ul>

<h2 id="토스트-toast">토스트 (Toast)</h2>
<ul>
  <li>간단한 메시지를 잠깐 보여주었다가 없어지는 뷰</li>
  <li>앱 위에 떠있는 뷰</li>
  <li>앱이 화면에서 사라지더라도 필요한 메시지가 그대로 표시되므로 앱의 상태와 관계없이 보여줄 수 있다는 장점이 존재</li>
</ul>

<h2 id="스낵바-snackbar">스낵바 (Snackbar)</h2>
<ul>
  <li>외부 라이브러리로 추가되었기 때문에 dependency에 Design 라이브러리를 추가해야함</li>
  <li>간단한 메시지를 보여줄 때 사용</li>
</ul>

<h2 id="대화상자-alertdialog">대화상자 (AlertDialog)</h2>
<ul>
  <li>사용자에게 확인을 받거나 선택하게 할 때 사용</li>
  <li>보통 알림 대화상자는 사용자의 입력을 받기보다는 일방적으로 메시지를 전달하는 역할을 하며, ‘예’, ‘아니오’와 같은 전형적인 응답을 처리</li>
</ul>

<h2 id="프로그레스바-progressbar">프로그레스바 (ProgressBar)</h2>
<ul>
  <li>어떤 일의 진행 상태를 표시하거나 작업이 진행 중임을 사용자에게 알려줌</li>
  <li>막대, 원 모양이 대표적</li>
</ul>

<hr />

<h1 id="3-화면-전환">3. 화면 전환</h1>
<h2 id="레이아웃-인플레이션">레이아웃 인플레이션</h2>
<ul>
  <li>실제 앱을 실행하면 XML 레이아웃의 내용이 메모리에 객체화되고, 객체화된 XML 레이아웃을 소스 파일에서 사용</li>
  <li>인플레이션 (Inflation): XMl 레이아웃의 내용이 메모리에 객체화되는 과정</li>
  <li>레이아웃 객체화 과정은 앱이 실행될 때(런타임) 레이아웃 XML 파일에 정의된 내용들이 메모리에 객체화되기 때문에 매우 중요</li>
  <li>setContentView() 메소드는 화면에 나타낼 뷰를 지정하거나 레이아웃 내용을 메모리에 객체화하는 두 가지 역할을 수행</li>
  <li>setContentView()는 화면 전체를 설정하는 역할만을 수행하기 때문에 부분 화면(부분 레이아웃)을 메모리에 객체화 할 수는 없음. 이를 위해서는 인플레이터를 사용해야함(LayoutInflater)</li>
</ul>

<h2 id="화면-간-전환">화면 간 전환</h2>
<ul>
  <li>startActivity(): 액티비티를 소스코드에서 띄울 때 사용</li>
  <li>startActivityForResult(): 띄웠던 액티비티로부터 다시 원래의 액티비티로 돌아오면서 응답을 받아 처리할 때 사용, setResult()로 응답을 보냄
    <h3 id="안드로이드-앱을-구성하는-네-가지-구성-요소">안드로이드 앱을 구성하는 네 가지 구성 요소</h3>
  </li>
  <li>액티비티(Activity), 서비스(Service), 브로드캐스트 수신자(Broadcast Receiver), 내용 제공자(Content Provider)</li>
  <li>위 네 가지 요소들은 앱을 만들어 단말에 설치했을 때 안드로이드 시스템이 이 요소에 대한 정보를 요구하기 때문에 중요</li>
  <li>Android-Manifest.xml 파일에 그 정보들을 담고 있음. 새 액티비티에 대한 <activity> 태그를 매니페스트에 추가하지 않으면 새 액티비티를 화면에 보여줄 수 없음</activity></li>
</ul>

<h2 id="인텐트">인텐트</h2>
<ul>
  <li>다른 액티비티를 띄우거나 기능을 동작시키기 위한 수단으로 사용</li>
  <li>무언가 작업을 수행하기 위해 사용되는 일종의 명령 또는 데이터를 전달하는 데 사용</li>
  <li>액션(Action, 수행할 기능)과 데이터(data, 액션이 수행될 대상의 데이터)로 구성
    <h3 id="명시적-인텐트-explicit-intent">명시적 인텐트 (Explicit Intent)</h3>
  </li>
  <li>인텐트에 클래스 객체나 컴포넌트 이름을 지정하여 호출할 대상을 확실히 알 수 있는 경우
    <h3 id="암시적-인텐트-implicit-intent">암시적 인텐트 (Implicit Intent)</h3>
  </li>
  <li>액션과 데이터를 지정하긴 했지만 호출할 대상이 달라질 수 있는 경우</li>
  <li>액션과 데이터 이외에도 여러가지 속성을 가지고 있음</li>
  <li>범주 (Category): 액션이 실행되는 데 필요한 추가적인 정보를 제공</li>
  <li>타입 (Type): 인텐트에 들어가는 데이터의 MIME 타입을 명시적으로 지정</li>
  <li>컴포넌트 (Component): 인텐트에 사용될 컴포넌트 클래스 이름으 명시적으로 지정</li>
  <li>부가 데이터 (Extra Data)</li>
</ul>

<h2 id="플래그">플래그</h2>
<ul>
  <li>액티비티를 여러 번 호출하면 동일한 액티비티가 메모리에 여러 개 만들어지게 되는데, 이 중복된 액티비티를 띄우지 않도록 조정하는 역할
    <h3 id="액티비티-스택-activity-stack">액티비티 스택 (Activity Stack)</h3>
  </li>
  <li>액티비티는 액티비티 매니저(Activity Manager)라는 객체에 의해 액티비티 스택으로 관리됨</li>
  <li>이 스택은 액티비티를 쌓아두었다가 가장 상위에 있던 액티비티가 없어지면 이전 액티비티가 다시 화면에 보이게 함</li>
  <li>만약 동일한 액티비티가 여러 개 스택에 들어가서 동시에 데이터를 접근하거나 리소스를 사용하는 문제가 발생 가능
    <h3 id="flag_activity_single_top">FLAG_ACTIVITY_SINGLE_TOP</h3>
  </li>
  <li>액티비티를 생성할 때 이미 생성된 액티비티가 있으면 그 액티비티를 그대로 사용</li>
  <li>기존에 만든 동일한 액티비티를 사용</li>
  <li>이미 만들어져있는 액티비티를 다시 띄울 때는 onCreate() 메소드가 실행되지 않으므로 onNewIntent() 메소드를 재정의하여 인텐트를 처리
    <h3 id="flag_activity_no_history">FLAG_ACTIVITY_NO_HISTORY</h3>
  </li>
  <li>처음 이후에 실행된 액티비티는 액티비티 스택에 추가되지 않음</li>
  <li>해당 플래그를 가진 액티비티가 다른 액티비티를 호출하고, 호출된 액티비티가 끝난 후에는 다시 플래그 가진 액티비티를 실행하지 않음
    <h3 id="flag_activity_clear_top">FLAG_ACTIVITY_CLEAR_TOP</h3>
  </li>
  <li>이 액티비티 위에 있는 다른 액티비티를 모두 종료시키게 됨</li>
  <li>홈 화면과 같이 다른 액티비티보다 항상 우선하는 액티비티를 만들 때 사용
    <h2 id="부가-데이터-extra-data">부가 데이터 (Extra data)</h2>
  </li>
  <li>데이터를 전달할 때에는 Intent안의 번들(Bundle, 해시테이블과 유사) 객체에 데이터를 넣고(putExtra()) 빼서(get~Extra()) 사용</li>
  <li>번들 안에 부가 데이터를 넣을 때는 키(Key)와 값(Value)을 쌍으로 만들어 넣음</li>
  <li>전달하고 싶은 데이터가 기본 자료형이 아니라 객체(Obejct) 자료형일 때는 객체 자체를 전달할 수 없기 때문에 바이트 배열로 변환하거나 Serializable 인터페이스(안드로이드는 Parcelable을 권장)를 구현하는 객체를 만들어 직렬화한 다음 전달</li>
</ul>

<h2 id="태스크-task">태스크 (Task)</h2>
<ul>
  <li>다른 앱과 흐름 관리</li>
  <li>태스크를 이용하면 프로세스처럼 독립적인 실행 단위와 상관없이 어떤 화면들이 같이 동작해야 하는지 흐름을 관리할 수 있음</li>
</ul>

<h2 id="sharedpreferences">SharedPreferences</h2>
<ul>
  <li>데이터를 간단하게 저장하고 싶을 때 사용</li>
</ul>

<h2 id="액티비티-수명주기-life-cycle">액티비티 수명주기 (Life Cycle)</h2>
<ul>
  <li>액티비티는 여러 과정의 상태 정보를 갖고 있으며, 이런 상태 정보는 시스템이 관리하면서 각각의 상태에 해당하는 메소드를 자동으로 호출</li>
  <li>[새로운 액티비티] -(onCreate(), onStart(), onResume())-&gt; [실행] -(onPuase())-&gt; &lt;-(onResume())- [일시 정지] -(onStop()) -&gt; [중지] -(onDestroy()) -&gt; [소멸]</li>
  <li>[중지] -(onRestart(), onStart(), onResume()) -&gt; [실행]</li>
  <li>onCreate-&gt;onStart-&gt;onResume-&gt;onPause-&gt;onStop-&gt;onDestroy
    <h3 id="oncreate">onCreate()</h3>
  </li>
  <li>액티비티가 처음 만들어졌을 때 호출</li>
  <li>화면에 보이는 뷰들의 일반적인 상태를 설정하는 부분</li>
  <li>이전 상태가 저장되어 있는 경우에는 번들 객체를 참조하여 이전 상태 복원 가능</li>
  <li>이 메소드 다음에는 항상 onStart()가 호출됨
    <h3 id="onstart">onStart()</h3>
  </li>
  <li>액티비티가 화면에 보이기 바로 전에 호출됨</li>
  <li>액티비티가 화면 상에 보이면 이 메소드 다음에 onResume() 메소드가 호출됨</li>
  <li>액티비티가 화면에서 가려지게 되면 이 메소드 다음에 onStop() 메소드가 호출됨
    <h3 id="onresume">onResume()</h3>
  </li>
  <li>액티비티가 사용자와 상호작용하기 바로 전에 호출됨
    <h3 id="onrestart">onRestart()</h3>
  </li>
  <li>액티비티가 중지된 이후에 호출되는 메소드</li>
  <li>다시 시작되기 바로 전에 호출됨</li>
  <li>이 메소드 다음에는 항상 onStart() 메소드가 호출됨
    <h3 id="onpause">onPause()</h3>
  </li>
  <li>또 다른 액티비티를 시작하려고 할 때 호출됨</li>
  <li>저장되지 않은 데이터를 저장소에 저장하거나 애니메이션 중인 작업을 중지하는 등의 기능을 수행</li>
  <li>이 메소드가 리턴되기 전에는 다음 액티비티가 시작될 수 없으므로 이 작업은 매우 빨리 수행된 후 리턴되어야 함</li>
  <li>액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료할 수 있음
    <h3 id="onstop">onStop()</h3>
  </li>
  <li>액티비티가 사용자에게 더 이상 보이지 않을 때 호출됨</li>
  <li>액티비티가 소멸되거나 또 다른 액티비티가 화면을 가릴 때 호출됨</li>
  <li>액티비티가 이 상태에 들어가면 시스템은 액티비티를 강제 종료할 수 있음
    <h3 id="ondestroy">onDestroy()</h3>
  </li>
  <li>액티비티가 소멸되어 없어지기 전에 호출됨</li>
  <li>액티비티가 받는 마지막 호출</li>
  <li>액티비티가 앱에 의해 종료되거나(finish()), 시스템이 강제로 종료시키는 경우에 호출될 수 있음</li>
  <li>액티비티가 이 상테에 들어가면 시스템은 액티비티를 강제 종료할 수 있음</li>
</ul>

<p><br /><br /></p>
<ul>
  <li>onSaveInstanceState() 메소드의 파라미터로 전달되는 번들 객체를 이용해 데이터를 저장하면 onCreate()나 onRestoreInstanceState() 메소드로 저장했던 데이터가 전달됨</li>
  <li>이 방식을 사용하면 앱이 강제 종료되거나 비정상 종료된 이후에 앱이 재실행되었을 때도 그 상태 그대로 보일 수 있도록 만들어줌</li>
</ul>

<hr />

<h1 id="4-프래그먼트">4. 프래그먼트</h1>
<h2 id="프래그먼트-fragment">프래그먼트 (Fragment)</h2>
<ul>
  <li>하나의 화면을 여러 부분으로 나눠서 보여주거나 각각의 부분 화면 단위로 바꿔서 보여주고 싶을 때 사용</li>
  <li>화면의 일부분을 다른 화면으로 구성하고 싶을 때 사용</li>
  <li>분할된 화면들의 상태를 관리하는 것이 목적</li>
  <li>부분 화면</li>
  <li>액티비티가 독립적으로 동작하는 방식을 본떠 만듬</li>
  <li>분할된 화면들을 독립적으로 구성하기 위해 사용</li>
  <li>분할된 화면들의 상태를 관리하기 위해 사용</li>
  <li>항상 액티비티 위에 올라가 있어야 함</li>
  <li>프래그먼트가 제대로 동작하는 시점은 프래그먼트가 메모리에 만들어진 시점이 아니라 액티비티에 올라가는 시점</li>
  <li>프래그먼트와 액티비티가 연결되어야 초기화될 수 있음</li>
  <li>프래그먼트 객체가 new 연산자로 만들어졌더라도 액티비티 위에 올라가지 전까지는 프래그먼트로 동작하지 않음</li>
  <li>액티비티의 onCreate()에서 getSupportFragmentManger().beginTransaction().add(fragment).commit()으로 액티비티에 추가된 후 프래그먼트 동작을 시켜야 함</li>
  <li>뷰 특성: 뷰그룹에 추가되거나 레이아웃의 일부가 될 수 있음. 뷰에서 상속받은 것은 아니며 뷰를 담고 있는 일종의 틀</li>
  <li>액티비티 특성: 액티비티처럼 수명주기(Lifecycle)를 가지고 있음. 건텍스트 객체는 아니며 라이프사이클은 액티비티에 종속됨
    <h3 id="onattachactivity">onAttach(Activity)</h3>
  </li>
  <li>프래그먼트가 액티비티와 연결될 때 호출</li>
  <li>먼저 onAttach()가 호출되어 액티비티에 프래그먼트가 추기되고 그 다음에 onCreate()가 호출</li>
  <li>액티비티를 위해 설정해야 하는 정보들을 처리해야 함
    <h3 id="oncreatebundle">onCreate(Bundle)</h3>
  </li>
  <li>프래그먼트가 초기화될 때 호출</li>
  <li>new 연산자를 이용해 새로운 프래그먼트 객체를 만드는 시점이 아님에 주의
    <h3 id="oncreateviewlayoutinflator-viewgroup-bundle">onCreateView(LayoutInflator, ViewGroup, Bundle)</h3>
  </li>
  <li>프래그먼트와 관련되는 뷰 계층을 만들어서 리턴
    <h3 id="onactivitycreatedbundle">onActivityCreated(Bundle)</h3>
  </li>
  <li>프래그먼트와 연결된 액티비티가 onCreate() 메소드의 작업을 완료했을 때 호출
    <h3 id="onstart-1">onStart()</h3>
  </li>
  <li>프래그먼트와 연결된 액티비티가 onStart()되어 사용자에게 프래그먼트가 보일 때 호출
    <h3 id="onresume-1">onResume()</h3>
  </li>
  <li>프래그먼트와 연결된 액티비티가 onResume()되어 사용자와 상호작용할 수 있을 때 호출
    <h3 id="onpause-1">onPause()</h3>
  </li>
  <li>프래그먼트와 연결된 액티비티가 onPause()되어 사용자와 상호작용을 중지할 때 호출
    <h3 id="onstop-1">onStop()</h3>
  </li>
  <li>프래그먼트와 연결된 액티비티가 onStop()되어 화면에서 더 이상 보이지 않을 때나 프래그먼트의 기능이 중지되었을 때 호출
    <h3 id="ondestroyview">onDestroyView()</h3>
  </li>
  <li>프래그먼트와 관련된 뷰 리소스를 해제할 수 있도록 호출됨
    <h3 id="ondestroy-1">onDestroy()</h3>
  </li>
  <li>프래그먼트의 상태를 마지막으로 정리할 수 있도록 호출됨
    <h3 id="ondetach">onDetach()</h3>
  </li>
  <li>프래그먼트가 액티비티와 연결을 끊기 바로 전에 호출됨</li>
</ul>

<h2 id="액션바-actionbar">액션바 (ActionBar)</h2>
<ul>
  <li>상단의 메뉴바</li>
  <li>기본적으로 제목을 보여주는 타이틀의 기능</li>
  <li>showAsAction 속성으로 메뉴를 보이게 할 것인지 지정
    <h3 id="옵션-메뉴-option-menu">옵션 메뉴 (Option Menu)</h3>
  </li>
  <li>시스템 메뉴 버튼을 눌렀을 때 나타나는 메뉴</li>
  <li>각 화면마다 설정할 수 있는 주요 메뉴
    <h3 id="컨텍스트-메뉴-context-menu">컨텍스트 메뉴 (Context Menu)</h3>
  </li>
  <li>화면을 길게 누르면 나타나는 메뉴</li>
  <li>텍스트뷰의 편집상태를 바꾸거나 할 때 사용</li>
  <li>각각의 뷰 마다 설정할 수 있음</li>
</ul>

<h2 id="상단-탭과-하단-탭">상단 탭과 하단 탭</h2>
<h3 id="탭-tab-내비게이션-위젯">탭 (Tab, 내비게이션 위젯)</h3>
<ul>
  <li>하나의 뷰에서 여러 개의 정보를 볼 때 일반적으로 사용하는 뷰</li>
  <li>상단 탭과 하단 탭으로 구분
    <h3 id="상단-탭-top-navigation">상단 탭 (Top Navigation)</h3>
  </li>
  <li>액션바에 탭 기능을 넣어 보여주는 방법으로 제공
    <h3 id="하단-탭-bottom-navigation">하단 탭 (Bottom Navigation)</h3>
  </li>
  <li>BottomNavigationView 위젯으로 사용</li>
</ul>

<h2 id="뷰페이저-viewpager">뷰페이저 (ViewPager)</h2>
<ul>
  <li>손가락으로 좌우 스크롤하여 넘겨볼 수 있는 기능을 제공</li>
  <li>FragmentStatePagerAdapter를 상속</li>
  <li>Fragment형 ArrayList에 프래그먼트를 넣은 후, ViewPager에 setAdapter(adapter)하면 어댑터 객체가 설정되고 이때부터 뷰페이저는 어댑터에 있는 프래그먼트들을 화면에 보여줄 수 있게 됨
    <h3 id="어댑터-adapter">어댑터 (Adapter)</h3>
  </li>
  <li>뷰페이저에 보여줄 각 프래그먼트를 관리하는 역할</li>
  <li>뷰페이저에 설정하면 서로 상호작용하면서 화면에 표시해주게 됨
    <h3 id="타이틀스트립-titlestrip">타이틀스트립 (TitleStrip)</h3>
  </li>
  <li>위나 아래쪽에 전체 프래그먼트들 중 몇 번째인지 알려주는 역할</li>
</ul>

<h2 id="바로가기-메뉴-navigationdrawer">바로가기 메뉴 (NavigationDrawer)</h2>
<ul>
  <li>화면의 좌측 상단에 위치한 햄버거 모양 아이콘을 눌렀을 때 나타나는 화면</li>
  <li>빠르게 메뉴 기능에 접근하고자 할 때 사용</li>
</ul>

<hr />

<h1 id="5-서비스와-수신자">5. 서비스와 수신자</h1>
<h2 id="서비스-service">서비스 (Service)</h2>
<ul>
  <li>오래 실행되는 작업을 위한 것</li>
  <li>백그라운드에서 실행되는 앱의 구성 요소</li>
  <li>매니페스트 파일에 등록 필요</li>
  <li>메인 액티비티에서 startService()로 서비스를 실행, 인텐트 객체를 파라미터로 전달
    <h3 id="onstartcommand">onStartCommand()</h3>
  </li>
  <li>인텐트 객체가 null인 경우 Service.START_STICKY를 반환. 이 값은 서비스가 비정상 종료되었다는 의미이므로 시스템이 자동으로 재시작됨
    <h3 id="onbind">onBind()</h3>
  </li>
  <li>서비스가 서버 역할을 하면서 액티비티와 연결될 수 있도록 만드는 것
    <h3 id="인텐트-서비스-intentservice">인텐트 서비스 (IntentService)</h3>
  </li>
  <li>서비스처럼 백그라운드에서 실행되는 것은 같지만 길게 지속되는 서비스라기보다는 한 번 실행되고 끝나는 작업을 수행할 때 사용</li>
  <li>필요한 함수가 수행되고 나면 종료됨</li>
</ul>

<h2 id="브로드캐스트-수신자-broadcast-receiver">브로드캐스트 수신자 (Broadcast Receiver)</h2>
<ul>
  <li>앱 간에 또는 구성 요소 간에 메시지를 주고받을 수 있도록 한 것</li>
  <li>기기 안에서 동작하는 다른 앱 A로부터 특정 메시지를 받기 위해 내가 만든 앱에 브로드캐스트 수신자를 등록하면 A의 메시지가 이곳으로 전달됨</li>
  <li>새 브로드캐스트 수신자를 만들면 매니페스트 파일에 등록해야하지만, 소스코드에서 registerReceiver()로 등록할 수도 있음</li>
  <li>브로드캐스트 수신자를 포함하고 있는 앱의 메인 액티비티가 적어도 한 번 실행되어야 브로드캐스트 수신자가 메시지를 받을 수 있음
    <h3 id="onreceive">onReceive()</h3>
  </li>
  <li>원하는 브로드캐스트 메시지가 도착하면 자동으로 호출됨</li>
  <li>파라미터로 전달되는 Intent 객체안에 해당 데이터가 들어있음</li>
</ul>

<h2 id="위험-권한-dangerous-permission">위험 권한 (Dangerous Permission)</h2>
<ul>
  <li>대부분 개인정보가 담겨있는 정보에 접근하거나 개인정보를 만들어낼 수 있는 단말의 주요 장치에 접근할 때 부여</li>
  <li>위치, 카메라, 마이크, 연락처, 전화, 문자, 일정, 센서</li>
  <li>AndroidManifest.xml에 <uses-permission> 태그로 권한을 추가</uses-permission></li>
  <li>cf. 일반 권한 (Normal Permission)</li>
</ul>

<h2 id="리소스">리소스</h2>
<ul>
  <li>자바 코드와 분리하여 이해하기 쉽고 유지관리가 용이하게 만듬</li>
  <li>리소스는 빌드되어 설치파일에 추가되지만 애셋(Asset, 둘 다 모두 리소스라고 할 수 있으나 동영상이나 웹페이지와 같이 용량이 큰 데이터를 의미)은 빌드되지 않음</li>
  <li>리소스가 갱신되면 그때마다 리소스의 정보가 R.java 파일에 자동으로 기록되며 그 정보는 리소스에 대한 내부적인 포인터 정보가 됨</li>
  <li>리소스 유형마다 다른 파일에 넣어야 함</li>
  <li>/app/res/values: 문자열이나 기본 데이터 타입에 해당하는 정보들이 저장</li>
  <li>/app/res/drawable: 이미지를 저장, 단말의 해상도에 따라 다른 이미지를 보여줄 수 있도록 폴더를 나누어 저장할 수 있음</li>
</ul>

<h2 id="매니페스트">매니페스트</h2>
<ul>
  <li>설치된 앱의 구성 요소가 어떤 것인지, 그리고 어떤 권한이 부여되었는지 시스템에 알려주는 역할</li>
  <li>모든 안드로이드 앱은 가장 상위 폴더에 매니페스트 파일이 있어야 함</li>
  <li>앱이 실행되기 전에 시스템이 알아야 할 내용들을 정의하고 있음</li>
  <li>앱의 패키지 이름 지정</li>
  <li>앱 구성 요소에 대한 정보 등록(액티비티, 서비스, 브로드캐스트 수신자, 내용 제공자)</li>
  <li>각 구성 요소를 구현하는 클래스 이름 지정</li>
  <li>앱이 가져야 하는 권한에 대한 정보 등록</li>
  <li>다른 앱이 접근하기 위해 필요한 권한에대한 정보 등록</li>
  <li>앱 개발 과정에서 프로파일링을 위해 필요한 instrumentation 클래스 등록</li>
  <li>앱에 필요한 안드로이드 API의 레벨 정보 등록</li>
  <li>앱에서 사용하는 라이브러리 리스트</li>
</ul>

<h2 id="그래들-gradle">그래들 (Gradle)</h2>
<ul>
  <li>안드로이드 스튜디오에서 사용하는 빌드 및 배포 도구</li>
  <li>한 앱의 빌드 섲렁은 build.gradle 파일에 넣어 관리</li>
  <li>그래들 파일은 프로젝트 수준과 모듈 수준으로 나눠 관리
    <h3 id="프로젝트-수준-buildgradle">프로젝트 수준 build.gradle</h3>
  </li>
  <li>프로젝트 안에 들어있는 모든 모듈에 적용되는 설정을 담고 있음</li>
  <li>이 파일을 수정하는 경우는 거의 없음</li>
  <li>가끔 외부 도구를 포함시키기 위해 buildscript의 dependencies안에 classpath를 추가하는 정도의 수정
    <h3 id="모듈-수준-buildgradle">모듈 수준 build.gradle</h3>
  </li>
  <li>각각의 모듈에 대한 설정을 담고 있음</li>
  <li>app 모듈의 설정 정보를 담고 있음</li>
  <li>새로운 모듈을 추가한다면 그 모듈에 대한 build.gradle 파일도 새로 추가해야 함</li>
</ul>

<hr />

<h1 id="6-선택-위젯">6. 선택 위젯</h1>
<h2 id="나인패치-nine-patch">나인패치 (Nine Patch)</h2>
<ul>
  <li>이미지가 늘어나거나 줄어들 때 생기는 이미지 왜곡을 해결</li>
  <li>나인패치 이미지로 만든 파일 이름은 filename.9.png 처럼 파일 확장자 앞에 .9를 붙여야 함</li>
  <li>안드로이드에서는 이 방식의 파일을 원본 이미지의 가로, 세로 끝부분의 픽셀을 모두 나인패치 이미지의 정보를 담은 것으로 인식</li>
  <li>가운데 부분만 늘어나므로 이미지의 크기가 커지더라도 모서리 부분은 원래 이미지 모양을 유지할 수 있음</li>
</ul>

<h2 id="카드뷰-cardview">카드뷰 (CardView)</h2>
<ul>
  <li>프로필과 같은 간단 정보를 넣기 위해 각 영역을 구분하는 역할</li>
</ul>

<h2 id="리싸이클러뷰-recyclerview">리싸이클러뷰 (RecyclerView)</h2>
<ul>
  <li>리스트 모양으로 보여줄 수 있는 위젯</li>
  <li>기본적으로 상하 스크롤이지만 좌우도 가능</li>
  <li>각각의 아이템이 화면에 보일 때 메모리를 효율적으로 사용하도록 캐시(Cache) 메커니즘이 구현되어 있음</li>
  <li>리스트뷰보다는 리싸이클러뷰를 권장</li>
  <li>선택 위젯이기 때문에 어댑터가 데이터 관리와 뷰 객체 관리를 담당</li>
  <li>리싸이클러뷰에 보이는 여러 개의 아이템은 내부에서 캐시되기 때문에 아이템 개수만큼 객체로 만들어지지는 않음</li>
  <li>메모리를 효율적으로 사용하려면 뷰홀더에 뷰 객체를 넣어두고 사용자가 스크롤하여 보이지 않게 된 뷰 객체를 새로 보일 쪽에 재사용하는 것이 효율적이기 때문에 이 과정에서 뷰홀더가 재사용됨</li>
  <li>레이아웃 매니저로 리싸이클러뷰가 보일 기본적인 형태를 설정(세로, 가로, 격자 방향)
    <h3 id="oncreateviewholder">onCreateViewHolder()</h3>
  </li>
  <li>뷰홀더가 새로 만들어지는 시점에 호출</li>
  <li>뷰 타입을 위한 정수값이 파라미터로 전달됨
    <h3 id="onbindviewholder">onBindViewHolder()</h3>
  </li>
  <li>뷰홀더 객체가 만들어질 때와 재사용될 때 자동으로 호출</li>
  <li>재활용할 수 있는 뷰홀더 객체를 파라미터로 전달하기 때문에 그 뷰홀더에 현재 아이템에 맞는 데이터만 설정
    <h3 id="getitemcount">getItemCount()</h3>
  </li>
  <li>어댑터에서 관리하는 아이템의 개수를 반환</li>
  <li>리싸이클러뷰에서 어댑터가 관리하는 아이템의 개수를 알아야 할 때 사용</li>
</ul>

<h2 id="스피너-spinner-콤보박스">스피너 (Spinner, 콤보박스)</h2>
<ul>
  <li>여러 아이템 중에서 하나를 선택하는 위젯</li>
  <li>선택 위젯</li>
</ul>

<hr />

<h1 id="7-애니메이션과-다양한-위젯">7. 애니메이션과 다양한 위젯</h1>
<h2 id="애니메이션-animation">애니메이션 (Animation)</h2>
<ul>
  <li>애니메이션이 어떻게 동작할지 정의한 정보는 XML로 만든 후 자바 소스에서 애니메이션 객체로 로딩한 후 뷰 객체의 startAnimation() 메소드를 사용하여 애니메이션을 동작</li>
  <li>트윈 애니메이션 (Tweened Animation)으로 위치 이동, 회전, 스케일, 투명도, 속도 조절이 가능</li>
</ul>

<h2 id="페이지-슬라이딩">페이지 슬라이딩</h2>

<h2 id="시크바-seekbar">시크바 (SeekBar)</h2>
<ul>
  <li>상태 표시 위젯</li>
  <li>프로그레스바를 확장하여 만든 것, 프로그레스바의 속성을 갖고 있으면서 사용자가 값을 조정할 수 있게 함</li>
  <li>시크바의 일부분을 터치하면 터치한 부분으로 즉시 이동할 수 있는 방법을 제공, 가운데에 있는 핸들(Handle)을 드래그하여 좌우로 이동시킬 수 있음
    <h3 id="onstarttrackingtouch">onStartTrackingTouch()</h3>
    <h3 id="onstoptrackingtouch">onStopTrackingTouch()</h3>
    <h3 id="onprogresschanged">onProgressChanged()</h3>
  </li>
  <li>사용자에 의해 변경된 progress 값을 전달받을 수 있음</li>
</ul>

<h2 id="키패드-제어">키패드 제어</h2>
<ul>
  <li>키패드가 올라오지 않도록 하려면 매니페스트에 속성을 추가해야 함(android:windowSoftInputMode=”stateHidden”)
    <h3 id="showsoftinput">showSoftInput()</h3>
    <h3 id="hidesoftinputfromwindow">hideSoftInputFromWindow()</h3>
  </li>
</ul>

<hr />

<h1 id="8-스레드와-핸들러">8. 스레드와 핸들러</h1>
<h2 id="스레드-thread">스레드 (Thread)</h2>
<ul>
  <li>하나의 프로세스 안에서 동시에 수행되어야 하는 작업을 위해 사용</li>
  <li>동시 수행이 가능한 작업 단위</li>
  <li>멀티 스레드 방식은 같은 프로세스 안에 들어 있으면서 메모리 리소스를 공유하므로 효율적인 처리가 가능하지만, 데드락(Deadlock)을 조심해야 함</li>
  <li>new 연산자로 객체를 생성한 후 start() 메소드를 호출하면 시작할 수 있음</li>
  <li>생성자는 파라미터가 없는 경우와 Runnable 객체를 파라미터로 갖는 두 가지로 구분
    <h3 id="오랜-시간-작업을-수행할-때">오랜 시간 작업을 수행할 때</h3>
  </li>
  <li>서비스 사용: 백그라운드 작업은 서비스로 실행하고 사용자에게는 알림 서비스로 알려줌. 만약 메인 액티비티로 결과 값을 전달하고 이를 이용해서 다른 작업을 수행하고자 한다면 브로드캐스팅으로 결과 값을 전달할 수 있음</li>
  <li>스레드 사용: 스레드는 같은 프로세스 안에 있기 때문에 작업 수행의 결과를 바로 처리할 수 있음. 그러나 UI 객체는 직접 접근할 수 없으므로 핸들러(Handler) 객체를 사용</li>
</ul>

<h2 id="핸들러-handler">핸들러 (Handler)</h2>
<ul>
  <li>메시지 큐로 메인 스레드에서 처리할 메시지를 전달하는 역할을 담당</li>
  <li>핸들러를 이용하면 특정 메시지가 미래의 어떤 시점에 실행되도록 스케줄링할 수 있음
    <h3 id="메시지-큐-message-queue">메시지 큐 (Message Queue)</h3>
  </li>
  <li>앱을 실행할 때 프로세스가 만들어지면 그 안에 메인 스레드가 함께 생성되는데, 그 최상위에서 관리되는 앱 구성요소(액티비티, 브로드캐스트 수신자 등)와 윈도우를 관리</li>
  <li>순차적으로 코드를 수행할 수 있게 함
    <h3 id="메인-스레드에-접근하기-위해-핸들러를-사용할-때-필요한-세-가지-단계">메인 스레드에 접근하기 위해 핸들러를 사용할 때 필요한 세 가지 단계</h3>
  </li>
  <li>obtainMessage(): 새로 만든 스레드가 수행하려는 정보를 메인 스레드로 전달하기 위해 먼저 핸들러가 관리하는 메시지 큐에서 처리할 수 있는 메시지 객체 하나를 참조, 호출 결과로 메시지 객체를 반환</li>
  <li>sendMessage(): 이 메시지 객체에 필요한 정보를 넣은 후 메시지 큐에 넣음</li>
  <li>handleMessage(): 메시지 큐에 들어간 메시지는 순서대로 핸들러가 처리하게 되며, 이때 이 메소드에 정의된 기능이 수행됨. 이 코드가 수행되는 위치는 새로 만든 스레드가 아닌 메인 스레드가 됨</li>
</ul>

<h2 id="runnable">Runnable</h2>
<ul>
  <li>새로 만든 Runnable 객체를 핸들러의 post()로 전달해주면 이 객체에 정의된 run() 메소드 안의 코드들은 메인 스레드에서 실행</li>
</ul>

<h2 id="일정-시간-후에-실행">일정 시간 후에 실행</h2>
<ul>
  <li>Thread.sleep() 메소드 사용</li>
  <li>핸들러의 sendMessageAtTime(), sendMessageDelayed()</li>
</ul>

<h2 id="스레드로-메시지-전송">스레드로 메시지 전송</h2>
<ul>
  <li>메인 스레드에서 별도의 스레드로 메시지를 전달할 때 사용</li>
  <li>메인 스레드는 UI 객체들을 처리하기 위해 메시지 큐와 루퍼를 사용</li>
  <li>하지만 별도의 스레드를 새로 생성하면 루퍼가 없으므로 메인 스레드나 다른 스레드에서 메시지 전송 방식으로 스레드에 데이터를 전달한 후 순차적으로 작업을 수행하고 싶다면 루퍼를 만든 후 실행해야 함
    <h3 id="루퍼-looper">루퍼 (Looper)</h3>
  </li>
  <li>메시지 큐에 들어오는 메시지를 지속적으로 보면서 하나씩 처리</li>
</ul>

<h2 id="asynctask">AsyncTask</h2>
<ul>
  <li>AsyncTask 클래스를 상속하여 새로운 클래스를 만들면 그 안에 스레드를 위한 코드와 UI 접근 코드를 한꺼번에 넣을 수 있음</li>
  <li>스레드로 처리해야 하는 코드를 하나의 AsyncTask 클래스로 정의할 수 있는 장점
    <h3 id="doinbackground">doInBackground()</h3>
  </li>
  <li>새로 만든 스레드에서 백그라운드 작업을 수행</li>
  <li>execute() 메소드를 호출할 때 사용된 파라미터를 배열로 전달 받음
    <h3 id="onpreexecute">onPreExecute()</h3>
  </li>
  <li>백그라운드 작업을 수행하기 전에 호출됨</li>
  <li>메인 스레드에서 실행</li>
  <li>초기화 작업에 사용됨
    <h3 id="onprogressupdate">onProgressUpdate()</h3>
  </li>
  <li>백그라운드 작업의 진행 상태를 표시하기 위해 호출됨</li>
  <li>작업 수행 중간에 UI 객체에 접근하는 경우에 사용</li>
  <li>이 메소드가 호출되도록 하려면 백그라운드 작업 중간에 publishProgress() 메소드를 호출해야 함
    <h3 id="onpostexecute">onPostExecute()</h3>
  </li>
  <li>백그라운드 작업이 끝난 후 호출</li>
  <li>메인 스레드에서 실행</li>
  <li>메모리 리소스를 해제하는 등의 작업에 사용</li>
  <li>백그라운드 작업 결과는 Result 타입의 파라미터로 전달됨
    <h3 id="oncancelled">onCancelled()</h3>
  </li>
  <li>AsyncTask 객체의 cancel() 메소드를 호출 시 동작</li>
  <li>작업을 취소</li>
</ul>

<hr />

<h1 id="9-서버">9. 서버</h1>
<h2 id="네트워킹-networking">네트워킹 (Networking)</h2>
<ul>
  <li>인터넷에 연결되어 있는 원격지의 서버 또는 원격지의 단말과 통신해서 데이터를 주고받는 동작들을 포함</li>
  <li>인터넷에 연결되어 있는 여러 단말을 동시에 사용할 수 있어서 다양한 데이터 자원을 효율적으로 사용할 수 있기 때문에 중요
    <h3 id="2-tier-cs-clientserver">2-tier C/S (Client/Server)</h3>
  </li>
  <li>클라이언트와 서버가 일대일로 연결</li>
  <li>원격지의 서버를 연결하는 가장 단순, 많이 사용하는 방식</li>
  <li>대부분 클라이언트가 서버에 연결되어 데이터를 요청하고 응답받음</li>
  <li>HTTP 프로토콜(웹페이지를 볼때 사용), FTP 프로토콜(파일 전송), POP3 프로토콜(메일을 주고받음) 등의 연결 방식
    <h3 id="3-tier">3-tier</h3>
  </li>
  <li>클라이언트, 응용서버, 데이터 서버간의 연결 방식</li>
  <li>응용 서버와 데이터 서버로 서버를 구성하면 데이터베이스를 분리할 수 있어서 중간에 비즈니스 로직(Business Logic)을 처리하는 응용서버가 좀 더 다양한 역할을 할 수 있다는 장점이 생김
    <h3 id="p2p-모델-peer-to-peer">P2P 모델 (Peer-to-Peer)</h3>
  </li>
  <li>서버를 두지 않고 단말끼리 서버와 클라이언트 역할을 수행</li>
  <li>정보 검색이나 파일 송수신으로 정보를 공유하는 데 많이 사용</li>
</ul>

<h2 id="소켓-socket">소켓 (Socket)</h2>
<ul>
  <li>IP 주소로 목적지 호스트를 찾아내고 포트로 통신 접속점을 찾아냄</li>
  <li>TCP, UDP 방식이 존재
    <h3 id="http-프로토콜">HTTP 프로토콜</h3>
  </li>
  <li>소켓으로 웹서버에 연결한 후에 요청을 전송하고 응답을 받은 다음 연결을 끊음 (비연결성, Stateless)
    <h2 id="웹으로-요청">웹으로 요청</h2>
  </li>
  <li>HttpURLConnection 객체로 HTTP 클라이언트를 생성</li>
  <li>setRequestProperty()로 GET, POST 요청 방식을 설정할 수 있음</li>
</ul>

<h2 id="volley">Volley</h2>
<ul>
  <li>웹 요청과 응답을 단순화하기 위해 만들어진 라이브러리</li>
  <li>요청(Request) 객체를 만들고 이 요청 객체를 요청 큐(RequestQueue)에 넣어주면 요청 큐가 알아서 웹서버에 요청하고 응답까지 받아줌</li>
  <li>스레드, 핸들러를 사용하지 않음</li>
  <li>요청 큐가 내부에서 스레드를 만들어 웹서버에 요청하고 응답받는 과정을 진행</li>
  <li>요청 큐는 한 번만 만들어 계속 사용할 수 있기 때문에 static 키워드를 붙이며, 특정 액티비티에서만 사용하는 것이 아니라 앱 전체에서 사용하는 것이 일반적</li>
  <li>외부 라이브러리</li>
</ul>

<h2 id="json-javascript-object-notation">JSON (JavaScript Object Notation)</h2>
<ul>
  <li>자바스크립트 객체 포맷을 데이터로 주고받을 때 사용할 수 있도록 문자열을 표현한 것
    <h3 id="gson">GSON</h3>
  </li>
  <li>자바스크립트에서처럼 JSON 문자열을 객체로 변환할 수 있도록 해줌</li>
  <li>JSON 문자열을 자바 객체로 바꾼 후 그 객체 안에 들어있는 데이터를 접근하여 사용</li>
  <li>외부 라이브러리</li>
</ul>

<hr />

<h1 id="10-데이터베이스와-내용-제공자">10. 데이터베이스와 내용 제공자</h1>
<h2 id="sqlite">SQLite</h2>
<ul>
  <li>안드로이드의 임베디드 데이터베이스로 개발된 경량급(Light-weight) 관계형 데이터베이스</li>
  <li>파일로 만들어진 하위 수준의 구조</li>
  <li>데이터 조회 속도가 빠르고 표준 SQL을 지원</li>
</ul>

<h2 id="데이터베이스와-테이블">데이터베이스와 테이블</h2>
<h3 id="openorcreatedatabase">openOrCreateDatabase()</h3>
<ul>
  <li>데이터베이스를 생성하거나 조회
    <h3 id="deletedatabase">deleteDatabase()</h3>
  </li>
  <li>데이터베이스 삭제
    <h3 id="execsql">execSQL()</h3>
  </li>
  <li>데이터베이스를 만들고 난 다음 SQL문을 실행할 때 사용</li>
</ul>

<h2 id="헬퍼helper-클래스로-업그레이드-지원">헬퍼(Helper) 클래스로 업그레이드 지원</h2>
<ul>
  <li>테이블의 정의가 바뀌어서 스키마를 업그레이드해야 할 때 API에서 제공하는 헬퍼 클래스를 사용</li>
  <li>SQLiteOpenHelper 클래스 사용</li>
</ul>

<h2 id="내용-제공자-content-provider">내용 제공자 (Content Provider)</h2>
<ul>
  <li>앱에서 관리하는 데이터를 다른 앱에서도 접근할 수 있도록 함</li>
  <li>앱 구성요소이기 때문에 매니페스트 파일에 등록해야 사용 가능</li>
  <li>데이터베이스, 파일, SharedPreferences를 공유할 수 있음</li>
  <li>CRUD 동작(Create, Read, Update, Delete)을 기준으로 함</li>
  <li>내용 제공자에서 허용한 통로로 접근하려면 콘텐트 리졸버(ContentResolver) 객체가 필요</li>
  <li>내용 제공자를 만들기 위해서는 고유한 값을 가진 content URI를 생성해야 함 (content://AUTHORITY/BASE_PATH)</li>
  <li>ContentResolver 객체로 내용 제공자에 접근</li>
  <li>내용 제공자를 이용해 값을 조회하고 싶다면 Cursor의 query()를 사용</li>
</ul>

<hr />

<h1 id="11-뷰에-그래픽-그리기">11. 뷰에 그래픽 그리기</h1>
<h2 id="뷰에-그래픽-그리기">뷰에 그래픽 그리기</h2>
<ul>
  <li>1단계: 뷰 상속</li>
  <li>2단계: 페인트 객체(Paint) 초기화</li>
  <li>3단계: onDraw() 메소드 구현</li>
  <li>4단계: onTouchEvent() 메소드 구현</li>
  <li>5단계: 메인 액티비티에 CustomView 클래스 추가
    <h3 id="그래픽-클래스">그래픽 클래스</h3>
  </li>
  <li>캔버스(Canvas): 뷰의 표면에 직접 그릴 수 있도록 만들어주는 객체</li>
  <li>페인트(Paint): 그래픽 그리기 위해 필요한 색상 등의 속성을 담고 있음</li>
  <li>비트맵(Bitmap): 픽셀로 구성된 이미지로 메모리에 그래픽을 그리는 데 사용</li>
  <li>드로어블 객체(Drawable): 사각형, 이미지 등의 그래픽 요소가 객체로 정의되어 있음</li>
</ul>

<h2 id="드로어블-객체로-만들어-그리기">드로어블 객체로 만들어 그리기</h2>
<ul>
  <li>리소스 파일의 사용: 프로젝트 리소스에 이미지와 같은 파일을 포함시킨 후 읽어 들여 사용</li>
  <li>XML로 정의하여 사용</li>
  <li>소스 코드에서 객체를 만들어 사용</li>
  <li>ShapeDrawable, BitmapDrawable, PictureDrawable, LayerDrawable 등</li>
</ul>

<h2 id="비트맵-이미지">비트맵 이미지</h2>
<ul>
  <li>비트맵(Bitmap) 객체: 메모리에 만들어지는 이미지</li>
  <li>더블 버퍼링(Double Buffering): 별도의 메모리 공간에 미리 그래픽을 그린 후 뷰가 다시 그려져야 할 필요가 있을 때 미리 그려놓은 비트맵을 화면에 표시하는 방법</li>
  <li>BitmapFactory 클래스: 비트맵 이미지를 만들기 위한 클래스 메소드를 제공
    <h3 id="decodefile">decodeFile()</h3>
  </li>
  <li>파일에서 읽기</li>
  <li>파일 패스를 지정하면 해당 위치의 이미지 파일을 읽어옴
    <h3 id="decoderesource">decodeResource()</h3>
  </li>
  <li>리소스에서 읽기
    <h3 id="decodebytearray">decodeByteArray()</h3>
  </li>
  <li>바이트 배열에서 읽기
    <h3 id="decodestream">decodeStream()</h3>
  </li>
  <li>스트림에서 읽기</li>
</ul>

<h2 id="페인트보드">페인트보드</h2>
<ul>
  <li>터치 이벤트를 처리하여 빈 화면 위에 손가락으로 그림을 기를 수 있는 형태</li>
</ul>

<h2 id="멀티터치multi-touch-이미지-뷰어">멀티터치(Multi-Touch) 이미지 뷰어</h2>
<ul>
  <li>여러 개의 손가락으로 터치</li>
</ul>

<h2 id="머티리얼-디자인-material-design">머티리얼 디자인 (Material Design)</h2>
<ul>
  <li>구글이 안드로이드에 적용한 디자인 트렌드</li>
</ul>

<hr />

<h1 id="12-멀티미디어">12. 멀티미디어</h1>
<h2 id="카메라">카메라</h2>
<ul>
  <li>FileProvider.getUriForFile() 메소드로 카메라 앱에서 공유하여 사용할 수 있는 파일 정보를 Uri 객체로 만듬</li>
</ul>

<h2 id="음악-파일">음악 파일</h2>
<h3 id="미디어플레이어mediaplayer-클래스">미디어플레이어(MediaPlayer) 클래스</h3>
<ul>
  <li>음악 파일과 같은 오디오 재생과 동영상 재생을 담당</li>
  <li>인터넷에 있는 파일, 프로젝트 파일, 단말 SD 카드의 파일 데이터 소스를 지정할 수 있음</li>
</ul>

<h2 id="동영상">동영상</h2>
<ul>
  <li>비디오뷰(VideoView) 위젯으로 XML에 태그 추가</li>
  <li>미디어콘트롤러(MediaController) 객체로 동영상의 재생 상태와 동영상을 제어</li>
  <li>동영상 재생을 위해서는 VideoView와 MediaPlayer를 사용할 수 있음</li>
  <li>더 세밀한 제어를 원한다면 MediaPlayer</li>
</ul>

<h2 id="오디오-녹음">오디오 녹음</h2>
<ul>
  <li>미디어리코더(MediaRecorder)로 오디오 녹음, 동영상 녹화를 진행</li>
  <li>미디어리코더 객체를 생성한 후 오디오 입력 및 출력 형식 설정, 오디오 인코더와 파일 지정하고 녹음 시작</li>
</ul>

<hr />

<h1 id="13-위치기반-서비스와-앱-위젯">13. 위치기반 서비스와 앱 위젯</h1>
<h2 id="gps">GPS</h2>
<ul>
  <li>안드로이드 기반의 스마트폰 위치는 위치 관리자(LocationManager) 시스템 서비스가 관리
    <h3 id="위치-관리자-객체-참조">위치 관리자 객체 참조</h3>
  </li>
  <li>위치 관리자(LocationManager)는 시스템 서비스로 제공되므로, getSystemService() 메소드를 이용해 위치 관리자 객체를 참조
    <h3 id="위치-리스너-구현">위치 리스너 구현</h3>
  </li>
  <li>위치 관리자가 알려주는 현재 위치는 위치 리스너(LocationListner)를 통해 받게 되므로 새로운 리스너를 구현하여 전달 받은 위치 정보를 처리
    <h3 id="위치-정보-업데이트-요청">위치 정보 업데이트 요청</h3>
  </li>
  <li>위치 관리자에게 위치 정보가 변경될 때마다 알려달라고 요청하기 위해 requestLocationUpdates() 메소드를 호출
    <h3 id="매니페스트에-권한-추가">매니페스트에 권한 추가</h3>
  </li>
  <li>ACCESS_FINE_LOCATION 권한 추가</li>
</ul>

<h2 id="앱-위젯-appwidget">앱 위젯 (AppWidget)</h2>
<ul>
  <li>홈 화면에서 위젯을 바로 보여주고 싶을 때 사용</li>
  <li>앱 위젯 호스트(App Widget Host, 위젯을 담고 있는 그릇), 앱 위젯 제공자(App Widget Provider, 위젯을 보여주는 제공자)</li>
  <li>AppWidgetProvider 클래스를 상속</li>
  <li>onUpdate() 재정의
    <h3 id="앱-위젯-구성할-때-필요한-요소">앱 위젯 구성할 때 필요한 요소</h3>
  </li>
  <li>위젯의 초기 뷰 레이아웃: 앱 위젯이 처음 화면에 나타날 때 필요한 레이아웃, XML로 정의</li>
  <li>앱 위젯 제공자 정보(App Widget Provider Info) 객체: 앱 위젯을 위한 메타데이터(레이아웃, 업데이트 주기 등)을 가짐. 앱 위젯 제공자 클래스에 대한 정보를 가지고 있음. XML로 정의</li>
  <li>앱 위젯 제공자(App Widget Provider): 앱 위젯과 정보를 주고받기 위한 기본 클래스. 브로드캐스트 수신자로 만들며 앱 위젯의 상태변화에 다른 기능을 구현</li>
</ul>

<hr />

<h1 id="14-푸시-서비스와-센서-및-단말-기능">14. 푸시 서비스와 센서 및 단말 기능</h1>
<h2 id="진동과-소리">진동과 소리</h2>
<ul>
  <li>Vibrator 시스템 서비스 객체의 vibrate() 메소드로 진동 패턴이나 시간을 지정</li>
  <li>Rintone 객체의 play() 메소드로 소리를 이용할 수 있음</li>
</ul>

<h2 id="상단-알림-notification">상단 알림 (Notification)</h2>
<ul>
  <li>NotificationManager 시스템 서비스를 이용해 화면 상단에 알림을 띄울 수 있음</li>
</ul>

<h2 id="푸시-서비스">푸시 서비스</h2>
<ul>
  <li>구글 클라우드 서버에서 구글 Play tmxhdjrk tjfclehls eksakfrlfh qhsownsms qkdtlr</li>
  <li>구글 서비스를 사용하지 않으면 폴링(Polling, 일정 시간 간격으로 서버와 연결이 끊어졌는지 검사) 메커니즘을 구현해야 하는데, 그 과정에서 단말의 하드웨어 리소스나 전원을 많이 소모하는 문제가 발생하므로 구글에서 제공하는 FCM(구글 푸시 서비스)를 사용하는 것이 효과적
    <h3 id="fcm-푸시-메시지-처리-과정">FCM 푸시 메시지 처리 과정</h3>
    <p>(1) 구글 클라우드 서버에 단말 등록
(2) 애플리케이션 서버에 등록 ID 전송
(3) 애플리케이션 서버로 메시지 전송 요청
(4) 애플리케이션 서버가 구글 클라우드 서버로 메시지 전송
(5) 구글 클라우드 서버가 대상 단말에게 메시지 수신</p>
  </li>
</ul>

<h2 id="센서">센서</h2>
<ul>
  <li>가속 센서(Accelerometer): 가속도 감지, 외부의 충격량과 방향 감지</li>
  <li>자이로스코프 센서(Gyroscope): 회전 정보 감지, 다양한 축을 따른 회전각 감지</li>
  <li>중력 센서(Gravity): 축의 방향과 중력 감지</li>
  <li>조도 센서(Light): 빛의 세기 감지</li>
  <li>선형 가속 센서(Linear Acceleration): 각 축에 따른 가속도를 감지하는 3차원 벡터</li>
  <li>근접 센서(Proximity): 근접한 물체와의 거리 감지, 단말에 따라 가깝거나 먼 정도만 표시할 수도 있음</li>
  <li>온도 센서(Temperature): 온도 감지</li>
  <li>방향 센서(Orientation): 방향각 감지</li>
</ul>

<h2 id="시스템-서비스-system-service">시스템 서비스 (System Service)</h2>
<ul>
  <li>단말이 켜졌을 때 자동으로 실행되어 백그라운드에서 동작
    <h3 id="activitymanager">ActivityManager</h3>
  </li>
  <li>액티비티나 서비스를 관리하는 시스템 서비스</li>
  <li>앱의 실행 상태를 알 수 있도록 함
    <h3 id="packagemanager">PackageManager</h3>
  </li>
  <li>앱의 설치에 대한 정보를 알 수 있도록 함
    <h3 id="alarmmanager">AlarmManager</h3>
  </li>
  <li>일정 시간에 알림을 받을 수 있도록 시스템에 등록해주는 역할</li>
</ul>

<h2 id="네트워크-기능">네트워크 기능</h2>
<ul>
  <li>ConnectivityManager로 단말의 인터넷 연결 상태를 파악</li>
</ul>

<h2 id="다중-창-multi-window">다중 창 (Multi Window)</h2>
<ul>
  <li>단말 화면에 여러 개의 액티비티가 보이도록 지원하는 기능</li>
</ul>

<hr />

<h3 id="참고">참고</h3>
<ul>
  <li>안드로이드 앱 프로그래밍 6판 (정재곤, 이지스퍼블리싱)</li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
