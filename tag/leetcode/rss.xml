<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 142. Linked List Cycle II</title>
	  <link>/blog//algo-leet142</link>
	  <author></author>
	  <pubDate>2020-10-15T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet142</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/submissions/">https://leetcode.com/problems/linked-list-cycle-ii/submissions/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>ListNode의 사이클 시작점부터를 반환한다.</li>
  <li>이때 공간 복잡도 O(1)을 만족하는 코드를 짠다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">detectCycle</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ListNode</span> <span class="n">fast</span><span class="o">=</span><span class="n">head</span><span class="o">,</span> <span class="n">slow</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">fast</span><span class="o">!=</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">fast</span><span class="o">=</span><span class="n">fast</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">fast</span><span class="o">==</span><span class="n">slow</span><span class="o">){</span> <span class="c1">// 사이클이 있다면</span>
                <span class="n">ListNode</span> <span class="n">slow2</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">slow</span><span class="o">!=</span><span class="n">slow2</span><span class="o">){</span>
                    <span class="n">slow</span><span class="o">=</span><span class="n">slow</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                    <span class="n">slow2</span><span class="o">=</span><span class="n">slow2</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">return</span> <span class="n">slow</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">}</span>        
        
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201015_1.PNG" alt="실행결과" />
🤟 성공 🤟 <br />
문제 제한조건을 못보고 HashSet을 이용하여 문제를 풀었었다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">리스트에 사이클이 있는지 확인한다</span></strong>
    <ul>
      <li>fast는 리스트를 두 칸씩 뛰는 포인터, slow는 한 칸씩 뛰는 포인터이다.</li>
      <li>fast가 리스트의 마지막까지 간다면 사이클이 없다는 뜻이다.</li>
      <li>fast==slow가 만나는 지점이 사이클 구간 중 한 군데이다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">사이클의 시작점을 찾는다</span></strong>
    <ul>
      <li>리스트 시작부터 사이클 시작점까지의 구간을 a, 사이클 내 fast와 slow가 만난 곳을 b(사이클 시작점~만난 곳), b를 제외한 사이클 나머지 구간을 c라고 하자.</li>
      <li>fast와 slow가 만나기 위해 fast는 a+b+c+b=a+2b+c를 이동한다.</li>
      <li>slow는 a+b</li>
      <li>fast==slow이므로 a+2b+c=a+b (1)</li>
      <li>fast는 slow보다 2배 빠르므로 a+b=2(a+b) (2)</li>
      <li>식 (1), (2)를 통해 a=c라는 결론을 얻을 수 있다.</li>
      <li>따라서 리스트 시작점(head)에서부터 움직이는 포인터 slow2와 fast와 slow가 만난 점에서부터 사이클 시작점으로 가는 slow가 만나는 점이 정답이다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 206. Reverse Linked List</title>
	  <link>/blog//algo-leet206</link>
	  <author></author>
	  <pubDate>2020-10-15T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet206</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/reverse-linked-list/">https://leetcode.com/problems/reverse-linked-list/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>리스트를 역순으로 만들어 리턴한다.</li>
  <li>반복문과 재귀를 이용한 두 경우를 구현한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">ListNode</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">reverseList</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">iter</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
        <span class="c1">// return recur(head);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">iter</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">){</span> <span class="c1">// 반복문</span>
        <span class="n">ListNode</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">null</span><span class="o">,</span> <span class="n">cur</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">cur</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">ListNode</span> <span class="n">rest</span><span class="o">=</span><span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">;</span> <span class="c1">// 임시 저장</span>
            <span class="n">cur</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">reverse</span><span class="o">;</span> <span class="c1">// 현재 cur은 만들어진 reverse를 가리킨다</span>
            <span class="n">reverse</span><span class="o">=</span><span class="n">cur</span><span class="o">;</span> <span class="c1">// reverse는 항상 맨 앞을 가리키도록</span>
            <span class="n">cur</span><span class="o">=</span><span class="n">rest</span><span class="o">;</span> <span class="c1">// 다음 노드 탐색</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">reverse</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">recur</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">){</span> <span class="c1">// 재귀</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// 빈 리스트이거나 마지막 노드라면</span>
        
        <span class="n">ListNode</span> <span class="n">reverse</span><span class="o">=</span><span class="n">recur</span><span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">);</span> <span class="c1">// 현재까지 생성한 리스트</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="n">head</span><span class="o">;</span> <span class="c1">// head의 다음노드는 나를 가리킨다</span>
        <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span> <span class="c1">// 원본 리스트에서 나 이후로는 연결 끊기(재귀로 연결되어있으므로 상관X)</span>
        <span class="k">return</span> <span class="n">reverse</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201015_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">Iterative</span></strong>
    <ul>
      <li>포인터 cur로 리스트를 순회하며, reverse에는 앞에 붙는 새 노드(cur)의 next가 지금까지 생성한 reverse를 가리키는 방식으로 구현한다.</li>
      <li>reverse는 항상 리스트의 앞을 가리켜야 하므로 reverse의 앞에 노드를 추가한 후 reverse=cur이 된다.</li>
      <li>cur의 다음 노드들이 있는 rest가 다시 cur이 된다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">Recursive</span></strong>
    <ul>
      <li>head는 현재 리스트에서의 위치이다.</li>
      <li>재귀 탈출 조건은 head가 마지막 노드(head.next==null)이다.</li>
      <li>원본 리스트 자체가 빈 값일 수 있으므로 head==null 조건을 추가하였다.</li>
      <li>역순이 되기 위해 내 뒤의 노드는 나를 가리켜야 한다(head.next.next=head)</li>
      <li>나는 역순 리스트에 포함되었으므로 원본 리스트에서 연결을 끊는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 160. Intersection of Two Linked Lists</title>
	  <link>/blog//algo-leet160</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet160</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">https://leetcode.com/problems/intersection-of-two-linked-lists/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>headA와 headB가 가리키는 같은 노드를 리턴(value가 같은 값이 아님)한다.</li>
  <li>headA의 노드들을 HashSet에 저장하고, headB를 순회하며 겹치는 노드부터의 리스트를 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">ListNode</span> <span class="nf">getIntersectionNode</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">headA</span><span class="o">,</span> <span class="n">ListNode</span> <span class="n">headB</span><span class="o">)</span> <span class="o">{</span> 
        <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">ListNode</span><span class="o">&gt;</span> <span class="n">set</span><span class="o">=</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">ListNode</span> <span class="n">p</span><span class="o">=</span><span class="n">headA</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span> <span class="c1">// headA의 노드들을 HashSet에 저장</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">p</span><span class="o">=</span><span class="n">headB</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span> <span class="c1">// headB 순회</span>
            <span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">p</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span> <span class="c1">// headA와 같은 노드(교차점)를 발견했다면</span>
            <span class="k">else</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_4.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">HashSet을 이용한다</span></strong>
    <ul>
      <li>headA의 노드들을 HashSet에 다 넣는다.</li>
      <li>headB를 순회하며 현재 가리키는 노드 p가 set에도 있다면 p가 교차점이 된다.</li>
      <li>참고로, 교차점은 val이 같은 노드가 아니라 주소까지 모조리 같은 것을 의미한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<p>문제 이해하는데 시간이 더 걸리는 듯</p>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 139. Word Break</title>
	  <link>/blog//algo-leet139</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet139</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/word-break/">https://leetcode.com/problems/word-break/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>dp[i]는 0부터 i-1번째 문자열까지가 wordDict 단어들로 만들 수 있는지 여부를 저장한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">wordBreak</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">wordDict</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> 
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> 
                <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">wordDict</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">j</span><span class="o">,</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
           
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp는 1부터 시작한다. dp[1]은 s의 첫 번째 문자가 wordDict에 있는지 여부를 저장한다.</li>
      <li>s.substring(j,i)가 wordDict에 있는지 확인한다. 이를 만족한다면 0~j까지의 값인 dp[j]도 true여야 dp[i]까지가 wordDict의 조건을 만족하는 것이므로 true를 넣는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 138. Copy List with Random Pointer</title>
	  <link>/blog//algo-leet138</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet138</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/copy-list-with-random-pointer/">https://leetcode.com/problems/copy-list-with-random-pointer/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>주어진 리스트 head를 깊은 복사하여 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">copyRandomList</span><span class="o">(</span><span class="n">Node</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">head</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
        
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">Node</span> <span class="n">p</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span> <span class="c1">// 새 노드 생성</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">val</span><span class="o">));</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">p</span><span class="o">=</span><span class="n">head</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">p</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span> <span class="c1">// 새 노드들에 next, random 연결</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="na">next</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="na">random</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">random</span><span class="o">);</span>
            <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">head</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">해시맵을 이용한다</span></strong>
    <ul>
      <li>Key는 기존 리스트의 노드, Value는 기존 노드를 복사한 새 노드가 된다.</li>
      <li>처음 while문을 통해 기존 노드와 val이 같은 새 노드를 만들어서 맵에 넣는다.</li>
      <li>두 번째 while문에서 새 노드(p를 key로 가지는 값의 value)의 next와 random을 연결한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<p>처음에는 맵의 형태를 &lt;Integer, Node&gt;로 하여 코드를 짰는데, 노드의 val은 중복 값이 존재하기 떄문에 해당 방법은 불가능하는 것을 알고 다른 풀이를 참고하였다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 169. Majority Element</title>
	  <link>/blog//algo-leet169</link>
	  <author></author>
	  <pubDate>2020-10-14T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet169</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/majority-element/">https://leetcode.com/problems/majority-element/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>HashMap으로 num의 개수를 센다.</li>
  <li>map을 순회하며 majority(n/2)보다 큰 value의 key를 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">majorityElement</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span> <span class="c1">// num의 개수 카운트</span>
            <span class="kt">int</span> <span class="n">value</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">value</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">majority</span><span class="o">=</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nl">entry:</span><span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()&gt;</span><span class="n">majority</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// majority 넘는 value의 key 리턴</span>
                <span class="n">answer</span><span class="o">=</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>            
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201014_5.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">HashMap을 이용한다</span></strong>
    <ul>
      <li>HashMap을 이용하여 nums의 num별 개수를 세서 저장한다.</li>
      <li>map.entrySet()을 순회하며 majority(n/2)보다 큰 value를 찾고, 해당 key를 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
	  <link>/blog//algo-leet105</link>
	  <author></author>
	  <pubDate>2020-10-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet105</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>inorder에서 preorder[i] 위치를 찾는다. 그 왼쪽은 모두 preorder의 left이고, 오른쪽은 right이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nf">solution</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">prestart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preend</span><span class="o">,</span> <span class="kt">int</span> <span class="n">instart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inend</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prestart</span><span class="o">&gt;</span><span class="n">preend</span> <span class="o">||</span> <span class="n">instart</span><span class="o">&gt;</span><span class="n">inend</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="n">TreeNode</span> <span class="n">node</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">prestart</span><span class="o">]);</span> <span class="c1">// 현재 생성할 노드</span>
        <span class="kt">int</span> <span class="n">inroot</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">prestart</span><span class="o">]);</span> <span class="c1">// inorder에서 pre[i]의 위치 찾기</span>
        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="n">inroot</span><span class="o">-</span><span class="n">instart</span><span class="o">;</span> <span class="c1">// node의 마지막 left 위치 찾기</span>
        
        <span class="c1">// left 생성</span>
        <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="n">solution</span><span class="o">(</span><span class="n">prestart</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">prestart</span><span class="o">+</span><span class="n">left</span><span class="o">,</span> <span class="n">instart</span><span class="o">,</span> <span class="n">inroot</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
        <span class="c1">// right</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="n">solution</span><span class="o">(</span><span class="n">prestart</span><span class="o">+</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">preend</span><span class="o">,</span> <span class="n">inroot</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">inend</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201005_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">preorder[i]가 inorder에서 몇 번째 인덱스인지 찾는다</span></strong>
    <ul>
      <li>반복문으로 인덱스를 찾는 것 보다 해시맵에 넣어서 찾는 것이 더 빠르다.</li>
      <li>preorder은 VLR, inorder은 LVR으로, preorder 순서대로 트리를 만들되, 어디까지가 left, right인지 확인하기 위해 inorder에서 Visit node의 위치를 찾는다.</li>
      <li>inorder[preorder[i]]의 왼쪽이 left node이고, 오른쪽이 right 노드이다.</li>
      <li>left 변수에 node의 마지막 left node 인덱스 번호를 저장한다.</li>
      <li>preorder 배열에서 prestart+1~prestart+left 인덱스까지가 node의 left node이다.</li>
      <li>node의 right node들은 prestart+left+1부터 preend까지이다. 이때 node의 left, right를 연결했으므로 다음 node를 찾기 위해 inorder의 범위도 갱신한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 114. Flatten Binary Tree to Linked List</title>
	  <link>/blog//algo-leet114</link>
	  <author></author>
	  <pubDate>2020-10-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet114</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>postorder을 이용하여 트리를 재구성한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">TreeNode</span> <span class="n">prev</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatten</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="n">prev</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="n">prev</span><span class="o">=</span><span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201005_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">postorder을 이용한다</span></strong>
    <ul>
      <li>후위순회는 RLV로 방문한다.</li>
      <li>문제의 예제에서 후위순회로 방문하면 [6,5,4,3,2,1]이므로 트리의 밑에서 위로 올라가며 오른쪽으로 flatten된 트리를 만들면 된다.</li>
      <li>재귀를 통해 오른쪽 끝까지 이동한 후, 마지막 노드 root의 right는 이전 prev, left는 null로 바꾼다.</li>
      <li>이제 root의 위로 올라가므로 prev를 root로 갱신한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 98. Validate Binary Search Tree</title>
	  <link>/blog//algo-leet98</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet98</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>중위순회로 탐색하며 뒤에 나보다 작은 값이 나오면 false이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="c1">// 뒤에 나보다 같거나 더 큰 값이 있으면</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)&gt;=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">){</span> <span class="c1">// 중위순회</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_1.PNG" alt="실행결과" />
🤟 성공 🤟 <br />
중위순회로 트리를 한 번 훑고 또 훑어서 시간이 조금 소요되는 것 같다. 그냥 중위순회하면서 조건에 만족하지 않으면 바로 return할 수도 있을 듯</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">중위순회 이용한다</span></strong>
    <ul>
      <li>중위순회는 LVR로, 오름차순으로 숫자를 방문함을 알 수 있다.</li>
      <li>따라서, 유효한 BST가 아니라면 오름차순을 만족하지 못하므로 false를 리턴하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 136. Single Number</title>
	  <link>/blog//algo-leet136</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet136</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/single-number/">https://leetcode.com/problems/single-number/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>해시맵을 이용하여 숫자별 개수를 센다.</li>
  <li>해시맵을 확인하여 value=1인 것을 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span> <span class="c1">// 맵에 추가</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nl">entry:</span><span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span> <span class="c1">// 개수가 하나인 것을 리턴</span>
            <span class="k">if</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_5.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">해시맵을 이용한다</span></strong>
    <ul>
      <li>해시맵을 사용함으로써 개수를 센 숫자를 다시 찾는데 걸리는 시간을 줄인다.</li>
      <li>getOrDefault()를 이용해 맵에 key가 저장되어 있지 않다면 0을 리턴하고, 여기다가 +1한다.</li>
      <li>map.entrySet()으로 해시맵을 순회한다. value가 1인 것은 해당 key(숫자)의 개수가 1인 것이므로 해당 key를 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
