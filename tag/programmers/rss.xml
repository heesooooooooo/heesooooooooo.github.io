<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/프로그래머스] 탐욕법(Greedy): 조이스틱</title>
	  <link>/blog//algo-prog42860</link>
	  <author></author>
	  <pubDate>2020-10-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog42860</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42860">https://programmers.co.kr/learn/courses/30/lessons/42860</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>문자열의 문자(i) 하나씩 체크하며 A가 아니면 상, 하 중 최솟값을 구한다.</li>
  <li>i 다음 문자가 A로 시작한다면 A가 끝나는 점 인덱스를 구한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">minWay</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 오른쪽으로 계속 이동하는 경우</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ch</span><span class="o">!=</span><span class="sc">'A'</span><span class="o">)</span> <span class="n">answer</span><span class="o">+=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">ch</span><span class="o">-</span><span class="sc">'A'</span><span class="o">,</span> <span class="sc">'Z'</span><span class="o">-</span><span class="n">ch</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 상, 하</span>
            
            <span class="kt">int</span> <span class="n">next</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
            <span class="c1">// i 다음 문자가 A로 시작한다면 A가 끝나는 위치 찾기</span>
            <span class="k">while</span><span class="o">(</span><span class="n">next</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">next</span><span class="o">)==</span><span class="sc">'A'</span><span class="o">)</span> <span class="n">next</span><span class="o">++;</span>
            <span class="n">minWay</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">minWay</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">-</span><span class="n">next</span><span class="o">);</span> 
        <span class="o">}</span>
        
        <span class="n">answer</span><span class="o">+=</span><span class="n">minWay</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201025_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">A가 아닌 문자는 상/하 중 최소 움직임을 선택한다</span></strong>
    <ul>
      <li>i번째 문자를 A로 만들기 위해서 아스키코드를 이용한다.</li>
      <li>A에서 시작한다면 ch-A이고, Z부터는 Z-ch+1이다(1은 A에서 Z로 가기 위함).</li>
      <li>둘 중 작은 값을 택한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">이동 방향을 체크한다</span></strong>
    <ul>
      <li>이동 방향의 최댓값은 한 방향으로만 가는 경우이다. 따라서 minWay를 n-1로 초기화한다.</li>
      <li>i번째 문자를 A로 바꿨다면, 다음 문자가 A인지 체크한다. A라면 A가 아닌 문자가 나오는 지점을 next를 통해 찾는다.</li>
      <li>이동 방향은 양쪽 가능한데, minWay는 오른쪽으로만 이동하는 경우이다. 더 빨리 알파벳을 완성하기 위해서는 왼쪽으로도 이동해야 한다. next를 통해 왼쪽으로 가는 경우를 찾는다.</li>
      <li>next는 오른쪽 방향으로 i 뒤에 A가 아닌 다른 알파벳으로 가는 거리이다. 왼쪽으로 그곳까지 가기 위해서는 i+i+n-next가 된다.</li>
      <li>i(현재 내 위치. 원점에서 내 위치까지 가는데 거리)+i(현재 위치에서 시작점으로 돌아가는 거리)+n-next(끝에서 next까지 가는 거리)</li>
      <li>따라서 기존 minWay(오른쪽으로 가는 경우), i+i+n-next(왼쪽으로 가는 경우)의 최솟값을 택해서 minWay에 넣으면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[프로그래머스] 조이스틱 (java) Greedy <a href="https://parksuu.github.io/139-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1-(java)/">https://parksuu.github.io/139-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A1%B0%EC%9D%B4%EC%8A%A4%ED%8B%B1-(java)/</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 연습문제: 가장 큰 정사각형 찾기</title>
	  <link>/blog//algo-prog12905</link>
	  <author></author>
	  <pubDate>2020-10-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog12905</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/12905">https://programmers.co.kr/learn/courses/30/lessons/12905</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>(i, j)가 정사각형이 되기 위해서, 내 왼쪽(i, j-1), 내 위쪽(i-1, j), 내 대각선 앞(i-1, j-1)이 같은 값을 가져야 한다.</li>
  <li>이를 이용하여 점화식을 구현한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="o">[][]</span><span class="n">board</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 새 배열의 사이즈</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">m</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 값 복사</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]==</span><span class="mi">1</span><span class="o">){</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]))+</span><span class="mi">1</span><span class="o">;</span>
                    <span class="n">answer</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">*</span><span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201025_3.PNG" alt="실행결과" />
🤟 성공 🤟<br />
input이 1000이지만 혹시나 하는 마음에 BFS로 구현하였는데 몇몇 케이스 실패에 시간 초과가 발생했다. 일단 범위가 크면 DP 점화식을 생각해봐야 겠다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">(i, j)가 정사각형이 되기 위한 조건을 생각한다</span></strong>
    <ul>
      <li>(i, j)가 정사각형이 되려면 값이 1이어야 한다.</li>
      <li>다음으로, 내 주변이 0이 아니어야 한다.</li>
      <li>위에서부터 순차 탐색한다면, 이미 체크한 인덱스들 중 내 주변인 왼쪽(i, j-1), 위(i-1, j), 대각선 위(i-1, j-1)가 된다.</li>
      <li>세 값이 같은 값을 가져야 나 포함해서 정사각형이 커질(될) 수 있다.</li>
      <li>따라서 세 값 중 하나+1(내가 포함되어 정사각형이 커졌으므로)를 저장한다.</li>
      <li>참고로, 배열에는 정사각형의 길이를 저장한다.</li>
      <li>세 값이 다르다면, 셋 중 제일 작은 값+1을 저장한다. 그 값이 현재까지 만들어진 정사각형의 길이이기 때문이다.</li>
      <li>따라서, 세 값을 비교하기 위해 인덱스 에러가 뜨지 않도록 배열의 맨 왼쪽과 위에 행열을 하나 더 붙인 map을 만들고, 값을 복사한 후 이를 사용한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<p>다른 사람들의 풀이 중에 board의 크기를 늘리지 않고 (1,1)부터 체크하는 코드가 있다. 이 경우 board의 0행, 0열은 체크하지 않기 때문에 여기를 포함하는 정사각형의 경우에는 잘못된 값을 낸다. 테스트케이스에서는 이와 같은 입력값이 없는지 성공이 뜨지만, 해당 input까지 생각한다면 배열을 늘리는 것이 낫다.</p>

<h3 id="참고">참고</h3>
<ul>
  <li>[프로그래머스] 가장 큰 정사각형 찾기 (java) Dynamic_Programming <a href="https://parksuu.github.io/27-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0-(java)/">https://parksuu.github.io/27-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0-(java)/</a></li>
  <li>배열에서 가장 큰 정사각형 찾기 <a href="https://blog.sonim1.com/212">https://blog.sonim1.com/212</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 월간 코드 챌린지 시즌1: 쿼드압축 후 개수 세기</title>
	  <link>/blog//algo-prog68936</link>
	  <author></author>
	  <pubDate>2020-10-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog68936</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/68936">https://programmers.co.kr/learn/courses/30/lessons/68936</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>분할정복 문제이다.</li>
  <li>배열 시작점 (x, y)에서 체크할 사각형 길이 k를 파라미터로 전달하고, 해당 범위가 같은 값으로 이루어져 있다면 그 원소 값을 하나 증가시킨다.</li>
  <li>같은 값이 아니라면, 범위를 k/2로 줄이고 다시 재귀호출한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span> <span class="c1">// arr 참조 전역변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">zero</span><span class="o">,</span> <span class="n">one</span><span class="o">;</span> <span class="c1">// 각 개수 카운트</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">map</span><span class="o">=</span><span class="n">arr</span><span class="o">;</span>
        <span class="n">zero</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">one</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">check</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
        
        <span class="n">answer</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">zero</span><span class="o">;</span>
        <span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="n">one</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isPossible</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">k</span><span class="o">)){</span> <span class="c1">// (x, y)에서 k범위까지가 같은 값으로 이루어져 있으면</span>
            <span class="kt">int</span> <span class="n">val</span><span class="o">=</span><span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span> <span class="c1">// 그 값 가져오기</span>
            <span class="k">if</span><span class="o">(</span><span class="n">val</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="n">one</span><span class="o">++;</span> <span class="c1">// 맞는 변수++</span>
            <span class="k">else</span> <span class="n">zero</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 같은 값으로 이루어져 있지 않다면</span>
        <span class="kt">int</span> <span class="n">half</span><span class="o">=</span><span class="n">k</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span> <span class="c1">// 범위 줄이기</span>
        <span class="c1">// 새 범위로 다시 재귀 호출</span>
        <span class="n">check</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">half</span><span class="o">);</span>
        <span class="n">check</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+</span><span class="n">half</span><span class="o">,</span> <span class="n">half</span><span class="o">);</span>
        <span class="n">check</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">half</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">half</span><span class="o">);</span>
        <span class="n">check</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">half</span><span class="o">,</span> <span class="n">y</span><span class="o">+</span><span class="n">half</span><span class="o">,</span> <span class="n">half</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isPossible</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">val</span><span class="o">=</span><span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span> <span class="c1">// 배열을 체크할 기준 값</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">y</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">y</span><span class="o">+</span><span class="n">k</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=</span><span class="n">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// 다른게 하나라도 있으면 F</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 모두 다 같은 값</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201025_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">check()</span></strong>
    <ul>
      <li>시작점 (x, y)에서 k만큼을 체크한다는 뜻이다.</li>
      <li>처음에는 (0,0)에서 n(배열 길이)만큼 isPossible()한다.</li>
      <li>리턴 값이 T라면 카운트하고 종료하겠지만, 아니라면 n/2의 넓이를 다시 체크해야 한다.</li>
      <li>이제 시작점은 총 4개로, (0,0), (0, n/2), (n/2, 0), (n/2, n/2)가 된다.</li>
      <li>이를 다시 재귀호출하여 isPossible인지 확인하고, 아니라면 거기서 또 4개로 쪼개면 된다.</li>
      <li>어쨌든 현재 체크하는 배열이 F면 4개의 배열로 분할해야 하고, 그 시작점은 위 코드와 같이 유추할 수 있으므로 check()를 4개 다 썼다. 물론 시작점 개수가 많다면 for문을 돌려서 적절하게 check()를 다시 호출할 수도 있다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">isPossible()</span></strong>
    <ul>
      <li>파라미터로 받은 범위가 같은 값으로 이루어져 있는지 확인하는 메소드이다.</li>
      <li>val은 시작점의 값을 가져온다. 배열이 같은 값으로 이루어져있는지 확인하기 위한 기준점이 된다. 물론 시작점이 아닌 다른 값을 가져와도 상관없다.</li>
      <li>배열을 순회하면서 하나라도 다른 값이 있다면 F를 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>쿼드트리 <a href="https://www.acmicpc.net/problem/1992">https://www.acmicpc.net/problem/1992</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] Summer/Winter Coding(~2018) : 스킬트리</title>
	  <link>/blog//algo-prog49993</link>
	  <author></author>
	  <pubDate>2020-10-23T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog49993</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/49993">https://programmers.co.kr/learn/courses/30/lessons/49993</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>skill의 각 문자를 K, 인덱스를 V로 하여 해시맵에 넣는다.</li>
  <li>해시맵을 이용해 스킬트리의 문자가 스킬이라면 value(인덱스)를 확인하여 순서대로 진행되는지 본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="n">String</span> <span class="n">skill</span><span class="o">,</span> <span class="n">String</span><span class="o">[]</span> <span class="n">skill_trees</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">skill</span><span class="o">.</span><span class="na">length</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 해시맵에 스킬과 인덱스 저장</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">skill</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">s:</span><span class="n">skill_trees</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 학습해야 할 스킬 인덱스</span>
            <span class="kt">boolean</span> <span class="n">flag</span><span class="o">=</span><span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
                <span class="kt">int</span> <span class="n">val</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">val</span><span class="o">==-</span><span class="mi">1</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 해당 문자가 스킬이 아니면 패스</span>
                <span class="c1">// 스킬일 경우</span>
                <span class="k">if</span><span class="o">(</span><span class="n">idx</span><span class="o">==</span><span class="n">val</span><span class="o">)</span> <span class="n">idx</span><span class="o">++;</span> <span class="c1">// 학습할 스킬이라면 학습</span>
                <span class="k">else</span> <span class="o">{</span> <span class="c1">// 아니라면 잘못된 문자열이므로 break</span>
                    <span class="n">flag</span><span class="o">=</span><span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="n">answer</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201023_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">해시맵에 스킬의 순서를 저장한다</span></strong>
    <ul>
      <li>K: 스킬 문자, V: 인덱스(스킬 순서)</li>
      <li>인덱스 순서대로 스킬이 진행된다는 뜻이다.</li>
      <li>스킬 문자를 숫자로 치환해줬다고 생각하면 쉽다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">스킬트리의 문자를 하나씩 확인한다</span></strong>
    <ul>
      <li>idx는 배워야 할 스킬 단어를 뜻한다.</li>
      <li>val은 map에서 i번째 문자열의 인덱스를 가져온다. map에 없다면 -1을 반환한다.</li>
      <li>i번째 문자가 map에 없다면(-1) 배울 수 있는 문자이므로 continue</li>
      <li>map에 존재한다면 idx를 체크하여 스킬 순서에 맞는지 확인해야 한다.</li>
      <li>idx==val이면 스킬 학습이 가능하므로 idx++하여 다음 배워야 할 스킬을 가리키도록 한다.</li>
      <li>idx!=val이라면 idx 뒤의 문자를 가지고 온 것이므로 flag를 통해 잘못된 스킬트리임을 표시하고 break한다.</li>
      <li>for문 탈출 후 flag가 true여야 가능한 스킬트리라는 뜻이므로 answer++한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 월간 코드 챌린지 시즌1: 삼각 달팽이</title>
	  <link>/blog//algo-prog68645</link>
	  <author></author>
	  <pubDate>2020-10-23T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog68645</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/68645">https://programmers.co.kr/learn/courses/30/lessons/68645</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>map[n][n] 배열을 만들고, 반시계 방향으로 채운다.</li>
  <li>방향 변경이 n번 일어나므로 이를 for문 i, 방향마다 움직이는 횟수는 n-i 되므로 이를 j로 한다.</li>
  <li>j를 보고 방향을 선택하여 map에 값을 저장한다.</li>
  <li>이차원 배열의 값을 일차원으로 변경하여 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">{};</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">x</span><span class="o">=-</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 방향 돌리는 횟수</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// 그 방향으로 움직이는 횟수</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">++;</span> <span class="c1">// 밑으로 이동</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">3</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="n">y</span><span class="o">++;</span> <span class="c1">// 옆</span>
                <span class="k">else</span><span class="o">{</span> <span class="c1">// 대각선</span>
                    <span class="n">x</span><span class="o">--;</span>
                    <span class="n">y</span><span class="o">--;</span>
                <span class="o">}</span>
                <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]=++</span><span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>            
        <span class="o">}</span>
        
        <span class="c1">// 반시계 달팽이 값 answer에 넣기</span>
        <span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="n">answer</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">num</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]==</span><span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">idx</span><span class="o">++]=</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201023_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">규칙을 찾는다</span></strong>
    <ul>
      <li>map[n][n]에 반시계 방향으로 넣으면 총 n번의 방향 전환이 일어난다.</li>
      <li>처음 방향에서는 n개 움직이고, 그 다음 방향은 n-1, … , 마지막은 1개 움직인다.</li>
      <li>따라서 i: 방향 전환 횟수, j: 방향안에서 움직이는 횟수로 두고 이중 for문을 만든다.</li>
      <li>i를 보고 어느 방향인지 본다. 방향은 총 3가지가 있으므로 나머지 연산을 이용한다. 0일때는 아래, 1은 옆, 2는 대각선이 된다.</li>
      <li>해당 위치에 num을 넣는다.</li>
      <li>이 코드는 i번째 방향에서 이동 개수(j)를 알고 있으므로 인덱스를 넘어가지 않는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">배열로 리턴한다</span></strong>
    <ul>
      <li>이차원배열 map에 저장한 값을 int[]형에 맞게 넣는다.</li>
      <li>map[i][j]==0이 나오면 그 행에서 다음 원소들은 볼 필요가 없으므로 break하여 다음 행으로 넘어간다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] Summer/Winter Coding(2019) : 멀쩡한 사각형</title>
	  <link>/blog//algo-prog62048</link>
	  <author></author>
	  <pubDate>2020-10-22T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog62048</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/62048">https://programmers.co.kr/learn/courses/30/lessons/62048</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>대각선 넓이의 규칙을 찾는다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">long</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">w</span><span class="o">,</span><span class="kt">int</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">long</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">w</span><span class="o">&lt;</span><span class="n">h</span><span class="o">){</span> <span class="c1">// w가 더 크도록</span>
            <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
            <span class="n">w</span><span class="o">=</span><span class="n">h</span><span class="o">;</span>
            <span class="n">h</span><span class="o">=</span><span class="n">temp</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">gcd</span><span class="o">=</span><span class="n">gcd</span><span class="o">(</span><span class="n">w</span><span class="o">,</span><span class="n">h</span><span class="o">);</span>
        <span class="n">answer</span><span class="o">=(</span><span class="kt">long</span><span class="o">)</span><span class="n">w</span><span class="o">*(</span><span class="kt">long</span><span class="o">)</span><span class="n">h</span><span class="o">-(</span><span class="n">w</span><span class="o">+</span><span class="n">h</span><span class="o">-</span><span class="n">gcd</span><span class="o">);</span>
		<span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
	<span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">gcd</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">){</span> <span class="c1">// 최대공약수</span>
        <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">b</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201022_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">대각선 넓이의 규칙을 찾는다</span></strong>
    <ul>
      <li>예시에서 똑같은 패턴이 4번 반복됨을 알 수 있다.</li>
      <li>4는 8과 12의 최대공약수이다.</li>
      <li>w=2, h=3일 때 6-4=6-(3+2-1)=w*h-(w+h-1) 식을 도출할 수 있다.</li>
      <li>최대공약수가 1 이상이면, gcd만큼 패턴이 반복되는 것이므로 (w/gcd+h/gcd-1)*gcd=w+h-gcd</li>
      <li>따라서 해당 문제의 점화식은 w*h-(w+h-gcd)</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<h3 id="참고">참고</h3>
<ul>
  <li>[프로그래머스] 여행경로 (java)(43164) <a href="https://youjourney.tistory.com/111">https://youjourney.tistory.com/111</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 깊이/너비 우선 탐색(DFS/BFS): 여행경로</title>
	  <link>/blog//algo-prog43164</link>
	  <author></author>
	  <pubDate>2020-10-22T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog43164</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/43164">https://programmers.co.kr/learn/courses/30/lessons/43164</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DFS를 이용하여 티켓 경로를 찾는다</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span> <span class="c1">// 티켓 수</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span><span class="o">;</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span> <span class="c1">// 최종 경로 저장</span>
    <span class="n">String</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span> <span class="c1">// 티켓 참조 변수</span>
    
    <span class="kd">public</span> <span class="n">String</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="n">String</span><span class="o">[][]</span> <span class="n">tickets</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="o">{};</span>
        
        <span class="n">n</span><span class="o">=</span><span class="n">tickets</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visit</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">map</span><span class="o">=</span><span class="n">tickets</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">tickets</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"ICN"</span><span class="o">)){</span> <span class="c1">// 시작</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 티켓 사용</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">tickets</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="mi">1</span><span class="o">,</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="s">"ICN "</span><span class="o">));</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span> <span class="c1">// 사용 안 할 경우</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span> <span class="c1">// 알파벳기준 오름차순 정렬</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span> <span class="c1">// 첫번째 값 리턴</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="n">String</span> <span class="n">dept</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">){</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">dept</span><span class="o">+</span><span class="s">" "</span><span class="o">);</span> <span class="c1">// 방문</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span><span class="o">==</span><span class="n">n</span><span class="o">){</span> <span class="c1">// 경로 생성 완료</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 티켓들 체크</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">dept</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span> <span class="c1">// 다음 티켓 찾음</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 티켓 사용</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sb</span><span class="o">);</span>
                <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span> <span class="c1">// 사용 안 할 경우</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">4</span><span class="o">,</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201022_2.PNG" alt="실행결과" />
🤟 성공 🤟<br />
가능한 경우가 여러 개이면 알파벳 순서로 움직여라길래 미리 comparator를 이용하여 sort후 사용하려고 했으나 잘 안됐다.<br />
그리고 dfs 호출 전 visit 여부를 관리해야 하는지, 들어가서 해야 하는지 헷갈린다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">for문을 돌며 시작점을 체크한다</span></strong>
    <ul>
      <li>ICN인 곳을 찾아서 순회를 시작한다.</li>
      <li>해당 티켓을 썼으므로 visit[i]는 true로 바꾸고, dfs()를 이용하여 dest를 다시 dept로 가지는 곳을 찾는다.</li>
      <li>ICN을 찾았지만 사용하지 않을 수도 있다. 따라서 dfs()후에 false로 처리하여 사용하지 않는다.</li>
      <li>dfs()를 다 돌고 나면 모든 경우가 list에 저장된다. 이를 알파벳 순 오름차순으로 정렬하면 0번째 값이 정답이다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">DFS</span></strong>
    <ul>
      <li>파라미터 dept는 이전에 dest였으므로 sb에 넣는다.</li>
      <li>idx는 sb에 저장된 갯수로, n개가 되면 모든 곳을 다 방문한 것이므로 list에 넣고 종료한다.</li>
      <li>아니라면, tickets를 다시 돌며 다음 티켓을 찾는다.</li>
      <li>해당 티켓을 쓸 경우와 아닐 경우를 나눠서 짠다.</li>
      <li>dfs로 방문 호출하고 난 뒤에 sb에서 삭제해야 한다. for문 밖에서 지우면 지금 위치는 방문하지 않았다는 것인데, 그러면 지금 위치 이전의 출발지는 방문하고 지금 위치는 방문하지 않는다는 모순이 생기기 때문이다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<h3 id="참고">참고</h3>
<ul>
  <li>[프로그래머스] 여행경로 (java)(43164) <a href="https://youjourney.tistory.com/111">https://youjourney.tistory.com/111</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 연습문제: 124 나라의 숫자</title>
	  <link>/blog//algo-prog12899</link>
	  <author></author>
	  <pubDate>2020-10-21T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog12899</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/12899">https://programmers.co.kr/learn/courses/30/lessons/12899</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>숫자를 3으로 나누며 나머지에 따라 적절한 숫자를 붙인다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="n">String</span><span class="o">[]</span> <span class="n">s</span><span class="o">={</span><span class="s">"4"</span><span class="o">,</span><span class="s">"1"</span><span class="o">,</span><span class="s">"2"</span><span class="o">};</span>
        <span class="kt">int</span> <span class="n">rest</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 나머지</span>
        <span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
        <span class="k">while</span><span class="o">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">){</span>
            <span class="n">rest</span><span class="o">=</span><span class="n">n</span><span class="o">%</span><span class="mi">3</span><span class="o">;</span>
            <span class="n">n</span><span class="o">/=</span><span class="mi">3</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rest</span><span class="o">==</span><span class="mi">0</span><span class="o">){</span> <span class="c1">// 나머지가 0이면 n--</span>
                <span class="n">n</span><span class="o">-=</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
           <span class="n">sb</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">[</span><span class="n">rest</span><span class="o">]);</span> <span class="c1">// 문자열 맨 앞에 추가</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201021_2.PNG" alt="실행결과" />
🤟 성공 🤟<br />
처음에 중복 순열, 나름 dp로 문제를 풀었으나 효율성에서 죄다 0점을 맞아… 다른 사람의 코드를 참고하였다. 하긴 n이 5억 이하니까 규칙이 있어야만 한다(?).</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">n을 3으로 나머지 연산한다</span></strong>
    <ul>
      <li>n=1일때 124연산 값은 1이다. n%3=1이므로 나머지가 1이 되면 124연산에서 1을 사용함을 알 수 있따. 2도 같은 방식이다.</li>
      <li>n=3이면 나머지가 0인데, 이때 124연산에서는 4를 채택한다. 따라서 배열 인덱스 번호에 맞게 {4,1,2}를 저장하고 코드 수행 나머지에 맞는 인덱스 번호를 찾아 값을 사용하면 된다.</li>
      <li>또한, 나머지가 0이면 다음 계산에서 조금 변경이 필요하다. n=6이면 rest(나머지)=6%3=0이므로 4를 채택하고, n은 2(n/3)로 갱신된다. 이를 다시 나머지 연산하면 2를 채택하므로 틀린다. 2가 아닌 그 전의 값을 가져와야 한다. 따라서 n-=1로 하나 줄여야 한다.</li>
      <li>수행되는 값은 sb의 맨 앞에 계속 붙여야 한다. 따라서 sb.insert() 메소드를 이용한다. 메소드의 첫 번째 파라미터는 붙일 인덱스 위치(우리는 맨 앞에 붙이는 것이니까 0), 다음은 붙일 값이다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>


	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 2017 카카오코드 예선: 카카오프렌즈 컬러링북</title>
	  <link>/blog//algo-prog1829</link>
	  <author></author>
	  <pubDate>2020-10-21T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog1829</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/1829">https://programmers.co.kr/learn/courses/30/lessons/1829</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DFS로 배열을 순회하며 영역 개수를 센다.</li>
  <li>picture 크기와 같은 int형 visit 배열을 생성하고, 위치를 방문했을 때 picture값을 넣어 중복 탐색을 방지한다.</li>
  <li>영역별로 체크가 끝날 때 마다 max에 영역 개수의 최대값을 저장한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">visit</span><span class="o">;</span> <span class="c1">// 방문 체크 배열</span>
    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span> <span class="c1">// 영역별 넓이 저장</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">,</span> <span class="n">max</span><span class="o">;</span> <span class="c1">// 탐색하고 있는 영역의 넓이, 전체 영역 넓이 중 최대값</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dotX</span><span class="o">={</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">dotY</span><span class="o">={</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">picture</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        
        <span class="n">visit</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="c1">// 색깔이 있고 방문하지 않는 곳이면 해당 영역 찾기</span>
                <span class="k">if</span><span class="o">(</span><span class="n">picture</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]!=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
                    <span class="n">cnt</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">picture</span><span class="o">);</span>
                    <span class="c1">// 영역 탐색 완료 후 max, list에 값 저장</span>
                    <span class="n">max</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">cnt</span><span class="o">);</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cnt</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>        
        
        <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">max</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">picture</span><span class="o">){</span>
        <span class="n">visit</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]=</span><span class="n">picture</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span> <span class="c1">// 방문했음을 표시</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 사방으로 갈 수 있는 좌표 계산</span>
            <span class="kt">int</span> <span class="n">xx</span><span class="o">=</span><span class="n">x</span><span class="o">+</span><span class="n">dotX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">yy</span><span class="o">=</span><span class="n">y</span><span class="o">+</span><span class="n">dotY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">if</span><span class="o">(</span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">xx</span><span class="o">&gt;=</span><span class="n">m</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&gt;=</span><span class="n">n</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 범위 초과</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visit</span><span class="o">[</span><span class="n">xx</span><span class="o">][</span><span class="n">yy</span><span class="o">]!=</span><span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문한 곳이면 패스</span>
            <span class="k">if</span><span class="o">(</span><span class="n">picture</span><span class="o">[</span><span class="n">xx</span><span class="o">][</span><span class="n">yy</span><span class="o">]==</span><span class="n">picture</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]){</span> <span class="c1">// 현재 탐색 영역과 색깔이 같다면</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">xx</span><span class="o">,</span> <span class="n">yy</span><span class="o">,</span> <span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">picture</span><span class="o">);</span> <span class="c1">// 이동</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201021_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DFS를 이용한다</span></strong>
    <ul>
      <li>배열의 영역을 구하는 문제는 주로 DFS를 이용한다.</li>
      <li>picture 값 별로 같은 영역을 구해야 하므로 visit 배열을 int형으로 선언하여, 방문한 곳이면 picture 값(색깔)을 저장한다.</li>
      <li>dotX, dotY 배열을 통해 상하좌우로 이동할 수 있는 좌표를 저장한다.</li>
      <li>for문으로 상하좌우 좌표를 계산하고, 배열 범위와 방문한 곳인지를 체크한다.</li>
      <li>탐색하는 영역의 색깔과 같다면(picture[i][j]), 영역이 늘어났으므로 cnt++하고 재귀 호출을 통해 그 곳으로 이동한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">main에서 picture을 순회하며 색깔이 있고 방문하지 않은 영역을 찾아 dfs를 호출한다</span></strong>
    <ul>
      <li>이중 for문을 통해 picture의 모든 원소를 탐색하지만, visit로 방문 여부를 체크하였기 때문에 같은 곳을 두 번 이상 dfs를 사용하는 경우는 없다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>


	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/프로그래머스] 2019 KAKAO BLIND RECRUITMENT : 길 찾기 게임</title>
	  <link>/blog//algo-prog42892</link>
	  <author></author>
	  <pubDate>2020-09-13T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-prog42892</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42892">https://programmers.co.kr/learn/courses/30/lessons/42892</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>x, y, value를 가지는 Node로 바꾸어 배열에 저장한 후, y 기준으로 내림차순 정렬한다. y가 같다면 x가 더 작은 것이 앞으로 온다.</li>
  <li>Node의 left, right를 이용하여 트리를 만든다.</li>
  <li>전위 순회와 후위 순회를 진행한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">nodeinfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">Node</span><span class="o">[]</span> <span class="n">array</span><span class="o">=</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">nodeinfo</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nodeinfo</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">nodeinfo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">nodeinfo</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Node</span> <span class="n">o1</span><span class="o">,</span> <span class="n">Node</span> <span class="n">o2</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">y</span><span class="o">&lt;</span><span class="n">o2</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">y</span><span class="o">==</span><span class="n">o2</span><span class="o">.</span><span class="na">y</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">o1</span><span class="o">.</span><span class="na">x</span><span class="o">&lt;</span><span class="n">o2</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                    <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
		<span class="n">Node</span> <span class="n">root</span><span class="o">=</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
		<span class="o">}</span>
		<span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">][</span><span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
		<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
		<span class="n">preorder</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="n">result</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
		<span class="n">postorder</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">();</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
		<span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Node</span> <span class="n">root</span><span class="o">,</span> <span class="n">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">x</span><span class="o">&gt;</span><span class="n">node</span><span class="o">.</span><span class="na">x</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
			<span class="k">else</span> <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="n">node</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">insert</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">node</span><span class="o">);</span>
			<span class="k">else</span> <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="n">node</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">preorder</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
		<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">preorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">preorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postorder</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">postorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">!=</span><span class="kc">null</span><span class="o">)</span> <span class="n">postorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
		<span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Node</span><span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">left</span><span class="o">;</span>
    <span class="n">Node</span> <span class="n">right</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">=</span><span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">=</span><span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">=</span><span class="n">v</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200913_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">Node 클래스를 만든 후 배열에 넣어 정렬한다</span></strong>
    <ul>
      <li>x, y는 각 좌표, value는 노드 값이다.</li>
      <li>left, right를 통해 자식 노드와 연결한다.</li>
      <li>Comparator을 이용하여 정렬한다.</li>
      <li>중위 순회한 값 순서대로 저장되도록, y의 값이 클 수록 앞으로 온다. y가 같다면 x가 작은 것이 앞으로 온다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">트리를 만든다</span></strong>
    <ul>
      <li>insert()를 통해 트리를 만든다. root는 현재 내 위치이고, node는 새로 삽입할 값이다.</li>
      <li>현재 root보다 node의 x가 작다면 재귀를 통해 root의 left로 간다. 반대라면 right로 간다.</li>
      <li>가야할 곳이 null이라면 그 곳에 node를 넣는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">전위순회와 후위순회를 하여 결과를 저장한다</span></strong>
    <ul>
      <li>전위 순회는 preorder에서, 후위 순회는 postorder에서 한다.</li>
      <li>결과를 result에 저장하기 위해 ArrayList를 파라미터로 계속 넘겨준다.</li>
      <li>result에 값이 들어오면 answer에 넣는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>2019 카카오 블라인드 코딩테스트 (프로그래멋, Java, 길 찾기 게임) <a href="https://eoghks0521.tistory.com/entry/2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Java-%EA%B8%B8-%EC%B0%BE%EA%B8%B0-%EA%B2%8C%EC%9E%84">https://eoghks0521.tistory.com/entry/2019-%EC%B9%B4%EC%B9%B4%EC%98%A4-%EB%B8%94%EB%9D%BC%EC%9D%B8%EB%93%9C-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-Java-%EA%B8%B8-%EC%B0%BE%EA%B8%B0-%EA%B2%8C%EC%9E%84</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
