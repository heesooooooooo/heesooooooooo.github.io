<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>(◍•ᴗ•◍)</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[Algorithm] 백트래킹(BackTracking)</title>
	  <link>/blog//algo-backtracking</link>
	  <author></author>
	  <pubDate>2020-03-12T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-backtracking</guid>
	  <description><![CDATA[
	     <h2 id="백트래킹"><span style="color:navy">백트래킹</span></h2>

<h3 id="1-기본-개념">1. 기본 개념</h3>
<ul>
  <li>모든 경우를 구할 때 사용한다.</li>
  <li>그리디 알고리즘(Greedy Algorithm)처럼 모든 가능성을 조회한다는 것은 같으나, 백트래킹은 계산 도중 아닌 것 같으면 종료한다(그리디는 진짜 다 구한다).</li>
  <li>DFS를 이용한다.</li>
  <li>visit[]를 두어 사용 여부를 체크한다.</li>
  <li>수행 후 다시 재귀호출로 Depth를 만족시킨다.</li>
  <li>복귀 후 visit[i]=false로 바꾸어 다음 사용을 가능하게 한다.</li>
  <li>퀸 문제가 대표적이다. <a href="https://www.acmicpc.net/problem/9663">https://www.acmicpc.net/problem/9663</a></li>
  <li>스도쿠에도 이용된다. <a href="https://www.acmicpc.net/problem/2580">https://www.acmicpc.net/problem/2580</a></li>
  <li>순열(순서있게 배열), 조합(순서 상관없이 뽑는 것에 집중)에도 이용된다.</li>
</ul>

<h3 id="2-코드">2. 코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/*...*/</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recur</span><span class="o">(...){</span>
    <span class="k">if</span><span class="o">(</span><span class="cm">/*재귀 종료 조건*/</span><span class="o">){</span>
        <span class="c1">//맨 마지막 Depth에 도달 시 수행해야 할 코드 작성</span>
        <span class="k">return</span><span class="o">;</span><span class="c1">//다시 호출 지점으로 복귀</span>
    <span class="o">}</span>

    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span><span class="c1">//해당 값 사용</span>
            <span class="n">recur</span><span class="o">(...);</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span><span class="c1">//다음 사용을 위함</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/*...*/</span>
</code></pre></div></div>

<h3 id="4-결과">4. 결과</h3>
<ul>
  <li>visit[]로 중복 사용을 없애고, 다시 재귀호출하여 DFS의 depth조건을 만족시킨다.</li>
  <li>recur로 끝까지 방문하고 return으로 재귀 호출 지점으로 복귀한 후에는, 또 다른 경우의 수에 따른 계산을 위해 visit[i]=false로 바꾸어 다시 재사용할 수 있게 한다.</li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>[Algorithm] 플로이드 와샬 알고리즘(Floyd-Warshall Algorithm)</title>
	  <link>/blog//algo-floyd</link>
	  <author></author>
	  <pubDate>2019-12-12T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-floyd</guid>
	  <description><![CDATA[
	     <h2 id="플로이드-와샬-알고리즘"><span style="color:navy">플로이드 와샬 알고리즘</span></h2>

<h3 id="1-기본-개념">1. 기본 개념</h3>
<ul>
  <li>그래프에서 모든 꼭짓점 사이의 최단경로의 거리를 구하는 알고리즘이다.</li>
  <li>최단 경로를 찾기에 좋은 알고리즘이다.</li>
  <li>O(n^3), 시간이 많이 소요된다는 단점이 있다.</li>
</ul>

<h3 id="2-초기화">2. 초기화</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">i/j</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">5</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">INF</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">INF</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>i==j인 곳은 0으로, 나머지는 INF(적당히 큰 값)으로 초기화한다.</li>
  <li>이때 INF가 Integer.MAX_VALUE일 경우, 두 값을 더해서 int형에 저장한다면 오버플로우가 발생하므로 INF는 적당히 큰 값으로 초기화하는 것이 좋다(ex. 987654321).</li>
</ul>

<h3 id="3-코드">3. 코드</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/*...*/</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">k</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">k</span><span class="o">++){</span><span class="c1">//거쳐가는 꼭짓점</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span><span class="c1">//출발하는 꼭짓점</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span><span class="c1">//도착하는 꼭짓점</span>
      <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]&gt;</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]+</span><span class="n">d</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]){</span><span class="c1">//더 짧은 경로 찾았다면</span>
        <span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]+</span><span class="n">d</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="cm">/*...*/</span>
</code></pre></div></div>

<h3 id="4-결과">4. 결과</h3>
<ul>
  <li>0과 INF를 제외한 값들이 최단 경로이다.</li>
</ul>

<h3 id="참고">참고</h3>
<ul>
  <li>플로이드-워셜 알고리즘(Floyd-Warshall Algorithm) <a href="https://hsp1116.tistory.com/45">https://hsp1116.tistory.com/45</a></li>
  <li>플로이드 와샬 알고리즘 :: 마이구미 <a href="https://mygumi.tistory.com/110">https://mygumi.tistory.com/110</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
