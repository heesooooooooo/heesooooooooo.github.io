<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
	  <link>/blog//algo-leet105</link>
	  <author></author>
	  <pubDate>2020-10-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet105</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>inorder에서 preorder[i] 위치를 찾는다. 그 왼쪽은 모두 preorder의 left이고, 오른쪽은 right이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">buildTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">inorder</span><span class="o">[</span><span class="n">i</span><span class="o">],</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="nf">solution</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">preorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">inorder</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">TreeNode</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">prestart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">preend</span><span class="o">,</span> <span class="kt">int</span> <span class="n">instart</span><span class="o">,</span> <span class="kt">int</span> <span class="n">inend</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">preorder</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">inorder</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prestart</span><span class="o">&gt;</span><span class="n">preend</span> <span class="o">||</span> <span class="n">instart</span><span class="o">&gt;</span><span class="n">inend</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="n">TreeNode</span> <span class="n">node</span><span class="o">=</span><span class="k">new</span> <span class="n">TreeNode</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">prestart</span><span class="o">]);</span> <span class="c1">// 현재 생성할 노드</span>
        <span class="kt">int</span> <span class="n">inroot</span><span class="o">=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">preorder</span><span class="o">[</span><span class="n">prestart</span><span class="o">]);</span> <span class="c1">// inorder에서 pre[i]의 위치 찾기</span>
        <span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="n">inroot</span><span class="o">-</span><span class="n">instart</span><span class="o">;</span> <span class="c1">// node의 마지막 left 위치 찾기</span>
        
        <span class="c1">// left 생성</span>
        <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="n">solution</span><span class="o">(</span><span class="n">prestart</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">prestart</span><span class="o">+</span><span class="n">left</span><span class="o">,</span> <span class="n">instart</span><span class="o">,</span> <span class="n">inroot</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
        <span class="c1">// right</span>
        <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="n">solution</span><span class="o">(</span><span class="n">prestart</span><span class="o">+</span><span class="n">left</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">preend</span><span class="o">,</span> <span class="n">inroot</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">inend</span><span class="o">,</span> <span class="n">preorder</span><span class="o">,</span> <span class="n">inorder</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201005_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">preorder[i]가 inorder에서 몇 번째 인덱스인지 찾는다</span></strong>
    <ul>
      <li>반복문으로 인덱스를 찾는 것 보다 해시맵에 넣어서 찾는 것이 더 빠르다.</li>
      <li>preorder은 VLR, inorder은 LVR으로, preorder 순서대로 트리를 만들되, 어디까지가 left, right인지 확인하기 위해 inorder에서 Visit node의 위치를 찾는다.</li>
      <li>inorder[preorder[i]]의 왼쪽이 left node이고, 오른쪽이 right 노드이다.</li>
      <li>left 변수에 node의 마지막 left node 인덱스 번호를 저장한다.</li>
      <li>preorder 배열에서 prestart+1~prestart+left 인덱스까지가 node의 left node이다.</li>
      <li>node의 right node들은 prestart+left+1부터 preend까지이다. 이때 node의 left, right를 연결했으므로 다음 node를 찾기 위해 inorder의 범위도 갱신한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 114. Flatten Binary Tree to Linked List</title>
	  <link>/blog//algo-leet114</link>
	  <author></author>
	  <pubDate>2020-10-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet114</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/">https://leetcode.com/problems/flatten-binary-tree-to-linked-list/submissions/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>postorder을 이용하여 트리를 재구성한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">TreeNode</span> <span class="n">prev</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">flatten</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">flatten</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">=</span><span class="n">prev</span><span class="o">;</span>
        <span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">=</span><span class="kc">null</span><span class="o">;</span>
        <span class="n">prev</span><span class="o">=</span><span class="n">root</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201005_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">postorder을 이용한다</span></strong>
    <ul>
      <li>후위순회는 RLV로 방문한다.</li>
      <li>문제의 예제에서 후위순회로 방문하면 [6,5,4,3,2,1]이므로 트리의 밑에서 위로 올라가며 오른쪽으로 flatten된 트리를 만들면 된다.</li>
      <li>재귀를 통해 오른쪽 끝까지 이동한 후, 마지막 노드 root의 right는 이전 prev, left는 null로 바꾼다.</li>
      <li>이제 root의 위로 올라가므로 prev를 root로 갱신한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 136. Single Number</title>
	  <link>/blog//algo-leet136</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet136</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/single-number/">https://leetcode.com/problems/single-number/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>해시맵을 이용하여 숫자별 개수를 센다.</li>
  <li>해시맵을 확인하여 value=1인 것을 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">singleNumber</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span> <span class="c1">// 맵에 추가</span>
            <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">num</span><span class="o">,</span><span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="nl">entry:</span><span class="n">map</span><span class="o">.</span><span class="na">entrySet</span><span class="o">()){</span> <span class="c1">// 개수가 하나인 것을 리턴</span>
            <span class="k">if</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">()==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">();</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_5.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">해시맵을 이용한다</span></strong>
    <ul>
      <li>해시맵을 사용함으로써 개수를 센 숫자를 다시 찾는데 걸리는 시간을 줄인다.</li>
      <li>getOrDefault()를 이용해 맵에 key가 저장되어 있지 않다면 0을 리턴하고, 여기다가 +1한다.</li>
      <li>map.entrySet()으로 해시맵을 순회한다. value가 1인 것은 해당 key(숫자)의 개수가 1인 것이므로 해당 key를 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question:121. Best Time to Buy and Sell Stock</title>
	  <link>/blog//algo-leet121</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet121</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>0번째 인덱스를 buy한다고 가정한다.</li>
  <li>buy보다 더 작은 값이 나오면 갱신한다.</li>
  <li>아닐 경우, i로 판다고 가정하고 이윤을 계산한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxProfit</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// 0 또는 1은 0리턴</span>
        
        <span class="kt">int</span> <span class="n">buy</span><span class="o">=</span><span class="n">prices</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 첫 번째는 buy</span>
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="c1">// 더 싸게 살 수 있으면 buy</span>
            <span class="k">if</span><span class="o">(</span><span class="n">buy</span><span class="o">&gt;</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="n">buy</span><span class="o">=</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">];</span> 
            <span class="c1">// i로 판다고 가정했을 때 이윤 계산 및 max 체크</span>
            <span class="k">else</span> <span class="n">answer</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]-</span><span class="n">buy</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_6.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">배열을 체크하며 buy보다 더 작은 값이 있다면 갱신, 아니라면 이익을 계산한다</span></strong>
    <ul>
      <li>buy=prices[0]으로 초기화한다. 처음 값으로 샀다고 가정한다.</li>
      <li>인덱스 1부터 체크하며 buy&gt;prices[i]면 더 작은 값으로 산다.</li>
      <li>아니라면, 이익을 계산하고 기존 값과 비교하여 answer에 더 큰 값을 저장한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 104. Maximum Depth of Binary Tree</title>
	  <link>/blog//algo-leet104</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet104</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">https://leetcode.com/problems/maximum-depth-of-binary-tree/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>큐를 이용해 트리를 순회한다.</li>
  <li>현재 큐에 남아있는 값들이 같은 레벨인 것이므로 현재 큐의 개수만큼 뽑아서 리스트에 저장한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxDepth</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">depth</span><span class="o">=-</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
            <span class="n">depth</span><span class="o">++;</span> <span class="c1">// 현재 레벨 계산</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 레벨에 있는 노드 체크</span>
                <span class="n">TreeNode</span> <span class="n">node</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">depth</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_4.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>레벨순회를 통해 레벨 개수를 셌다.</li>
      <li>큐의 사이즈를 체크해서 size에 저장한다. 현재 레벨에 size만큼 노드가 있다는 뜻이다. 이 개수만큼 for문을 돌며 자식 노드들을 큐에 다시 넣는다. for문에서 size대신 q.size()를 쓰면, 밑에서 큐에 값을 삽입하며 큐 size가 계속 갱신되기 때문에 안된다.</li>
      <li>depth는 -1로 초기화한다. root가 들어오면 depth++하여 0이 되도록 하기 위함이다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 102. Binary Tree Level Order Traversal</title>
	  <link>/blog//algo-leet102</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet102</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/symmetric-tree/">https://leetcode.com/problems/symmetric-tree/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>큐를 이용해 트리를 순회한다.</li>
  <li>현재 큐에 남아있는 값들이 같은 레벨인 것이므로 현재 큐의 개수만큼 뽑아서 리스트에 저장한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">levelOrder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="c1">// 현재 노드 개수==현재 레벨의 노드 개수</span>
            <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> 
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
                <span class="n">TreeNode</span> <span class="n">node</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()!=</span><span class="mi">0</span><span class="o">)</span> <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>큐를 이용해 트리를 방문한다.</li>
      <li>현재 큐에 있는 노드들은 같은 레벨인 것과 같다.</li>
      <li>하지만 while문 처음에 poll한 node의 left와 right를 또다시 큐에 넣으면 큐의 사이즈가 바뀌기 때문에, 큐의 사이즈를 size에 저장해놓고, 그 개수만큼 for문을 돌려 노드를 뽑는다.</li>
      <li>뽑은 노드가 null이 아니라면, list에 넣는다.</li>
      <li>size만큼 뽑아서 list에 저장한 것이 하나 이상 존재하면 result에 넣는다. 해당 코드가 없으면 빈 리스트가 result에 들어간다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 101. Symmetric Tree</title>
	  <link>/blog//algo-leet101</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet101</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/symmetric-tree/">https://leetcode.com/problems/symmetric-tree/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>큐에서 두 개를 뽑고, 두 값이 같다면 a의 왼쪽, b의 오른쪽, a의 오른쪽, b의 왼쪽을 순서대로 넣는다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSymmetric</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()){</span>
            <span class="n">TreeNode</span> <span class="n">a</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">TreeNode</span> <span class="n">b</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="c1">// 두 개 비교</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">==</span><span class="kc">null</span> <span class="o">||</span> <span class="n">b</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">val</span><span class="o">!=</span><span class="n">b</span><span class="o">.</span><span class="na">val</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="c1">// 두 값이 대칭이라면 순서대로 넣기</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>큐에서 두 개씩 뽑아 값을 비교한다. 루트는 하나기 때문에 같은 값을 두 번 넣어준다.</li>
      <li>큐에서 두 개를 뽑는다. a와 b가 둘 다 null이라면 자식 노드도 없으므로 바로 continue한다.</li>
      <li>둘 중 하나가 null이면 대칭이 아니므로 false를 리턴한다.</li>
      <li>값이 달라도 false이다.</li>
      <li>값이 같다면 자식 노드들을 넣어준다. 비교하는 대상이 정해져있기 때문에 순서를 맞춰서 넣는다.</li>
      <li>a의 왼쪽은 b의 오른쪽과, a의 오른쪽은 b의 왼쪽과 비교해야 하므로 차례대로 넣는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 98. Validate Binary Search Tree</title>
	  <link>/blog//algo-leet98</link>
	  <author></author>
	  <pubDate>2020-09-28T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet98</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">https://leetcode.com/problems/validate-binary-search-tree/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>중위순회로 탐색하며 뒤에 나보다 작은 값이 나오면 false이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isValidBST</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">root</span><span class="o">==</span><span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="c1">// 뒤에 나보다 같거나 더 큰 값이 있으면</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)&gt;=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">){</span> <span class="c1">// 중위순회</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200928_1.PNG" alt="실행결과" />
🤟 성공 🤟 <br />
중위순회로 트리를 한 번 훑고 또 훑어서 시간이 조금 소요되는 것 같다. 그냥 중위순회하면서 조건에 만족하지 않으면 바로 return할 수도 있을 듯</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">중위순회 이용한다</span></strong>
    <ul>
      <li>중위순회는 LVR로, 오름차순으로 숫자를 방문함을 알 수 있다.</li>
      <li>따라서, 유효한 BST가 아니라면 오름차순을 만족하지 못하므로 false를 리턴하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 96. Unique Binary Search Trees</title>
	  <link>/blog//algo-leet96</link>
	  <author></author>
	  <pubDate>2020-09-27T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet96</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees/submissions/">https://leetcode.com/problems/unique-binary-search-trees/submissions/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numTrees</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]+=</span><span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]*</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200927_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>n=1이면 1 (dp[1]=1)</li>
      <li>n=2이면 1(root)- 2(right) 또는 1(left)-2(root) 이므로 dp[2]=2</li>
      <li>n=3인 경우, root가 1이면 left에는 아무것도 오지 않고, right는 {2,3}이 온다. {2,3}이나 {1,2}나 BST를 만드는 경우의 수는 같으므로 경우의 수는 1(left 경우의 수, dp[0])*dp<a href="right 경우의 수">2</a>=2</li>
      <li>root=2이면, left에는 {1}, right는 {3}이 온다. 따라서 경우의 수는 dp[1]*dp[1]=1</li>
      <li>root=3이면 left에 {1,2}, right={null}이므로 dp[2]*dp[0]=2</li>
      <li>이를 모두 더하면 <code class="highlighter-rouge">dp[3]=(dp[0]*dp[2])+(dp[1]*dp[1])+(dp[2]*dp[0])</code></li>
      <li>따라서 이를 점화식으로 나타내면 dp[x]=dp[0]*dp[x-1]+…+dp[x-1][0]이다.</li>
      <li>이를 for문을 통해 나타냈다. i가 x, j는 0부터 x-1까지 경우의 수를 모두 더하는데 사용한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>
<p>멀고도 험난한 DP의 세계🤯</p>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 94. Binary Tree Inorder Traversal</title>
	  <link>/blog//algo-leet94</link>
	  <author></author>
	  <pubDate>2020-09-27T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet94</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">https://leetcode.com/problems/binary-tree-inorder-traversal/</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>중위순회를 구현한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="cm">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">inorderTraversal</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">inorder</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">list</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">inorder</span><span class="o">(</span><span class="n">TreeNode</span> <span class="n">node</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">!=</span><span class="kc">null</span><span class="o">){</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
            <span class="n">inorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200927_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">중위순회를 구현한다</span></strong>
    <ul>
      <li>중위순회는 LVR(Left Visit Right)이다. 왼쪽 먼저 체크하고 노드를 체크한 후 오른쪽으로 넘어간다.</li>
      <li>참고로 전위순회는 VLR, 후위순회는 LRV이다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
