<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 56. Merge Intervals</title>
	  <link>/blog//algo-leet56</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet56</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/merge-intervals/">https://leetcode.com/problems/merge-intervals/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>boolean DP를 이용한다.</li>
  <li>방문한 곳(true)에서만 이동할 수 있는 범위를 체크한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{};</span>
        
        <span class="c1">// 배열 i기준 오름차순 정렬</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">i1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">i2</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i1</span><span class="o">[</span><span class="mi">0</span><span class="o">]&lt;</span><span class="n">i2</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i1</span><span class="o">[</span><span class="mi">0</span><span class="o">]==</span><span class="n">i2</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">end</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]&lt;=</span><span class="n">end</span><span class="o">){</span> <span class="c1">// 앞 배열과 구간이 겹친다면 두 개를 포함하는 더 큰 구간으로 변경</span>
                <span class="n">start</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">end</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span> <span class="c1">// 아니라면, 지금까지의 구간 list에 저장 후 start, end 갱신               </span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
                <span class="n">start</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">end</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="c1">// 마지막에 체크한 구간은 for문에서 삽입 안되므로 따로 추가</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
        
        <span class="c1">// ArrayList를 int[][]로 변환</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()][];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_8.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
compare()에 -1, 1인 경우로만 나누었더니 비교 기준이 모호하다고 오류났다. 그래서 같을 때인 0도 추가했다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">intervals를 오름차순 정렬한다</span></strong>
    <ul>
      <li>intervals는 이차원배열이므로 Comparator를 이용하여 compare()를 재정의해야한다.</li>
      <li>0번째 인덱스를 기준으로 오름차순 정렬한다. 1번째 인덱스는 0번째와 같거나 크기 때문에 굳이 1번째도 오름차순으로 정렬하지 않아도 된다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">중복되는 구간을 찾는다</span></strong>
    <ul>
      <li>start는 구간의 시작 지점, end는 끝나는 지점을 저장한다.</li>
      <li>0번째 인덱스는 시작 지점으로, 이 곳이 다른 배열의 구간에 들어간다면 두 배열은 중복되는 구간을 가지고 있는 것이다. 1번째 인덱스는 확인할 필요가 없다.</li>
      <li>구간이 중복된다면, intervals[i][0]이 start와 end 사이에 들어간다는 뜻이다.</li>
      <li>이 경우 start는 둘 중 더 작은 값, end는 둘 중 더 큰 값을 저장하여 두 구간을 모두 포함하도록 한다.</li>
      <li>포함되지 않는다면, 현재까지의 구간(start, end)를 list에 저장한다. 그리고 새 값으로 start와 end를 갱신한다.</li>
      <li>마지막 구간은 for문에서 삽입되지 않는다. 따라서 for문을 나온 후에 따로 list에 추가해야 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">int[][]형으로 변환 후 리턴한다</span></strong>
    <ul>
      <li>메소드의 리턴 형이 이차원배열이기 때문에, ArrayList에 저장한 값을 다시 형변환한 후 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 55. Jump Game</title>
	  <link>/blog//algo-leet55</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet55</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>boolean DP를 이용한다.</li>
  <li>방문한 곳(true)에서만 이동할 수 있는 범위를 체크한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 시작점이니까 방문</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문하지 않은 곳이면 패스</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// i에서 뛸 수 있는 범위 체크</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 뛸 수 있는 곳은 true</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> 
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_7.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
BFS로 시도했으나 또 시간초과나서 DP로 수정해서 풀었다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>boolean[] dp를 이용한다. dp[i]=true면 방문한 곳, false는 방문할 수 없는 곳이다.</li>
      <li>0에서 시작하므로 dp[0]=true이다.</li>
      <li>dp[i]=false는 방문할 수 없는 곳이므로 뛸 수 없다. 따라서 continue로 패스한다.</li>
      <li>i에서 뛸 수 있는 곳을 j로 체크한다. dp[i+j]는 갈 수 있는 곳이므로 true로 바꾼다.</li>
      <li>마지막 dp[n-1]이 true라면 도착할 수 있는 것이고, 아니면 없다는 뜻이다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 49. Group Anagrams</title>
	  <link>/blog//algo-leet49</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet49</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/group-anagrams/submissions/">https://leetcode.com/problems/group-anagrams/submissions/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>str를 오름차순으로 만들고, 해시맵에 넣어 같은 문자열이면 value에 넣는다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="nf">groupAnagrams</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">strs</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">();</span>
        
        <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">str:</span><span class="n">strs</span><span class="o">){</span>
            <span class="kt">char</span><span class="o">[]</span> <span class="n">array</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// 배열로 만들어서 오름차순 정렬하기 위함</span>
            <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">array</span><span class="o">);</span>
            <span class="n">String</span> <span class="n">key</span><span class="o">=</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">array</span><span class="o">);</span> <span class="c1">// 배열을 String으로 변환</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">());</span> <span class="c1">// 새로운 key면 리스트 생성</span>
            <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">str</span><span class="o">);</span> <span class="c1">// 해당 리스트에 str 추가</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="na">values</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_5.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">str를 오름차순 정렬한다</span></strong>
    <ul>
      <li>str를 오름차순 정렬하기 위해서는 Arrays.sort()를 쓰기 위해 배열로 만들어야 한다.</li>
      <li>String[]형으로 만들 경우, 다시 String으로 변환하기 위해 for문을 써야하므로, char[]로 배열을 만들고 String.valueOf()로 String으로 다시 변환한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">해시맵의 해당 key에 삽입한다</span></strong>
    <ul>
      <li>오름차순으로 만든 key가 map에 없다면, 새 리스트를 하나 만든다.</li>
      <li>map.get(key)로 value인 ArrayList를 가져오고, 거기에 add로 str를 넣는다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 48. Rotate Image</title>
	  <link>/blog//algo-leet48</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet48</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/rotate-image/">https://leetcode.com/problems/rotate-image/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>i 위치에서 건너뛸 수 있는 max를 구하고, 1~max까지 뛰어본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">matrix</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">matrix</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">top</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">down</span><span class="o">=</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(</span><span class="n">top</span><span class="o">&lt;</span><span class="n">down</span><span class="o">){</span> <span class="c1">// 위와 아래 행렬을 swap, 둘이 만날 때 까지 반복</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">temp</span><span class="o">=</span><span class="n">matrix</span><span class="o">[</span><span class="n">top</span><span class="o">];</span>
            <span class="n">matrix</span><span class="o">[</span><span class="n">top</span><span class="o">]=</span><span class="n">matrix</span><span class="o">[</span><span class="n">down</span><span class="o">];</span>
            <span class="n">matrix</span><span class="o">[</span><span class="n">down</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span>
            <span class="n">top</span><span class="o">++;</span>
            <span class="n">down</span><span class="o">--;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 대각선 기준 대칭 swap</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                <span class="n">matrix</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]=</span><span class="n">temp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_4.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">위와 아래 행렬을 swap</span></strong>
    <ul>
      <li>먼저 행렬의 위 아래를 swap한다.</li>
      <li>[[1,2,3],[4,5,6],[7,8,9]] -&gt; [[7,8,9],[4,5,6],[1,2,3]] 꼴로 바꿔준다.</li>
      <li>맨 위와 아래만 바꾸는 것이 아니라, 서로 좁혀가며 계속 바꾼다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">대각선 기준 대칭 swap</span></strong>
    <ul>
      <li>[[7,8,9],[4,5,6],[1,2,3]] -&gt; [[7,4,1],[8,5,2],[9,6,3]] 으로 바꾼다.</li>
      <li>i==j 인 대각선(y=-x) 을 기준으로 swap한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>
<p>어떻게 이런 생각을 할 수 있는건가요 세넓코잘많…………</p>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 46. Permutations</title>
	  <link>/blog//algo-leet46</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet46</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>i 위치에서 건너뛸 수 있는 max를 구하고, 1~max까지 뛰어본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
    <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visit</span><span class="o">;</span> <span class="c1">// 사용 여부 체크</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">permute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="n">visit</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;();</span>
        
        <span class="n">permutation</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(),</span> <span class="n">nums</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">permutation</span><span class="o">(</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="n">n</span><span class="o">){</span> <span class="c1">// 순열 생성 완료</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 사용한 숫자는 패스</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">permutation</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 재귀를 끝내고 다시 돌아온 후, 다음 사용을 위해 원상복구</span>
            <span class="n">visit</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_3.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">재귀를 이용해 순열을 구한다</span></strong>
    <ul>
      <li>순열은 순서를 고려한다.</li>
      <li>visit[] 배열을 둬서 숫자 사용 여부를 체크한다. 이를 통해 중복을 거른다.</li>
      <li>for문에서 0부터 n까지 숫자를 확인한다. visit[i]가 true면 사용한 숫자이므로 패스한다.</li>
      <li>사용하지 않은 숫자는 true로 바꾸고, list에 넣은 후 다시 permutation()을 재귀 호출한다. 이렇게 해서 n개의 숫자를 고른다.</li>
      <li>n개를 다 골랐으면 result에 넣는다. 이때 result.add(list)를 하면 리스트 내에 빈 값만 들어간다. 따라서 위와 같이 작성해야 한다(이유는 아직 이해가 안된다).</li>
      <li>재귀를 끝나고 재귀 호출 다음으로 돌아오면, 방금 넣었던 nums[i]를 지금 선택하지 않는 경우를 위해 list에서도 삭제, visit에서도 false로 바꾼다. 다음 사용을 위함이다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 45. Jump Game II</title>
	  <link>/blog//algo-leet45</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet45</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/jump-game-ii/">https://leetcode.com/problems/jump-game-ii/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>i 위치에서 건너뛸 수 있는 max를 구하고, 1~max까지 뛰어본다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">jump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dp</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// Math.min을 사용하기 위함</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// i 위치에서 다 체크</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// 1부터 nums[i]까지 뛰어본다, 단 배열 범위 벗어나지 않는 범위내에서</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// 기존 점프 횟수와 i에서 뛴 것 중 작은 값 선택</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
처음에는 BFS로 문제를 코드를 작성했는데, 특정 테케에서 시간 초과로 다른 사람의 코드를 참고했다. 뭔가 DP 느낌은 들었는데 점화식이 떠오르지 않았다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>nums 개수 만큼 dp를 만든다.</li>
      <li>Math.min()을 이용하여 둘 중 작은 값을 넣을 것이기 때문에 dp가 0으로 초기화 되어있으면 안된다. 따라서 Integer.MAX_VALUE로 min을 통해 값이 무조건 변경되도록 한다.</li>
      <li>i는 dp에서 확인할 위치이다.</li>
      <li>j는 i에서 1부터 nums[i]번 만큼 뛸 수 있는 경우다. 예를 들어 [2,3,1,1,4]에서 0번째 인덱스에서는 1부터 2까지 뛸 수 있다.</li>
      <li>따라서 j는 1부터 nums[i]만큼 뛰어보는데, 이때 i+j가 배열 범위를 벗어나면 안된다.</li>
      <li>dp[i+j]는 i위치에서 j만큼 뛴 곳이다. 이곳의 값은 기존 dp[i+j]를 유지하거나, i에서 j만큼 뛰어 해당 위치에 가는 두 방법이 있다. 따라서 dp[i]+1과 기존 dp[i+j] 중 작은 값을 택한다.</li>
      <li>dp[마지막 위치]에는 인덱스 0부터 뛴 경우를 다 체크하고 min값이 들어갈 것이므로, 해당 값을 리턴하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 42. Trapping Rain Water</title>
	  <link>/blog//algo-leet42</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet42</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">https://leetcode.com/problems/trapping-rain-water/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>i 위치에서 왼쪽, 오른쪽으로 max 높이를 구한다.</li>
  <li>둘 중 작은 값-내 높이 가 i에서 물의 영역이다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">trap</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">left</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">right</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        
        <span class="c1">// 왼쪽으로 max 높이 저장</span>
        <span class="n">left</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">height</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> 
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        <span class="c1">// 오른쪽</span>
        <span class="n">right</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]=</span><span class="n">height</span><span class="o">[</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">2</span><span class="o">;</span><span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">--){</span>
            <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="c1">// 물 영역 계산</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">height</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">answer</span><span class="o">+=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">right</span><span class="o">[</span><span class="n">i</span><span class="o">])-</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_1.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>i 위치에서 물 영역을 계산하려면 왼쪽 오른쪽에서 경계를 찾아야 한다. DP를 사용하지 않고 Brute Force로 진행하면 i위치에 따른 left, right max 높이를 계속 구해야 한다. 이 값은 변하는 것이 아니기 때문에 dp에 넣고 한 번만 체크하는 것이 더 시간을 단축시킨다.</li>
      <li>left[i]는 i 기준 왼쪽에서 가장 큰 높이를 저장한다.</li>
      <li>이전까지의 최대 높이(left[i-1])와 현재 내 높이(height[i]) 중 큰 값을 left[i]에 저장한다.</li>
      <li>right도 같다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">물을 계산한다</span></strong>
    <ul>
      <li>water[i]=min(left[i], right[i])-height[i]이다.</li>
      <li>왼쪽, 오른쪽 최대 높이에서 작은 높이까지만 물을 담을 수 있으므로 min을 통해 둘 중 하나를 선택한다.</li>
      <li>내 높이까지는 물을 채울 수 없으므로 height[i]를 뺀다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 53. Maximum Subarray</title>
	  <link>/blog//algo-leet53</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet53</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>누적합에 i값을 더할 지, 아니면 i값에서부터 다시 시작할 지 둘 중 max로 결정한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">long</span> <span class="n">answer</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// dp에서 최댓값을 저장</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// i를 더하거나, i에서 다시 시작하거나</span>
            <span class="n">answer</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">dp</span><span class="o">));</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_6.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
answer을 dp[0]이 아닌 Integer.MIN으로 초기화해서 실패했다. [-1,-2]인 경우 answer에 -1이 들어가지 않기 때문이다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp[i]=Math.max(dp[i-1]+nums[i], nums[i])</li>
      <li>dp[i]: i번째까지의 누적 합</li>
      <li>이전 합에서 nums[i]를 더한 것과, nums[i] 자체 중 더 큰 값을 설정한다. nums[i]를 선택하게 되면, i부터 누적합을 다시 구하는 것이다.</li>
      <li>dp 마지막 인덱스에 누적 값의 최댓값이 들어온다는 보장은 없으므로, answer을 두어 dp의 최댓값을 저장한다.</li>
      <li>nums[i]의 범위가 int형 범위와 같고, 합을 구하는 문제이기 때문에 오버플로우를 생각하여 dp를 long형으로 선언했다.</li>
      <li>근데 문제는 여기까지 의도한게 맞는건지 모르겠지만, 리턴형이 int여서 마지막에 answer를 int로 형변환하였다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 41. First Missing Positive</title>
	  <link>/blog//algo-leet41</link>
	  <author></author>
	  <pubDate>2020-09-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet41</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/first-missing-positive/submissions/">https://leetcode.com/problems/first-missing-positive/submissions/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>숫자 개수+1개의 boolean 배열을 만든다.</li>
  <li>인덱스를 숫자로 생각하고, 해당 숫자가 존재하면 true를 저장한다.</li>
  <li>인덱스 1부터 순회하며 false인 인덱스를 리턴한다.</li>
  <li>모두 true라면 마지막 숫자+1을 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">firstMissingPositive</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">number</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="nl">num:</span><span class="n">nums</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span><span class="o">&lt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">num</span><span class="o">&gt;</span><span class="n">size</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 음수거나 배열 범위를 벗어나는 숫자는 패스</span>
            <span class="n">number</span><span class="o">[</span><span class="n">num</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">size</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">number</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">return</span> <span class="n">i</span><span class="o">;</span> <span class="c1">// 없는 숫자를 리턴</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 숫자가 다 존재한다면 마지막 숫자 다음을 리턴</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200924_5.PNG" alt="실행결과" />
성공٩(˘◊˘)۶<br />
처음에는 오름차순 정렬 후, 앞에서부터 체크하며 +1이 아니면 없는 값을 리턴하게 했는데, 예외가 많아서 다른 사람의 코드를 참고했다.<br />
배열에 중복값이 있을 수도 있다는 것을 생각해야 한다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">boolean 배열을 만든다</span></strong>
    <ul>
      <li>배열은 1부터 nums 개수만큼 사용한다. 따라서 nums.length+1이다.</li>
      <li>인덱스를 숫자라고 가정하고, 배열에 해당 숫자가 있으면 true로 바꾼다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">boolean 배열을 체크하며 없는 숫자를 찾는다</span></strong>
    <ul>
      <li>0은 사용하지 않으므로 패스한다.</li>
      <li>false인 값이 나오면, 해당 인덱스를 리턴한다.</li>
      <li>[2,3,4]인 경우 boolean 배열에는 숫자 1,2,3을 저장할 수 있는데, 1 자리에 false이므로 바로 1을 리턴한다.</li>
      <li>[1,3,4]인 경우, boolean 배열에는 1,2,3을 저장할 수 있는데, 2가 false이므로 2를 리턴한다.</li>
      <li>[1,2]인 경우에는 boolean에 1,2를 저장할 수 있고, 둘 다 true가 들어가므로 for문에서 리턴하지 않는다. 마지막 줄에서 2(배열 사이즈)+1로 다음 숫자 3을 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 39. Combination Sum</title>
	  <link>/blog//algo-leet39</link>
	  <author></author>
	  <pubDate>2020-09-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet39</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>이분탐색을 이용해 target을 하나 찾는다.</li>
  <li>만약 target을 찾지 못한다면 {-1,-1}을 리턴한다.</li>
  <li>target이 있다면, 그곳을 기준으로 left, right를 두고 target이 아닌 값을 만날 때 까지 움직인다.</li>
  <li>left의 최소, right의 최대를 리턴한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">set</span><span class="o">;</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">c</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">t</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">combinationSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">set</span><span class="o">=</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">candidates</span><span class="o">);</span>
        <span class="n">c</span><span class="o">=</span><span class="n">candidates</span><span class="o">;</span>
        <span class="n">t</span><span class="o">=</span><span class="n">target</span><span class="o">;</span>
        
        <span class="n">combination</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
        
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="o">(</span><span class="n">set</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">combination</span><span class="o">(</span><span class="kt">int</span> <span class="n">sum</span><span class="o">,</span> <span class="n">String</span> <span class="n">str</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">==</span><span class="n">t</span><span class="o">){</span> <span class="c1">// sum 완성</span>
            <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
            <span class="n">String</span><span class="o">[]</span> <span class="n">array</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="n">String</span> <span class="nl">s:</span><span class="n">array</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 생성한 str를 list 형태로 변환</span>
                <span class="k">if</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">""</span><span class="o">))</span> <span class="k">continue</span><span class="o">;</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">list</span><span class="o">);</span> 
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">c</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 조합 찾기</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span><span class="o">+</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]&gt;</span><span class="n">t</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> <span class="c1">// t보다 크면 다음은 볼 필요도 없으므로 종료</span>
            
            <span class="n">combination</span><span class="o">(</span><span class="n">sum</span><span class="o">+</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">str</span><span class="o">+</span><span class="n">c</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200924_4.PNG" alt="실행결과" />
성공٩(˘◊˘)۶<br />
그닥 좋은 코드는 아닌듯😭 i가 무조건 0부터 체크하고, str를 다시 list로 바꾸고, 오름차순 정렬하는 데에서 시간이 소요되는 것 같다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">모든 조합을 다 찾는다</span></strong>
    <ul>
      <li>이때 숫자는 중복으로 쓸 수 있으므로 파라미터로 시작 인덱스를 넘기지 않고 무조건 0부터 순회하게 했다(다른 사람들의 풀이를 보니 사용한 i를 다시 start로 넘겨 중복으로 쓸 수 있게 했다. 이게 더 나은 듯).</li>
      <li>현재까지의 합계 sum에 넣을 값 c[i]가 t를 넘는다면 다음 숫자들은 볼 필요도 없으므로 return한다(이를 위해 c를 오름차순 정렬한 후 사용했다).</li>
      <li>숫자 생성에 성공하면 지금까지 만든 str를 list형태로 변환하고, set에 넣어 중복을 거른다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
