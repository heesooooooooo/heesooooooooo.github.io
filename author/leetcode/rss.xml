<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>PS & 개발 기록</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 78. Subsets</title>
	  <link>/blog//algo-leet78</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet78</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>조합을 구하면 된다. 이때 길이가 0~nums.length까지 모두 구한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="o">;</span>
    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">subsets</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 조합 길이 지정</span>
            <span class="n">combination</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;(),</span> <span class="n">nums</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">combination</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()==</span><span class="n">n</span><span class="o">){</span> <span class="c1">// 조합 생성 완료</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">list</span><span class="o">));</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 조합 생성</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// i를 선택하고 재귀 호출</span>
            <span class="n">combination</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">list</span><span class="o">,</span> <span class="n">nums</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// i를 선택하지 않는 경우</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_6.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">조합을 만든다</span></strong>
    <ul>
      <li>Output에는 길이가 0부터 nums.length까지 조합을 찾으면 된다.</li>
      <li>for문 i를 0~nums.length로 하여 길이를 지정한 후, combination()을 호출한다.</li>
      <li>combination()의 파라미터 start는 탐색을 시작할 인덱스, n은 만들 조합의 길이, list는 선택된 값을 저장하는 변수이다.</li>
      <li>조합 생성을 위해 for문에서 i를 0부터 설정하면 중복이 허용되므로 start로 시작점을 줘야 한다.</li>
      <li>nums[i]를 선택하면, 그 다음 확인해야할 인덱스를 start로 넘겨서 재귀를 호출한다.</li>
      <li>재귀가 끝나고 돌아오면 list에서 i를 지워 i를 선택하지 않는 경우를 탐색한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 75. Sort Colors</title>
	  <link>/blog//algo-leet75</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet75</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/sort-colors/">https://leetcode.com/problems/sort-colors/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>zero, one, two 인덱스를 두고 0이면 two, one, zero, 1은 two, one, 2는 two 순으로 값을 갱신한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">sortColors</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">zero</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">one</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 해당 값으로 채운 마지막 인덱스</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">0</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">two</span><span class="o">++]=</span><span class="mi">2</span><span class="o">;</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">one</span><span class="o">++]=</span><span class="mi">1</span><span class="o">;</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">zero</span><span class="o">++]=</span><span class="mi">0</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span><span class="mi">1</span><span class="o">){</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">two</span><span class="o">++]=</span><span class="mi">2</span><span class="o">;</span>
                <span class="n">nums</span><span class="o">[</span><span class="n">one</span><span class="o">++]=</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">nums</span><span class="o">[</span><span class="n">two</span><span class="o">++]=</span><span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_5.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
어떻게 이런 생각을 하는거지요… 아무 생각없이 Arrays.sort()썼다가, 라이브러리를 쓰지 말고 one pass에 공간복잡도 O(1)인 코드를 만들어라길래 다른 코드를 참고했다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">각 마지막 인덱스를 활용한다</span></strong>
    <ul>
      <li>zero, one, two는 각 숫자의 마지막 인덱스이다. nums[] 배열을 새로운 값으로 바꾸는 중에 특정 시점의 0, 1, 2의 마지막 인덱스와 같다.</li>
      <li>같은 배열안에서 값을 바꾸면 원래 값이 손실되는 경우가 있을 것 같았는데, zero, one, two 갱신 순서를 통해 이를 해결했다.</li>
      <li>예를 들어 0이면 two, one, zero 순으로 값을 바꿔서 뒤에서부터 값이 밀리게 하여 손실을 없앴다. 앞에서부터 밀면 뒤에 값이 사라진다.</li>
      <li>0이면 two, one, zero를 다 밀어야 한다. 1이면 two, one만 밀면 되고, 2이면 two 하나만 밀면 된다.</li>
      <li>각 변수는 현재 해당 숫자를 넣을 위치로, ++을 통해 다음 사용을 염두했다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 72. Edit Distance</title>
	  <link>/blog//algo-leet72</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet72</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/edit-distance/">https://leetcode.com/problems/edit-distance/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minDistance</span><span class="o">(</span><span class="n">String</span> <span class="n">word1</span><span class="o">,</span> <span class="n">String</span> <span class="n">word2</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">word1</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">word2</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 초기화</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">j</span><span class="o">;</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="c1">// i, j 문자가 같으면 변경 필요 없음</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word1</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">)==</span><span class="n">word2</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                <span class="k">else</span><span class="o">{</span> <span class="c1">// 다른 경우</span>
                    <span class="kt">int</span> <span class="n">insert</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">delete</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="kt">int</span> <span class="n">replace</span><span class="o">=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">insert</span><span class="o">,</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">delete</span><span class="o">,</span> <span class="n">replace</span><span class="o">))+</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 셋 중 가장 작은 값+1(이번에 수행한 것)  </span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_4.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>word1는 i, word2는 j로 문자를 체크한다.</li>
      <li>dp[i][j]: word1의 i번째, word2의 j번째를 바꿀 때, 최소 횟수(이전까지의 횟수에 누적)</li>
      <li>i, j는 1부터 시작한다. 따라서 charAt()을 쓸 때는 -1해야한다.</li>
      <li>빈 문자열과 word를 비교할 수도 있으므로 m+1, n+1로 배열을 선언하여 0~m 또는 n까지 체크할 수 있게 하였다.</li>
      <li>i==0 또는 j==0인 곳은 해당 word와 빈 문자열을 비교하는 것과 같다. 따라서 내 word와 같게 계속 삽입하면 되므로 그 횟수로 초기화한다.</li>
      <li>i와 j를 변경하는 세 가지 방법 insert, delete, replace 중, 처음부터 현재 i, j까지를 고려했을 때, 가장 적은 횟수가 드는 것을 선택하고, 여기에 지금 수행한 것(셋 중 하나)를 +1한다.</li>
      <li>insert: i 자리에 알파벳을 추가하므로, j는 i+1에서 체크한다. 다시말하면 j-1과 i를 체크하는 것과 같으므로 dp[i][j-1]이다.</li>
      <li>delete: i를 삭제하는 것이므로 j는 i+1와 비교한다. 즉, j-1과 i를 비교하는 것과 같으므로 dp[i][j-1].</li>
      <li>replace: i를 j로 바꾸는 것이므로 이전의 i-1, j-1을 그대로 가져오면 된다. dp[i-1][j-1].</li>
      <li>셋 중 가장 작은 값을 Math.min()을 두 번 사용함으로써 뽑고, 여기에 현재 수행한 횟수 1을 더한다.</li>
      <li>마지막 dp[m][n]에 최종으로 min 값이 들어있다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 70. Climbing Stairs</title>
	  <link>/blog//algo-leet70</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet70</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/climbing-stairs/">https://leetcode.com/problems/climbing-stairs/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">climbStairs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">)</span> <span class="k">return</span> <span class="n">n</span><span class="o">;</span>
        
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">1</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">2</span><span class="o">]=</span><span class="mi">2</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">];</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_3.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>이렇게 노가다를 해야할 것 같은 문제는 일단 1부터 개수를 세면서 규칙을 찾아본다.</li>
      <li>규칙이 있다면 DP를 쓰면 된다.</li>
      <li>(input, answer)이라 할 때, (1,1), (2,2), (3,3), (4,5), (5,8), (6,13), (7,21) …</li>
      <li>3번째 부터는 이전 두 값의 합이 answer이라는 것을 알 수 있다.</li>
      <li>따라서, dp[i]=dp[i-1]+dp[i-2]</li>
      <li>input이 1,2,3이면 answer==input이므로 dp를 따로 생성하지 않고 처음 if문을 통해 값을 리턴하게 했다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 64. Minimum Path Sum</title>
	  <link>/blog//algo-leet64</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet64</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/minimum-path-sum/">https://leetcode.com/problems/minimum-path-sum/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>dp[i][j]는 (i,j)에서 최솟값으로, 왼쪽이나 위에서 작은 값을 선택하고, 내 값을 더한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">minPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">grid</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="n">grid</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// 시작점 초기화</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 시작점은 패스</span>
                <span class="c1">// 왼쪽, 위쪽이 둘 다 존재한다면 둘 중 작은 값 선택</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">])+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// 위쪽만 있다면(i==0)</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                <span class="c1">// 왼쪽만 있다면(j==0)</span>
                <span class="k">else</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="n">grid</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_2.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
DFS로 하고 싶었지만 참았다</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>m, n의 범위를 알려주지 않아서 왠만큼 큰 숫자여도 풀 수 있어야 할 것 같았다. 그래서 DFS는 아니라고 생각했다.</li>
      <li>모든 경우를 다 따지는 것이 아니라면, 이런 문제는 보통 DP로 풀 수 있다. 따라서 점화식을 어떻게 짤지 생각했다.</li>
      <li>오른쪽, 아래쪽으로만 이동할 수 있기 때문에 (i,j)에 가기 위해서는 전의 위치가 (i-1,j)이거나 (i,j-1)이어야 한다.</li>
      <li>이때 합이 최소가 되도록 움직여야 하므로, 이전 값이 작은 것이 좋다.</li>
      <li>따라서 이전 위치에서 작은 값+내 값이 된다.</li>
      <li>이를 점화식으로 만들면, dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j]</li>
      <li>이때 i-1, j-1의 인덱스 범위를 생각해야하므로 if, else if, else문으로 경우에 따라 더할 값을 처리하였다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 62. Unique Paths</title>
	  <link>/blog//algo-leet62</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet62</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>시작점 행, 열을 1로 초기화하고 앞의 두 값을 더해가며 Finish까지 간다(초딩때 배운 길찾기 경우의수 사용).</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">uniquePaths</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="mi">1</span><span class="o">);</span> <span class="c1">// 0행 1로 초기화</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]=</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 0열 1로 초기화</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span> <span class="c1">// 값 계산</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]=</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 왼쪽과 위쪽을 더함</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        
        <span class="k">return</span> <span class="n">map</span><span class="o">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_1.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
처음에는 DFS로 시도했었는데, m=23, n=12에서 시간 초과가 걸렸다. DFS, BFS는 숫자가 아주 작을 때만 사용해야겠다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">배열에 합을 누적하며 Finish의 값을 찾는다</span></strong>
    <ul>
      <li>Start의 0행, 0열을 1로 초기화하고, 나머지 값은 내 왼쪽+내 위쪽을 더한 값을 저장한다.</li>
      <li>m=3, n=7이면 배열은 [[1,1,1,1,1,1,1],[1,2,3,4,5,6,7],[1,3,6,10,15,21,28]]이 되고 마지막 map[m-1][n-1]의 값을 리턴하면 된다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 79. Word Search</title>
	  <link>/blog//algo-leet79</link>
	  <author></author>
	  <pubDate>2020-09-26T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet79</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/word-search/">https://leetcode.com/problems/word-search/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DFS를 이용한다.</li>
  <li>시작 지점을 찾고, 거기서 DFS를 돌린다. 만족하면 종료, 아니라면 다른 시작점이 있는지 찾는다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">m</span><span class="o">,</span><span class="n">n</span><span class="o">,</span><span class="n">w</span><span class="o">;</span>
    <span class="kt">char</span><span class="o">[]</span> <span class="n">array</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">exist</span><span class="o">(</span><span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">,</span> <span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">m</span><span class="o">=</span><span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="c1">// 행</span>
        <span class="n">n</span><span class="o">=</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="c1">// 열</span>
        <span class="n">w</span><span class="o">=</span><span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="c1">// 문자열 길이</span>
        
        <span class="n">array</span><span class="o">=</span><span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span> <span class="c1">// word를 문자 하나하나 쪼개기</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span>
                <span class="c1">// 시작점을 찾았고, 거기서 DFS한 결과가 참이면</span>
                <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">]==</span><span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">],</span> <span class="n">board</span><span class="o">))</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>    
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visit</span><span class="o">,</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">board</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span><span class="o">==</span><span class="n">w</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// word 찾기 완료</span>
        
        <span class="c1">// 배열을 벗어나거나, 방문한 곳이거나, 찾는 문자가 아니라면</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">x</span><span class="o">&gt;=</span><span class="n">m</span> <span class="o">||</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">y</span><span class="o">&gt;=</span><span class="n">n</span> <span class="o">||</span> <span class="n">visit</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">||</span> <span class="n">board</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]!=</span><span class="n">array</span><span class="o">[</span><span class="n">idx</span><span class="o">])</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> 
        
        <span class="c1">// idx번째 문자가 일치</span>
        <span class="n">visit</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 사용</span>
        <span class="c1">// 현재 위치에서 갈 수 있는 경우 다 체크</span>
        <span class="kt">boolean</span> <span class="n">up</span><span class="o">=</span><span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">visit</span><span class="o">,</span> <span class="n">board</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">down</span><span class="o">=</span><span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">visit</span><span class="o">,</span> <span class="n">board</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">left</span><span class="o">=</span><span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">visit</span><span class="o">,</span> <span class="n">board</span><span class="o">);</span>
        <span class="kt">boolean</span> <span class="n">right</span><span class="o">=</span><span class="n">dfs</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">visit</span><span class="o">,</span> <span class="n">board</span><span class="o">);</span>
        
        <span class="c1">// 하나라도 true면 true</span>
        <span class="k">if</span><span class="o">(</span><span class="n">up</span> <span class="o">||</span> <span class="n">down</span> <span class="o">||</span> <span class="n">left</span> <span class="o">||</span> <span class="n">right</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        
        <span class="n">visit</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]=</span><span class="kc">false</span><span class="o">;</span> <span class="c1">// (x,y)를 사용하지 않는 경우를 위함</span>
        
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200926_7.PNG" alt="실행결과" />
성공٩(˘◊˘)۶</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">시작 지점을 찾는다</span></strong>
    <ul>
      <li>board에서 시작 지점을 찾는다. 거기서부터 DFS를 시작한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">DFS를 이용한다</span></strong>
    <ul>
      <li>일단 특정 위치에서 다음으로 타고타고 넘어가는 문제는 보통 DFS이다. 거기다가 상하좌우로 움직이는 거면 많이 익숙쓰</li>
      <li>파라미터 x, y는 현재 내 위치, idx는 word(String 체크를 편하게 하기 위해서 char 배열로 바꿨다)에서 체크할 곳, visit는 원소 방문여부 저장하는 배열이다.</li>
      <li>dfs()로 word를 체크한다. idx==w이면 문자열 체크가 무사히 끝났다는 것이므로 true를 리턴한다.</li>
      <li>현재 위치 (x,y)까지는 word의 idx까지의 문자가 일치한다는 것이다. 따라서 지금 위치에서 상하좌우 중에 다음 문자와 일치하는 곳이 있는지 체크한다.</li>
      <li>넷 중 하나라도 true이면 된다.</li>
      <li>위에까지는 (x,y)를 사용한다는 가정 하에 진행한 것이다. (x,y)를 사용하지 않고 그냥 넘어갈 수도 있으므로, visit[x][y]=false로 처리하여 이 경우를 체크한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 53. Maximum Subarray</title>
	  <link>/blog//algo-leet53</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet53</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>DP를 이용한다.</li>
  <li>누적합에 i값을 더할 지, 아니면 i값에서부터 다시 시작할 지 둘 중 max로 결정한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">maxSubArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="kt">long</span> <span class="n">answer</span><span class="o">=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span> <span class="c1">// dp에서 최댓값을 저장</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span> <span class="c1">// i를 더하거나, i에서 다시 시작하거나</span>
            <span class="n">answer</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>
        
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">dp</span><span class="o">));</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_6.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
answer을 dp[0]이 아닌 Integer.MIN으로 초기화해서 실패했다. [-1,-2]인 경우 answer에 -1이 들어가지 않기 때문이다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>dp[i]=Math.max(dp[i-1]+nums[i], nums[i])</li>
      <li>dp[i]: i번째까지의 누적 합</li>
      <li>이전 합에서 nums[i]를 더한 것과, nums[i] 자체 중 더 큰 값을 설정한다. nums[i]를 선택하게 되면, i부터 누적합을 다시 구하는 것이다.</li>
      <li>dp 마지막 인덱스에 누적 값의 최댓값이 들어온다는 보장은 없으므로, answer을 두어 dp의 최댓값을 저장한다.</li>
      <li>nums[i]의 범위가 int형 범위와 같고, 합을 구하는 문제이기 때문에 오버플로우를 생각하여 dp를 long형으로 선언했다.</li>
      <li>근데 문제는 여기까지 의도한게 맞는건지 모르겠지만, 리턴형이 int여서 마지막에 answer를 int로 형변환하였다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 56. Merge Intervals</title>
	  <link>/blog//algo-leet56</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet56</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/merge-intervals/">https://leetcode.com/problems/merge-intervals/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>boolean DP를 이용한다.</li>
  <li>방문한 곳(true)에서만 이동할 수 있는 범위를 체크한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">intervals</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{};</span>
        
        <span class="c1">// 배열 i기준 오름차순 정렬</span>
        <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">intervals</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;(){</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">i1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">i2</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i1</span><span class="o">[</span><span class="mi">0</span><span class="o">]&lt;</span><span class="n">i2</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">i1</span><span class="o">[</span><span class="mi">0</span><span class="o">]==</span><span class="n">i2</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">else</span> <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="kt">int</span> <span class="n">start</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="n">end</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">intervals</span><span class="o">.</span><span class="na">length</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">start</span><span class="o">&lt;=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]&lt;=</span><span class="n">end</span><span class="o">){</span> <span class="c1">// 앞 배열과 구간이 겹친다면 두 개를 포함하는 더 큰 구간으로 변경</span>
                <span class="n">start</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]);</span>
                <span class="n">end</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">else</span><span class="o">{</span> <span class="c1">// 아니라면, 지금까지의 구간 list에 저장 후 start, end 갱신               </span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
                <span class="n">start</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="n">end</span><span class="o">=</span><span class="n">intervals</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="c1">// 마지막에 체크한 구간은 for문에서 삽입 안되므로 따로 추가</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">});</span>
        
        <span class="c1">// ArrayList를 int[][]로 변환</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()][];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span><span class="n">i</span><span class="o">++){</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_8.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
compare()에 -1, 1인 경우로만 나누었더니 비교 기준이 모호하다고 오류났다. 그래서 같을 때인 0도 추가했다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">intervals를 오름차순 정렬한다</span></strong>
    <ul>
      <li>intervals는 이차원배열이므로 Comparator를 이용하여 compare()를 재정의해야한다.</li>
      <li>0번째 인덱스를 기준으로 오름차순 정렬한다. 1번째 인덱스는 0번째와 같거나 크기 때문에 굳이 1번째도 오름차순으로 정렬하지 않아도 된다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">중복되는 구간을 찾는다</span></strong>
    <ul>
      <li>start는 구간의 시작 지점, end는 끝나는 지점을 저장한다.</li>
      <li>0번째 인덱스는 시작 지점으로, 이 곳이 다른 배열의 구간에 들어간다면 두 배열은 중복되는 구간을 가지고 있는 것이다. 1번째 인덱스는 확인할 필요가 없다.</li>
      <li>구간이 중복된다면, intervals[i][0]이 start와 end 사이에 들어간다는 뜻이다.</li>
      <li>이 경우 start는 둘 중 더 작은 값, end는 둘 중 더 큰 값을 저장하여 두 구간을 모두 포함하도록 한다.</li>
      <li>포함되지 않는다면, 현재까지의 구간(start, end)를 list에 저장한다. 그리고 새 값으로 start와 end를 갱신한다.</li>
      <li>마지막 구간은 for문에서 삽입되지 않는다. 따라서 for문을 나온 후에 따로 list에 추가해야 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">int[][]형으로 변환 후 리턴한다</span></strong>
    <ul>
      <li>메소드의 리턴 형이 이차원배열이기 때문에, ArrayList에 저장한 값을 다시 형변환한 후 리턴한다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/LeetCode] Top 100 Liked Question: 55. Jump Game</title>
	  <link>/blog//algo-leet55</link>
	  <author></author>
	  <pubDate>2020-09-25T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-leet55</guid>
	  <description><![CDATA[
	     <h2 id="문제"><span style="color:navy">문제</span></h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">https://leetcode.com/problems/maximum-subarray/</a></p>

<h2 id="-ᐛ-و-도전"><span style="color:navy">( ᐛ )و 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>boolean DP를 이용한다.</li>
  <li>방문한 곳(true)에서만 이동할 수 있는 범위를 체크한다.</li>
</ol>

<h3 id="2-구현">2. 구현</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="cm">/**
 *
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">canJump</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">dp</span><span class="o">=</span><span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
        <span class="n">dp</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 시작점이니까 방문</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">++){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 방문하지 않은 곳이면 패스</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">j</span><span class="o">++){</span> <span class="c1">// i에서 뛸 수 있는 범위 체크</span>
                <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">]=</span><span class="kc">true</span><span class="o">;</span> <span class="c1">// 뛸 수 있는 곳은 true</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span> 
    <span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/200925_7.PNG" alt="실행결과" />
성공٩(˘◊˘)۶ <br />
BFS로 시도했으나 또 시간초과나서 DP로 수정해서 풀었다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">DP를 이용한다</span></strong>
    <ul>
      <li>boolean[] dp를 이용한다. dp[i]=true면 방문한 곳, false는 방문할 수 없는 곳이다.</li>
      <li>0에서 시작하므로 dp[0]=true이다.</li>
      <li>dp[i]=false는 방문할 수 없는 곳이므로 뛸 수 없다. 따라서 continue로 패스한다.</li>
      <li>i에서 뛸 수 있는 곳을 j로 체크한다. dp[i+j]는 갈 수 있는 곳이므로 true로 바꾼다.</li>
      <li>마지막 dp[n-1]이 true라면 도착할 수 있는 것이고, 아니면 없다는 뜻이다.</li>
    </ul>
  </li>
</ol>

<h2 id="해결-완료"><span style="color:navy">해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
