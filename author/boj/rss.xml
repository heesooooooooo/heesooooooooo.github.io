<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>iamheesoo.github.io/blog/</title>
   
   <link>http://localhost:4000</link>
   <description>세넓코잘많</description>
   <language>utf-8</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[JAVA/백준] 1918번: 후위 표기식</title>
	  <link>/blog//algo-boj1918</link>
	  <author></author>
	  <pubDate>2020-11-07T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1918</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1918">https://www.acmicpc.net/problem/1918</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>알파벳은 출력, 문자열은 스택에 넣고 비교한다.</li>
  <li>’(‘는 스택에 그냥 삽입, ‘)’는 여는 괄호가 나올 때까지 pop한다.</li>
  <li>+,-,*,/ 연산자는 우선순위를 비교하여 넣는다.</li>
  <li>현재 연산자가 top보다 커야지 넣을 수 있다.</li>
  <li>같거나 작은 경우에는 3번이 만족할 때까지 pop한다.</li>
  <li>for문 종료 후 스택에 남아있는 값들을 모두 pop한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
		<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">&gt;</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
		
		<span class="c1">// 연산자별 우선순위 저장</span>
		<span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Character</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'+'</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'-'</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'*'</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
		<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'/'</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="c1">// 알파벳은 바로 출력</span>
			<span class="k">if</span><span class="o">(</span><span class="sc">'A'</span><span class="o">&lt;=</span><span class="n">ch</span> <span class="o">&amp;&amp;</span> <span class="n">ch</span><span class="o">&lt;=</span><span class="sc">'Z'</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
			<span class="k">else</span> <span class="o">{</span>
				<span class="k">switch</span><span class="o">(</span><span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">case</span> <span class="sc">'('</span><span class="o">:</span>
					<span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
					<span class="k">break</span><span class="o">;</span>
				<span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
					<span class="c1">// 여는 괄호가 나올 때까지 출력</span>
					<span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()!=</span><span class="sc">'('</span><span class="o">)</span>
						<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
					<span class="c1">// 여는 괄호 pop</span>
					<span class="k">if</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()==</span><span class="sc">'('</span><span class="o">)</span> <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
					<span class="k">break</span><span class="o">;</span>
				<span class="k">default</span><span class="o">:</span> <span class="c1">// 연산자</span>
					<span class="c1">// top우선순위 &lt; ch우선순위여야 push 가능</span>
					<span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">())&gt;=</span><span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ch</span><span class="o">))</span>
						<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
					<span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">ch</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="c1">// 남은 연산자들 모두 출력</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">());</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
		
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201107_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">스택에는 연산자만 저장한다</span></strong>
    <ul>
      <li>’(‘ : 그냥 push</li>
      <li>’)’ : ‘(‘ 나올 때까지 pop, 닫는 괄호는 스택에 저장하지 않는다.</li>
      <li>나머지 연산자들은 top보다 내 우선순위가 커야 push할 수 있다.</li>
      <li>위 조건을 만족할 때까지 pop한다.</li>
      <li>연산자의 우선순위를 알기 위해 HashMap에 넣어 사용하였다.</li>
      <li>for문 종료 후 스택에 남은 값들을 모두 pop한다.</li>
    </ul>
  </li>
</ol>

<h3 id="5-성능">5. 성능</h3>
<ul>
  <li>시간 복잡도: O(N)</li>
  <li>공간 복잡도: O(N)</li>
</ul>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>백준 1918 후위 표기식 Java <a href="https://dundung.tistory.com/133">https://dundung.tistory.com/133</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1655번: 가운데를 말해요</title>
	  <link>/blog//algo-boj1655</link>
	  <author></author>
	  <pubDate>2020-11-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1655</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1655">https://www.acmicpc.net/problem/1655</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>실시간으로 입력된 데이터를 정렬하는 자료구조-&gt;힙(Heap)을 사용한다.</li>
  <li>maxHeap(내림차순), minHeap(오름차순)을 이용한다.</li>
  <li>두 개를 이용해 정렬된 숫자 배열을 만들 것이다. maxHeap의 리프노드-&gt;maxHeap root-&gt;minHeap root-&gt;minHeap 리프 노드 순으로 가면 정렬된 숫자 배열을 얻을 수 있다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		
		<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">maxHeap</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Integer</span> <span class="n">i1</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">i2</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">return</span> <span class="n">i2</span><span class="o">-</span><span class="n">i1</span><span class="o">;</span>
			<span class="o">}</span>
		<span class="o">});</span> <span class="c1">// 내림차순</span>
		<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">minHeap</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)-&gt;</span><span class="n">o1</span><span class="o">-</span><span class="n">o2</span><span class="o">);</span> <span class="c1">// 오름차순</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="c1">// num을 번갈아가면서 힙에 넣어줌</span>
			<span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
			<span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="n">maxHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
			<span class="k">else</span> <span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
			
			<span class="c1">// maxHeap의 root&lt;minHeap root이어야 함</span>
			<span class="k">if</span><span class="o">(!</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">minHeap</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="k">if</span><span class="o">(</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">()&gt;</span><span class="n">minHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">())</span> <span class="o">{</span>
					<span class="kt">int</span> <span class="n">maxRoot</span><span class="o">=</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
					<span class="n">maxHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">minHeap</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span>
					<span class="n">minHeap</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">maxRoot</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
			
			<span class="c1">// maxHeap의 root에 숫자 배열의 중간값이 들어감</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">maxHeap</span><span class="o">.</span><span class="na">peek</span><span class="o">());</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201105_1.PNG" alt="실행결과" />
🤟 성공 🤟<br />
처음에는 단순하게 리스트를 정렬하고 중간 인덱스를 뽑는 방식으로 작성했는데 시간 초과가 떴다.<br />
리스트를 이용한 코드의 시간 복잡도가 O(N*NlogN)인데, N=10^5이므로 시간이 빠른 편은 아니다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">힙을 이용한다</span></strong>
    <ul>
      <li>maxHeap, minHeap 두 개를 사용하여 숫자 배열을 오름차순 정렬할 것이다.</li>
      <li>maxHeap의 leaf node -&gt; maxHeap root -&gt; minHeap root -&gt; minHeap leaf node 순으로 방문하면 숫자 배열을 오름차순 순회하는 것과 같다.</li>
      <li>따라서 maxHeap root는 minHeap root보다 작아야 한다.</li>
      <li>두 root 노드가 배열의 중간값이 되고, 중간값이 짝수인 경우 더 작은 값을 택한다고 했으므로 maxHeap root를 리턴하면 된다.</li>
      <li>따라서 maxHeap, minHeap 순으로 번갈아 숫자를 넣고, 두 root값을 체크하여 조건에 맞지 않는다면 swap하면 된다.</li>
      <li>참고로, 우선순위 큐에서 Comparator 쓰는 방법은 위 코드와 같이 두 개가 있다.</li>
    </ul>
  </li>
</ol>

<h3 id="5-성능">5. 성능</h3>
<ul>
  <li>시간 복잡도: O(NlogN)<br />
숫자 개수 N, 힙 정렬 logN  -&gt; O(NlogN)</li>
  <li>공간 복잡도: O(N)</li>
</ul>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[BOJ 백준] 가운데를 말해요(1655) Java <a href="https://subbak2.tistory.com/19">https://subbak2.tistory.com/19</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 6549번: 히스토그램에서 가장 큰 직사각형</title>
	  <link>/blog//algo-boj6549</link>
	  <author></author>
	  <pubDate>2020-11-05T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj6549</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/6549">https://www.acmicpc.net/problem/6549</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>스택을 이용한다.</li>
  <li>height[top]&gt;height[i]이면 top과 i를 포함하여 넓이를 만들 수 있으므로 pop하여 넓이를 계산한다.</li>
  <li>나보다 작은 높이 top이 나올 때까지 계속 계산한다.</li>
  <li>계산이 끝나면 i 뒤에서 나중에 i를 체크해볼 수 있도록 push</li>
  <li>n까지 체크가 끝나면 스택에 남은 값들도 계산해준다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>
		
		<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>			
			
			<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="k">if</span><span class="o">(</span><span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="k">break</span><span class="o">;</span>
			
			<span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
			<span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">=</span><span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
			<span class="kt">long</span> <span class="n">max</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 높이 저장</span>
				<span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="o">}</span>
			
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// i 포함 왼쪽으로 만들수 있는 넓이 체크함</span>
				<span class="c1">// 왼쪽에 나보다 큰 높이 발견-&gt;걔 포함해서 넓이 만들 수 있음</span>
				<span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">height</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
					<span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
					<span class="c1">// 맨 왼쪽에서 i까지이면 width=i, 부분 구간이면 ~.</span>
					<span class="kt">int</span> <span class="n">width</span><span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()?</span> <span class="nl">i:</span> <span class="n">i</span><span class="o">-</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
					<span class="n">max</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">width</span><span class="o">*</span><span class="n">height</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
				<span class="o">}</span>
				<span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
			<span class="o">}</span>
			
			<span class="c1">// 남은 값들도 계산</span>
			<span class="k">while</span><span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
				<span class="kt">int</span> <span class="n">width</span><span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()?</span> <span class="nl">n:</span> <span class="n">n</span><span class="o">-</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()-</span><span class="mi">1</span><span class="o">;</span>
				<span class="n">max</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span><span class="n">width</span><span class="o">*</span><span class="n">height</span><span class="o">[</span><span class="n">idx</span><span class="o">]);</span>
			<span class="o">}</span>
			
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">max</span><span class="o">);</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201105_2.PNG" alt="실행결과" />
🤟 성공 🤟<br />
이 문제 리트코드에서도 보고 꽤 많이 봤는데 아직도 잘 못 풀겠다.<br />
넓이 계산하면서 int형을 벗어날 수 있다는 것을 몰라 실패했다.</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">스택을 이용한다</span></strong>
    <ul>
      <li>세그먼트 트리로도 해결할 수 있다. 근데 스택이 더 익숙해서 스택 코드를 이해하려고 노력했다.</li>
      <li>i로 0~n까지 순회하며 넓이를 체크한다. i 기준 왼쪽으로 만들 수 있는 넓이를 계산한다.</li>
      <li>일단 넓이 계산이 끝나면, 다음 사용을 위해 i를 push해야 한다.</li>
      <li>넓이 계산은 스택의 top을 비교하면서 진행한다.</li>
      <li>h[top]&gt;h[i]여야 top을 포함하여 넓이를 계산할 수 있다.</li>
      <li>0~i까지 넓이를 구하는 것이라면 width=i, 그게 아니라면 i-st.top-1(이해 안됨).</li>
      <li>높이는 i가 기준이므로 width*height[i]이 넓이가 된다.</li>
      <li>최대 넓이를 구해야하므로 Math.max()를 이용하여 max에 최댓값을 넣는다.</li>
      <li>n까지 순회가 끝난 후, 스택을 확인하여 아직 값이 남아있다면 스택 top~n(마지막)까지의 넓이를 계산해준다.</li>
    </ul>
  </li>
</ol>

<h3 id="5-성능">5. 성능</h3>
<ul>
  <li>시간 복잡도: O(N)<br />
for문 탐색 N, 안에 while문은 N 이하의 시간, for 밖의 while도 N 이하의 시간</li>
  <li>공간 복잡도: O(N)<br />
height 배열 사이즈 N, 스택 사이즈 최대 N</li>
</ul>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>백준 6549 히스토그램에서 가장 큰 직사각형 Java <a href="https://dundung.tistory.com/96">https://dundung.tistory.com/96</a></li>
  <li>[BOJ 백준] 히스토그램에서 가장 큰 직사각형(6549) Java <a href="https://subbak2.tistory.com/25">https://subbak2.tistory.com/25</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1922번: 네트워크 연결</title>
	  <link>/blog//algo-boj1922</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1922</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1922">https://www.acmicpc.net/problem/1922</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>MST 문제이다.</li>
  <li>이를 해결하기 위해, 크루스칼 알고리즘을 쓴다.</li>
  <li>우선순위 큐를 이용해 최소비용 먼저 체크한다.</li>
  <li>a, b의 최상위 부모를 찾고, 같다면 이미 연결된 컴퓨터이므로 패스한다.</li>
  <li>아닐 경우 둘을 연결한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="cm">/*
 * MST?
 * int[] parent, 초기화
 * Node 클래스 생성하고, 우선순위 큐에 다 넣어
 * 부모가 같으면 패스, 다르면 union하고 sum+=weight*/</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>
		
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="n">pq</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 부모는 자기 자신</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">());</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 가중치 작은 것 먼저 뽑음</span>
			<span class="n">Node</span> <span class="n">node</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">parentS</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">start</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">parentE</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span><span class="o">);</span>
			<span class="k">if</span><span class="o">(</span><span class="n">parentS</span><span class="o">==</span><span class="n">parentE</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span> <span class="c1">// 둘이 연결되어 있는 경우이므로 패스</span>
			<span class="n">union</span><span class="o">(</span><span class="n">parentS</span><span class="o">,</span> <span class="n">parentE</span><span class="o">);</span> <span class="c1">// 둘을 연결 짓기</span>
			<span class="n">sum</span><span class="o">+=</span><span class="n">node</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span> <span class="c1">// 최소비용 추가</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// x의 최상위 부모 리턴</span>
		<span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">==</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">])</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// a, b를 연결</span>
		<span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">b</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">start</span><span class="o">=</span><span class="n">s</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">end</span><span class="o">=</span><span class="n">e</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_4.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">크루스칼 알고리즘을 이용한다</span></strong>
    <ul>
      <li>MST는 크루스칼 또는 프림으로 해결할 수 있다.</li>
      <li>크루스칼을 쓸 때는 둘의 최상위 부모를 체크하고, 같다면 이미 연결되어있는 것이므로 패스, 아니면 둘을 합친다. 이를 위해 Union-Find를 쓴다.</li>
      <li>MST는 결국 최소 가중치를 가지는 그래프를 만드는 것이기 때문에, 노드 탐색을 가중치가 작은 것들 먼저 확인해야 한다. 따라서 우선순위 큐를 이용한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[JAVA/백준] 1197번: 최소 스패닝 트리 <a href="https://iamheesoo.github.io/blog/algo-boj1197">https://iamheesoo.github.io/blog/algo-boj1197</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1525번: 퍼즐</title>
	  <link>/blog//algo-boj1525</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1525</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1525">https://www.acmicpc.net/problem/1525</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>map 숫자를 String 한 줄로 표현한다.</li>
  <li>String이 “123456780”이 아니라면 큐에 넣고 BFS 시작한다.</li>
  <li>String에서 0의 위치를 찾는다.</li>
  <li>거기서 사방으로 갈 수 있는 위치를 찾고 범위를 체크한다.</li>
  <li>swap(0, 새로운 인덱스)</li>
  <li>변경값이 “123456780”이면 맵에서 현재 String의 value+1을 리턴한다.</li>
  <li>맵에 없으면 맵, 큐에 push한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span> <span class="c1">// BFS 돌리기 위함</span>
		<span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">=</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// 중복 체크</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">replace</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
		<span class="o">}</span>
		
		<span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"123456780"</span><span class="o">))</span> <span class="c1">// 이미 완성된 퍼즐</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span>
		<span class="k">else</span> <span class="o">{</span>
			<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="mi">0</span><span class="o">);</span>
			<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>		
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">bfs</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">map</span><span class="o">));</span>			
		<span class="o">}</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="n">Queue</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">,</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">dotX</span><span class="o">=</span> <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">};</span>
		<span class="kt">int</span><span class="o">[]</span> <span class="n">dotY</span><span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">};</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">String</span> <span class="n">str</span><span class="o">=</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="kt">int</span> <span class="n">zeroIdx</span><span class="o">=</span><span class="n">str</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="s">"0"</span><span class="o">);</span> <span class="c1">// 0 위치 찾기</span>
			<span class="kt">int</span> <span class="n">row</span><span class="o">=</span><span class="n">zeroIdx</span><span class="o">/</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// map에서 행 위치</span>
			<span class="kt">int</span> <span class="n">col</span><span class="o">=</span><span class="n">zeroIdx</span><span class="o">%</span><span class="mi">3</span><span class="o">;</span> <span class="c1">// 열 위치</span>
			
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 이동 가능한 범위 체크</span>
				<span class="kt">int</span> <span class="n">xx</span><span class="o">=</span><span class="n">row</span><span class="o">+</span><span class="n">dotX</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="kt">int</span> <span class="n">yy</span><span class="o">=</span><span class="n">col</span><span class="o">+</span><span class="n">dotY</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
				<span class="k">if</span><span class="o">(</span><span class="n">xx</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">xx</span><span class="o">&gt;=</span><span class="mi">3</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">||</span> <span class="n">yy</span><span class="o">&gt;=</span><span class="mi">3</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>				
				<span class="kt">int</span> <span class="n">swapIdx</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">xx</span><span class="o">+</span><span class="n">yy</span><span class="o">;</span> <span class="c1">// 2차원 인덱스를 1차원으로 변환</span>
				
				<span class="c1">// 0과 바꿀 자리를 swap</span>
				<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
				<span class="kt">char</span> <span class="n">ch</span><span class="o">=</span><span class="n">sb</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">swapIdx</span><span class="o">);</span>
				<span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">swapIdx</span><span class="o">,</span> <span class="sc">'0'</span><span class="o">);</span>
				<span class="n">sb</span><span class="o">.</span><span class="na">setCharAt</span><span class="o">(</span><span class="n">zeroIdx</span><span class="o">,</span> <span class="n">ch</span><span class="o">);</span>
				
				<span class="c1">// 정답 찾음</span>
				<span class="k">if</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="s">"123456780"</span><span class="o">))</span> 
					<span class="k">return</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)+</span><span class="mi">1</span><span class="o">;</span>
				
				<span class="c1">// 새로 만들어진 문자열인 경우</span>
				<span class="k">if</span><span class="o">(!</span><span class="n">map</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">()))</span> <span class="o">{</span>
					<span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> <span class="c1">// 큐에 넣어 나중에 다시 체크</span>
					<span class="n">map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">(),</span> <span class="n">map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">2차원 map을 1차원 String으로 변환하여 사용한다</span></strong>
    <ul>
      <li>시간과 메모리의 제한이 있기 때문에, map의 숫자들을 한 줄로 표현하고, 인덱스별로 map에서 행, 열 위치를 찾아 swap하는 방식으로 구현한다.</li>
      <li>따라서 BufferedReader로 행을 받은 후, 공백을 제거하여 StringBuilder에 저장하였다.</li>
      <li>저장한 sb가 “123456780”이라면 bfs를 돌릴 필요가 없으므로 바로 0을 리턴하고 종료한다. BFS를 돌게 되면 리턴 값이 2가 되므로 조심해야한다.</li>
      <li>아닐 경우, 큐와 맵에 sb를 넣는다.</li>
      <li>맵의 K는 현재 숫자 문자열, V는 K가 되기까지 카운트한 횟수이다. 따라서 처음에는 0을 넣어야 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">BFS로 숫자를 바꾸며 조건에 맞는지 체크한다</span></strong>
    <ul>
      <li>큐에서 뽑은 값을 str에 저장한다.</li>
      <li>str에서 0의 위치를 찾아 zeroIdx에 저장한다.</li>
      <li>map에서 0의 위치 주변으로 바꿀 값을 찾아야 하기 때문에 map에서 0의 위치(i, j)를 찾아야 한다.</li>
      <li>행은 zeroIdx를 3으로 나눈 몫, 열은 나머지가 된다.</li>
      <li>찾은 row, col 주변으로 갈 수 있는 곳을 for문을 통해 찾는다.</li>
      <li>인덱스 범위를 체크한다.</li>
      <li>2차원 인덱스를 다시 1차원으로 변환하여 swapIdx에 넣는다.</li>
      <li>이제 0(zeroIdx)과 바꿀 값(swapIdx)를 바꿔준다.</li>
      <li>String에서도 바꿀 수 있지만 StringBuilder가 문자열 삽입 등에 더 최적화되어있으므로 str을 StringBuilder로 바꿔서 swap을 진행한다.</li>
      <li>바꿀 인덱스의 값을 ch에 저장하고, setCharAt()을 이용하여 문자열을 바꾼다.</li>
      <li>바꾼 문자열 sb.toString()이 “123456780”이라면 정답을 찾은 것이다. 현재 문자열 str의 카운트 횟수를 map에서 찾아 +1한 값을 리턴한다.</li>
      <li>아닐 경우 바꾼 문자열이 이전에 만든 적이 있는 것은 아닌지 체크해야한다. 큐에는 새로 만든 문자열만 들어가야 하므로(그래야 같은 경우를 또 탐색하는 것을 방지할 수 있다) 맵에서 새로 만든 문자열이 존재하는지 체크하고, 없을 경우에 큐와 맵에 삽입한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1197번: 최소 스패닝 트리</title>
	  <link>/blog//algo-boj1197</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1197</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1197">https://www.acmicpc.net/problem/1197</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>크루스칼 알고리즘을 이용한다(프림도 가능).</li>
  <li>가중치 기준 우선순위 큐에서 노드를 뽑는다.</li>
  <li>Union-Find를 이용해 start와 end가 연결되어있는지 확인한다(공통 부모 체크).</li>
  <li>아닐 경우 둘을 연결하고 가중치 합을 누적한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">static</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="n">pq</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
		<span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">e</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="n">parent</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">v</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">v</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">i</span><span class="o">;</span> <span class="c1">// 부모는 나 자신으로 초기화</span>
		
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">e</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span> <span class="c1">// 큐에 다 넣기</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">solve</span><span class="o">());</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">solve</span><span class="o">()</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 가중치 누적 합 계산</span>
		
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">Node</span> <span class="n">node</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="c1">// start, end의 부모 찾기</span>
			<span class="kt">int</span> <span class="n">parentS</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">start</span><span class="o">);</span>
			<span class="kt">int</span> <span class="n">parentE</span><span class="o">=</span><span class="n">find</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">end</span><span class="o">);</span>
			<span class="c1">// 부모가 다르다면(연결되어있지 않다면)</span>
			<span class="k">if</span><span class="o">(</span><span class="n">parentS</span><span class="o">!=</span><span class="n">parentE</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">union</span><span class="o">(</span><span class="n">parentS</span><span class="o">,</span> <span class="n">parentE</span><span class="o">);</span> <span class="c1">// 둘을 연결</span>
				<span class="n">sum</span><span class="o">+=</span><span class="n">node</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span> <span class="c1">// 가중치 계산</span>
			<span class="o">}</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]==</span><span class="n">x</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
		<span class="k">else</span> <span class="k">return</span> <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]=</span><span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">parent</span><span class="o">[</span><span class="n">a</span><span class="o">]=</span><span class="n">b</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;{</span>
	<span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">end</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">e</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">start</span><span class="o">=</span><span class="n">s</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">end</span><span class="o">=</span><span class="n">e</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 가중치 기준 오름차순 정렬</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_3.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">크루스칼 알고리즘을 이용한다</span></strong>
    <ul>
      <li>MST는 크루스칼 또는 프림으로 해결할 수 있다.</li>
      <li>E 개수가 적으면 크루스칼, V 개수가 적은 것은 프림을 쓰는게 좋다.</li>
      <li>크루스칼은 V가 작은 것부터 체크한다. 이를 위해 우선순위 큐를 이용한다. 가중치가 작은 것부터 확인하기 때문에 최소 weight로 노드들을 연결할 수 있다.</li>
      <li>사이클을 방지하기 위해 두 노드(start, end)의 최상위 부모를 체크하고, 부모가 다르면 두 노드가 연결되어 있지 않은 것이므로 연결한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[Java][자바][백준][1197번] 최소 스패닝 트리 - 크루스칼 알고리즘 <a href="https://ju-nam2.tistory.com/112">https://ju-nam2.tistory.com/112</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 10282번: 해킹</title>
	  <link>/blog//algo-boj10282</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj10282</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/10282">https://www.acmicpc.net/problem/10282</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>다익스트라를 이용하여 노드에서 다른 노드로 가는 최소 weight를 기준으로 이동한다.</li>
  <li>처음 방문하는 노드이면 cnt++하여 전파되는 컴퓨터의 개수를 센다.</li>
  <li>dist[] 배열에서 INF 값을 제외한 최댓값이 감염되는 최소시간이 된다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>	
	<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dist</span><span class="o">;</span>
	<span class="kd">static</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
	<span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">tc</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="k">while</span><span class="o">(</span><span class="n">tc</span><span class="o">--&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
			<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 총 컴퓨터 수</span>
			<span class="kt">int</span> <span class="n">d</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 감염 정보 수</span>
			<span class="kt">int</span> <span class="n">c</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span> <span class="c1">// 시작 컴퓨터</span>
			
			<span class="n">dist</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span> <span class="c1">// 0번은 사용 안함</span>
			<span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">dist</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span> <span class="c1">// INF로 초기화</span>
			<span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> 
				<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;());</span>
			<span class="n">cnt</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// 시작 컴퓨터는 이미 감염되었으므로</span>
			
			<span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">=</span><span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
			<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
			<span class="n">dist</span><span class="o">[</span><span class="n">c</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="c1">// 시작 노드이므로 0으로 초기화</span>
			
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">d</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
				<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">b</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
				<span class="kt">int</span> <span class="n">s</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>				
				<span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">b</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">s</span><span class="o">));</span> <span class="c1">// b-&gt;a로 감염됨</span>
			<span class="o">}</span>

			<span class="n">solve</span><span class="o">(</span><span class="n">pq</span><span class="o">);</span>
			<span class="c1">// dist에서 INF를 제외한 새 배열 생성</span>
			<span class="kt">int</span><span class="o">[]</span> <span class="n">result</span><span class="o">=</span><span class="n">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">dist</span><span class="o">).</span><span class="na">filter</span><span class="o">(</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">k</span><span class="o">!=</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
			<span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
			<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">cnt</span><span class="o">+</span><span class="s">" "</span><span class="o">+</span><span class="n">result</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]);</span>
		<span class="o">}</span>
		
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">solve</span><span class="o">(</span><span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">pq</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">pq</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">Node</span> <span class="n">node</span><span class="o">=</span><span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
			<span class="c1">// 내 weight가 계산된 dist보다 크다면 갱신할 필요 없음</span>
			<span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">weight</span><span class="o">&gt;</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">])</span> <span class="k">continue</span><span class="o">;</span>
			
			<span class="k">for</span><span class="o">(</span><span class="n">Node</span> <span class="nl">n:</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// node에서 갈 수 있는 n</span>
				<span class="c1">// n으로 가는 것 중 node에서 n으로 가는 경우가 더 최단이라면</span>
				<span class="k">if</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]&gt;</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">]+</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">)</span> <span class="o">{</span>
					<span class="k">if</span><span class="o">(</span><span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]==</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="n">cnt</span><span class="o">++;</span> <span class="c1">// n 방문이 처음이라면</span>
					<span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]=</span><span class="n">dist</span><span class="o">[</span><span class="n">node</span><span class="o">.</span><span class="na">idx</span><span class="o">]+</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
					<span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">,</span> <span class="n">dist</span><span class="o">[</span><span class="n">n</span><span class="o">.</span><span class="na">idx</span><span class="o">]));</span>
				<span class="o">}</span>
				
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;{</span>
	<span class="kt">int</span> <span class="n">idx</span><span class="o">;</span>
	<span class="kt">int</span> <span class="n">weight</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">w</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">idx</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">=</span><span class="n">w</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// weight 기준 오름차순 정렬</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">weight</span><span class="o">-</span><span class="n">n</span><span class="o">.</span><span class="na">weight</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">초기화 및 다익스트라 실행 준비</span></strong>
    <ul>
      <li>컴퓨터 인덱스는 1부터 시작하므로 dist, list를 n+1 크기로 생성한다.</li>
      <li>cnt는 감염 컴퓨터 개수로, 시작 컴퓨터가 이미 감염되었으므로 1로 초기화한다.</li>
      <li>우선순위 큐 pq에 시작 노드를 넣는다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">다익스트라</span></strong>
    <ul>
      <li>pq는 우선순위 큐이기 때문에 weight(감염 시간)이 작은 순으로 뽑힌다.</li>
      <li>뽑힌 노드 node의 weight를 체크하여 node에서 다음으로 이동할 수 있는지 확인해야 한다.</li>
      <li>예를 들어, 테스트케이스 2에서 1-&gt;3으로 가는 것 보다 1-&gt;2-&gt;3으로 가는 게 최단이다. 이를 거르는 작업이 처음 if문이다.</li>
      <li>for문을 통해 node에서 갈 수 있는, 연결된 노드 n을 하나씩 체크한다.</li>
      <li>n으로 가기 위해 node에서 n으로 가는 것이 기존 방법보다 최단이면 해당 값으로 갱신한다.</li>
      <li>이때 n이 처음 방문하는 노드라면 cnt++하여 감염된 컴퓨터가 하나 늘었음을 표시한다.</li>
      <li>pq에 삽입하여 n에서 갈 수 있는 노드들을 확인할 수 있도록 한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">감염 수와 최소 시간을 출력한다</span></strong>
    <ul>
      <li>감염 수는 cnt를 출력하면 된다.</li>
      <li>최소 시간은 dist에서 INF(Integer.MAX_VALUE)를 제외한 최댓값을 출력하면 된다.</li>
      <li>처음에는 max 변수를 두고 dist 배열에 값이 변경될 때마다 Math.max()를 이용하여 최댓값을 저장하도록 했는데, 그러면 기존 dist[i]보다 더 작은 dist[i]를 발견하여 값을 수정하였을 때, max에도 수정된 값으로 들어가야하지만 Math.max()로 인해 값이 갱신되지 않음을 알았다.</li>
      <li>따라서 람다식을 이용하여 dist에서 INF를 제외한 배열을 새로 만든 뒤(result), 이를 오름차순 정렬하여 마지막 값을 뽑았다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[백준 10282] - 해킹 <a href="https://soobarkbar.tistory.com/113">https://soobarkbar.tistory.com/113</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 2331번: 반복수열</title>
	  <link>/blog//algo-boj2331</link>
	  <author></author>
	  <pubDate>2020-11-04T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj2331</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/2331">https://www.acmicpc.net/problem/2331</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>문제대로 코드를 짠다.</li>
  <li>현재 숫자 num의 각 자리수에 p제곱한 값이 이전에 나온 값인지 확인하기 위해 HashSet을 이용한다.</li>
  <li>HashSet에 숫자들을 넣고 중복 체크한다.</li>
  <li>숫자들의 순서를 체크하기 위해 ArrayList를 이용한다.</li>
  <li>중복 숫자가 나오면 list에서 해당 숫자 인덱스를 리턴하면 된다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		
		<span class="kt">int</span> <span class="n">a</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>	
		<span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">=</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span> <span class="c1">// 숫자 순서대로 저장</span>
		<span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">set</span><span class="o">=</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;();</span> <span class="c1">// 숫자 중복 체크</span>
		<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		<span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
		
		<span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">num</span><span class="o">=</span><span class="n">makeNum</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span> <span class="c1">// 다음 숫자 계산</span>
			<span class="k">if</span><span class="o">(</span><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">num</span><span class="o">))</span> <span class="o">{</span> <span class="c1">// 반복 찾음</span>
				<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>
				<span class="k">break</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="c1">// 새로운 숫자일 경우 set, list에 add</span>
			<span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
			<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
			<span class="n">a</span><span class="o">=</span><span class="n">num</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">makeNum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">sum</span><span class="o">+=</span><span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="n">a</span><span class="o">%</span><span class="mi">10</span><span class="o">,</span> <span class="n">p</span><span class="o">);</span>
			<span class="n">a</span><span class="o">/=</span><span class="mi">10</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201104_5.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">수열을 구한다</span></strong>
    <ul>
      <li>새로운 숫자가 나오는지 체크해야하므로 HashSet을 이용한다.</li>
      <li>HashSet에 숫자들을 저장해놓고 중복 체크한다.</li>
      <li>숫자들의 순서도 중요하다. 따라서 ArrayList를 이용한다.</li>
      <li>다음 숫자(num)는 makeNum()을 이용해서 구한다.</li>
      <li>set에서 num이 있는지 체크한 후, 있다면 반복 구간을 찾은 것이므로 list에서 해당 인덱스를 리턴한다.</li>
      <li>없다면 아직 반복 구간이 아니므로 set, list에 넣는다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

<h3 id="참고">참고</h3>
<ul>
  <li>[BOJ] 백준 2331번 : 반복수열 (JAVA) <a href="https://steady-coding.tistory.com/32">https://steady-coding.tistory.com/32</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 14719번: 빗물</title>
	  <link>/blog//algo-boj14719</link>
	  <author></author>
	  <pubDate>2020-10-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj14719</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/14719">https://www.acmicpc.net/problem/14719</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>i 위치 기준 왼쪽과 오른쪽에서 가장 높은 높이를 구한다(자신 포함).</li>
  <li>‘왼쪽 오른쪽 중 작은 높이-내 높이’가 i 위치에서 빗물 넓이이다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">BufferedReader</span> <span class="n">br</span><span class="o">=</span><span class="k">new</span> <span class="n">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="n">InputStreamReader</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
		<span class="n">StringTokenizer</span> <span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		
		<span class="kt">int</span> <span class="n">h</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="kt">int</span> <span class="n">w</span><span class="o">=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		
		<span class="kt">int</span><span class="o">[]</span> <span class="n">height</span><span class="o">=</span><span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">w</span><span class="o">];</span>
		<span class="n">st</span><span class="o">=</span><span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 높이 저장</span>
			<span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">]=</span><span class="n">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
		<span class="o">}</span>
		
		<span class="kt">int</span> <span class="n">sum</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="kt">int</span> <span class="n">left</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">l</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span><span class="n">l</span><span class="o">--)</span> <span class="o">{</span> <span class="c1">// 왼쪽에서 가장 큰 높이 구하기</span>
				<span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">l</span><span class="o">]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">])</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="kt">int</span> <span class="n">right</span><span class="o">=</span><span class="n">i</span><span class="o">;</span>
			<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">i</span><span class="o">;</span><span class="n">r</span><span class="o">&lt;</span><span class="n">w</span><span class="o">;</span><span class="n">r</span><span class="o">++)</span> <span class="o">{</span> <span class="c1">// 오른쪽에서 가장 큰 높이</span>
				<span class="k">if</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">r</span><span class="o">]&gt;</span><span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="o">;</span>
			<span class="o">}</span>
			<span class="kt">int</span> <span class="n">size</span><span class="o">=</span><span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">height</span><span class="o">[</span><span class="n">left</span><span class="o">],</span> <span class="n">height</span><span class="o">[</span><span class="n">right</span><span class="o">])-</span><span class="n">height</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
			<span class="k">if</span><span class="o">(</span><span class="n">size</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="n">sum</span><span class="o">+=</span><span class="n">size</span><span class="o">;</span>
		<span class="o">}</span>
		
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
	<span class="o">}</span>
	
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201024_1.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">왼쪽과 오른쪽에서 큰 높이를 구한다</span></strong>
    <ul>
      <li>i번째 빗물 넓이는 왼쪽과 오른쪽의 큰 높이 중 작은 값을 택한 곳 만큼 올라가 있다.</li>
      <li>거기서 본인 높이를 빼면 넓이이다(i번째의 w는 1이므로 넓이 계산은 필요 없다).</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>

	<item>
	  <title>[JAVA/백준] 1158번: 요세푸스 문제</title>
	  <link>/blog//algo-boj1158</link>
	  <author></author>
	  <pubDate>2020-10-24T09:00:00+09:00</pubDate>
	  <guid>/blog//algo-boj1158</guid>
	  <description><![CDATA[
	     <h2 id="-문제"><span style="color:navy">👀 문제</span></h2>
<p><a href="https://www.acmicpc.net/problem/1158">https://www.acmicpc.net/problem/1158</a></p>

<h2 id="-도전"><span style="color:navy">👊 도전</span></h2>

<h3 id="1-설계">1. 설계</h3>
<ol>
  <li>큐에 값을 넣는다.</li>
  <li>k번째가 아니면 다시 뒤에 넣고, 맞으면 StringBuilder에 저장한다.</li>
</ol>

<h3 id="2-구현-성공-코드">2. 구현 (성공 코드)</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="cm">/**
 * @author HEESOO
 *
 */</span>
<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
		<span class="n">Scanner</span> <span class="n">sc</span><span class="o">=</span><span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
		<span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		<span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">sc</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
		
		<span class="n">StringBuilder</span> <span class="n">sb</span><span class="o">=</span><span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&lt;"</span><span class="o">);</span>
		<span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span><span class="n">i</span><span class="o">++)</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="c1">// 큐에 삽입</span>
		
		<span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span>
		<span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="n">cnt</span><span class="o">++;</span>
			<span class="k">if</span><span class="o">(</span><span class="n">cnt</span><span class="o">%</span><span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">", "</span><span class="o">);</span> <span class="c1">// k번째라면</span>
			<span class="k">else</span> <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">());</span> <span class="c1">// 아니라면 뒤에 삽입</span>
		<span class="o">}</span>
		
		<span class="n">sb</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">2</span><span class="o">,</span> <span class="n">sb</span><span class="o">.</span><span class="na">length</span><span class="o">());</span> <span class="c1">// 마지막에 콤마와 띄어쓰기가 있으므로 삭제</span>
		<span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&gt;"</span><span class="o">);</span>
		<span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="3-결과">3. 결과</h3>
<p><img src="./assets/images/201024_2.PNG" alt="실행결과" />
🤟 성공 🤟</p>

<h3 id="4-설명">4. 설명</h3>
<ol>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>배열이나 ArrayList의 인덱스를 가지고 for문 돌리면, 원소의 삭제 삽입이 반복되므로 오류가 발생할 수 있다.</li>
      <li>따라서 큐를 이용한다.</li>
    </ul>
  </li>
  <li><strong><span style="color:navy">큐를 이용한다</span></strong>
    <ul>
      <li>cnt는 이제 뽑을 원소가 몇 번째 값인지 체크한다.</li>
      <li>k의 배수 번째 값이라면 제거할 수 있다. 따라서 StringBuilder에 넣는다.</li>
      <li>아닐 경우 뒤에 삽입하여 순서를 다시 받는다.</li>
      <li>StringBuilder 생성이 끝나면 마지막에 “, “가 들어있기 때문에 delete()를 이용하여 삭제한다.</li>
    </ul>
  </li>
</ol>

<h2 id="-해결-완료"><span style="color:navy">👏 해결 완료!</span></h2>

	  ]]></description>
	</item>


</channel>
</rss>
